
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="http://www.khanlab.ca/zarrnii/reference/">
      
      
        <link rel="prev" href="../cli/">
      
      
        <link rel="next" href="../examples/zarr_nifti/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.23">
    
    
      
        <title>API Reference - ZarrNii Documentation</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.84d31ad4.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#api-reference" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="ZarrNii Documentation" class="md-header__button md-logo" aria-label="ZarrNii Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            ZarrNii Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              API Reference
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="ZarrNii Documentation" class="md-nav__button md-logo" aria-label="ZarrNii Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    ZarrNii Documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Walkthrough
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Walkthrough
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../walkthrough/overview/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Overview
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../walkthrough/getting_started/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Getting Started
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../walkthrough/basic_tasks/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Basic Tasks
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../walkthrough/advanced_use_cases/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Advanced Use Cases
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../cli/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Command Line Interface
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    API Reference
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    API Reference
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii" class="md-nav__link">
    <span class="md-ellipsis">
      ZarrNii
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii-attributes" class="md-nav__link">
    <span class="md-ellipsis">
      Attributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Attributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.data" class="md-nav__link">
    <span class="md-ellipsis">
      data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.darr" class="md-nav__link">
    <span class="md-ellipsis">
      darr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.shape" class="md-nav__link">
    <span class="md-ellipsis">
      shape
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.dims" class="md-nav__link">
    <span class="md-ellipsis">
      dims
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.scale" class="md-nav__link">
    <span class="md-ellipsis">
      scale
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.translation" class="md-nav__link">
    <span class="md-ellipsis">
      translation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.name" class="md-nav__link">
    <span class="md-ellipsis">
      name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.orientation" class="md-nav__link">
    <span class="md-ellipsis">
      orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.affine" class="md-nav__link">
    <span class="md-ellipsis">
      affine
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.axes" class="md-nav__link">
    <span class="md-ellipsis">
      axes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.coordinate_transformations" class="md-nav__link">
    <span class="md-ellipsis">
      coordinate_transformations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.omero" class="md-nav__link">
    <span class="md-ellipsis">
      omero
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Functions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_affine_transform" class="md-nav__link">
    <span class="md-ellipsis">
      get_affine_transform
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_zarr_store_info" class="md-nav__link">
    <span class="md-ellipsis">
      get_zarr_store_info
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.from_ngff_image" class="md-nav__link">
    <span class="md-ellipsis">
      from_ngff_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.from_darr" class="md-nav__link">
    <span class="md-ellipsis">
      from_darr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.from_ome_zarr" class="md-nav__link">
    <span class="md-ellipsis">
      from_ome_zarr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.from_nifti" class="md-nav__link">
    <span class="md-ellipsis">
      from_nifti
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.crop" class="md-nav__link">
    <span class="md-ellipsis">
      crop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.crop_with_bounding_box" class="md-nav__link">
    <span class="md-ellipsis">
      crop_with_bounding_box
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.crop_centered" class="md-nav__link">
    <span class="md-ellipsis">
      crop_centered
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.downsample" class="md-nav__link">
    <span class="md-ellipsis">
      downsample
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.upsample" class="md-nav__link">
    <span class="md-ellipsis">
      upsample
    </span>
  </a>
  
    <nav class="md-nav" aria-label="upsample">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.upsample--upsample-with-scaling-factors" class="md-nav__link">
    <span class="md-ellipsis">
      Upsample with scaling factors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.upsample--upsample-to-a-specific-shape" class="md-nav__link">
    <span class="md-ellipsis">
      Upsample to a specific shape
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_bounded_subregion" class="md-nav__link">
    <span class="md-ellipsis">
      get_bounded_subregion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.apply_transform" class="md-nav__link">
    <span class="md-ellipsis">
      apply_transform
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.to_ome_zarr" class="md-nav__link">
    <span class="md-ellipsis">
      to_ome_zarr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.to_nifti" class="md-nav__link">
    <span class="md-ellipsis">
      to_nifti
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.to_tiff_stack" class="md-nav__link">
    <span class="md-ellipsis">
      to_tiff_stack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.from_imaris" class="md-nav__link">
    <span class="md-ellipsis">
      from_imaris
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.to_imaris" class="md-nav__link">
    <span class="md-ellipsis">
      to_imaris
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.copy" class="md-nav__link">
    <span class="md-ellipsis">
      copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.compute" class="md-nav__link">
    <span class="md-ellipsis">
      compute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      get_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_zooms" class="md-nav__link">
    <span class="md-ellipsis">
      get_zooms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_origin" class="md-nav__link">
    <span class="md-ellipsis">
      get_origin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_affine_matrix" class="md-nav__link">
    <span class="md-ellipsis">
      get_affine_matrix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.apply_transform_ref_to_flo_indices" class="md-nav__link">
    <span class="md-ellipsis">
      apply_transform_ref_to_flo_indices
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.apply_transform_flo_to_ref_indices" class="md-nav__link">
    <span class="md-ellipsis">
      apply_transform_flo_to_ref_indices
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.list_channels" class="md-nav__link">
    <span class="md-ellipsis">
      list_channels
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.select_channels" class="md-nav__link">
    <span class="md-ellipsis">
      select_channels
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.select_timepoints" class="md-nav__link">
    <span class="md-ellipsis">
      select_timepoints
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.to_ngff_image" class="md-nav__link">
    <span class="md-ellipsis">
      to_ngff_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.segment" class="md-nav__link">
    <span class="md-ellipsis">
      segment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.segment_otsu" class="md-nav__link">
    <span class="md-ellipsis">
      segment_otsu
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.segment_threshold" class="md-nav__link">
    <span class="md-ellipsis">
      segment_threshold
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.compute_histogram" class="md-nav__link">
    <span class="md-ellipsis">
      compute_histogram
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.compute_otsu_thresholds" class="md-nav__link">
    <span class="md-ellipsis">
      compute_otsu_thresholds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.create_mip" class="md-nav__link">
    <span class="md-ellipsis">
      create_mip
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.compute_centroids" class="md-nav__link">
    <span class="md-ellipsis">
      compute_centroids
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.apply_scaled_processing" class="md-nav__link">
    <span class="md-ellipsis">
      apply_scaled_processing
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas" class="md-nav__link">
    <span class="md-ellipsis">
      ZarrNiiAtlas
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ZarrNiiAtlas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas--attributes" class="md-nav__link">
    <span class="md-ellipsis">
      Attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas-attributes" class="md-nav__link">
    <span class="md-ellipsis">
      Attributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Attributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.dseg" class="md-nav__link">
    <span class="md-ellipsis">
      dseg
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Functions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.create_from_dseg" class="md-nav__link">
    <span class="md-ellipsis">
      create_from_dseg
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.from_files" class="md-nav__link">
    <span class="md-ellipsis">
      from_files
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.from_itksnap_lut" class="md-nav__link">
    <span class="md-ellipsis">
      from_itksnap_lut
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.from_csv_lut" class="md-nav__link">
    <span class="md-ellipsis">
      from_csv_lut
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.from_tsv_lut" class="md-nav__link">
    <span class="md-ellipsis">
      from_tsv_lut
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.from_labelmapper_lut" class="md-nav__link">
    <span class="md-ellipsis">
      from_labelmapper_lut
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.get_region_info" class="md-nav__link">
    <span class="md-ellipsis">
      get_region_info
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.get_region_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_region_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.get_region_volume" class="md-nav__link">
    <span class="md-ellipsis">
      get_region_volume
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.aggregate_image_by_regions" class="md-nav__link">
    <span class="md-ellipsis">
      aggregate_image_by_regions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.create_feature_map" class="md-nav__link">
    <span class="md-ellipsis">
      create_feature_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.get_region_bounding_box" class="md-nav__link">
    <span class="md-ellipsis">
      get_region_bounding_box
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.sample_region_patches" class="md-nav__link">
    <span class="md-ellipsis">
      sample_region_patches
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.label_centroids" class="md-nav__link">
    <span class="md-ellipsis">
      label_centroids
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform" class="md-nav__link">
    <span class="md-ellipsis">
      AffineTransform
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Functions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform.from_txt" class="md-nav__link">
    <span class="md-ellipsis">
      from_txt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform.from_array" class="md-nav__link">
    <span class="md-ellipsis">
      from_array
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform.identity" class="md-nav__link">
    <span class="md-ellipsis">
      identity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform.apply_transform" class="md-nav__link">
    <span class="md-ellipsis">
      apply_transform
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform.invert" class="md-nav__link">
    <span class="md-ellipsis">
      invert
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform.update_for_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      update_for_orientation
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.transform.DisplacementTransform" class="md-nav__link">
    <span class="md-ellipsis">
      DisplacementTransform
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.transform.DisplacementTransform-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Functions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.DisplacementTransform.from_nifti" class="md-nav__link">
    <span class="md-ellipsis">
      from_nifti
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.DisplacementTransform.apply_transform" class="md-nav__link">
    <span class="md-ellipsis">
      apply_transform
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Examples
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Examples
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/zarr_nifti/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Working with Zarr and NIfTI
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/imaris_usage/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Working with Imaris Files
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/transformations/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Transformations
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/downsampling/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Downsampling and Upsampling
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/near_isotropic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Near-Isotropic Downsampling
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/atlas_example/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Atlases
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/ml_patch_sampling/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ML Training - Patch Sampling
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/multiscale/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Multiscale OME-Zarr
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/segmentation_example/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Segmentation Plugins
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/scaled_processing/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Scaled Processing Plugins
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../faq/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    FAQ
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../changelog/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Changelog
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../contributing/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Contributing
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii" class="md-nav__link">
    <span class="md-ellipsis">
      ZarrNii
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii-attributes" class="md-nav__link">
    <span class="md-ellipsis">
      Attributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Attributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.data" class="md-nav__link">
    <span class="md-ellipsis">
      data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.darr" class="md-nav__link">
    <span class="md-ellipsis">
      darr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.shape" class="md-nav__link">
    <span class="md-ellipsis">
      shape
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.dims" class="md-nav__link">
    <span class="md-ellipsis">
      dims
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.scale" class="md-nav__link">
    <span class="md-ellipsis">
      scale
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.translation" class="md-nav__link">
    <span class="md-ellipsis">
      translation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.name" class="md-nav__link">
    <span class="md-ellipsis">
      name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.orientation" class="md-nav__link">
    <span class="md-ellipsis">
      orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.affine" class="md-nav__link">
    <span class="md-ellipsis">
      affine
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.axes" class="md-nav__link">
    <span class="md-ellipsis">
      axes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.coordinate_transformations" class="md-nav__link">
    <span class="md-ellipsis">
      coordinate_transformations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.omero" class="md-nav__link">
    <span class="md-ellipsis">
      omero
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Functions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_affine_transform" class="md-nav__link">
    <span class="md-ellipsis">
      get_affine_transform
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_zarr_store_info" class="md-nav__link">
    <span class="md-ellipsis">
      get_zarr_store_info
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.from_ngff_image" class="md-nav__link">
    <span class="md-ellipsis">
      from_ngff_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.from_darr" class="md-nav__link">
    <span class="md-ellipsis">
      from_darr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.from_ome_zarr" class="md-nav__link">
    <span class="md-ellipsis">
      from_ome_zarr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.from_nifti" class="md-nav__link">
    <span class="md-ellipsis">
      from_nifti
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.crop" class="md-nav__link">
    <span class="md-ellipsis">
      crop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.crop_with_bounding_box" class="md-nav__link">
    <span class="md-ellipsis">
      crop_with_bounding_box
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.crop_centered" class="md-nav__link">
    <span class="md-ellipsis">
      crop_centered
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.downsample" class="md-nav__link">
    <span class="md-ellipsis">
      downsample
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.upsample" class="md-nav__link">
    <span class="md-ellipsis">
      upsample
    </span>
  </a>
  
    <nav class="md-nav" aria-label="upsample">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.upsample--upsample-with-scaling-factors" class="md-nav__link">
    <span class="md-ellipsis">
      Upsample with scaling factors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.upsample--upsample-to-a-specific-shape" class="md-nav__link">
    <span class="md-ellipsis">
      Upsample to a specific shape
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_bounded_subregion" class="md-nav__link">
    <span class="md-ellipsis">
      get_bounded_subregion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.apply_transform" class="md-nav__link">
    <span class="md-ellipsis">
      apply_transform
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.to_ome_zarr" class="md-nav__link">
    <span class="md-ellipsis">
      to_ome_zarr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.to_nifti" class="md-nav__link">
    <span class="md-ellipsis">
      to_nifti
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.to_tiff_stack" class="md-nav__link">
    <span class="md-ellipsis">
      to_tiff_stack
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.from_imaris" class="md-nav__link">
    <span class="md-ellipsis">
      from_imaris
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.to_imaris" class="md-nav__link">
    <span class="md-ellipsis">
      to_imaris
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.copy" class="md-nav__link">
    <span class="md-ellipsis">
      copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.compute" class="md-nav__link">
    <span class="md-ellipsis">
      compute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      get_orientation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_zooms" class="md-nav__link">
    <span class="md-ellipsis">
      get_zooms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_origin" class="md-nav__link">
    <span class="md-ellipsis">
      get_origin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.get_affine_matrix" class="md-nav__link">
    <span class="md-ellipsis">
      get_affine_matrix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.apply_transform_ref_to_flo_indices" class="md-nav__link">
    <span class="md-ellipsis">
      apply_transform_ref_to_flo_indices
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.apply_transform_flo_to_ref_indices" class="md-nav__link">
    <span class="md-ellipsis">
      apply_transform_flo_to_ref_indices
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.list_channels" class="md-nav__link">
    <span class="md-ellipsis">
      list_channels
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.select_channels" class="md-nav__link">
    <span class="md-ellipsis">
      select_channels
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.select_timepoints" class="md-nav__link">
    <span class="md-ellipsis">
      select_timepoints
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.to_ngff_image" class="md-nav__link">
    <span class="md-ellipsis">
      to_ngff_image
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.segment" class="md-nav__link">
    <span class="md-ellipsis">
      segment
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.segment_otsu" class="md-nav__link">
    <span class="md-ellipsis">
      segment_otsu
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.segment_threshold" class="md-nav__link">
    <span class="md-ellipsis">
      segment_threshold
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.compute_histogram" class="md-nav__link">
    <span class="md-ellipsis">
      compute_histogram
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.compute_otsu_thresholds" class="md-nav__link">
    <span class="md-ellipsis">
      compute_otsu_thresholds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.create_mip" class="md-nav__link">
    <span class="md-ellipsis">
      create_mip
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.compute_centroids" class="md-nav__link">
    <span class="md-ellipsis">
      compute_centroids
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNii.apply_scaled_processing" class="md-nav__link">
    <span class="md-ellipsis">
      apply_scaled_processing
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas" class="md-nav__link">
    <span class="md-ellipsis">
      ZarrNiiAtlas
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ZarrNiiAtlas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas--attributes" class="md-nav__link">
    <span class="md-ellipsis">
      Attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas-attributes" class="md-nav__link">
    <span class="md-ellipsis">
      Attributes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Attributes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.dseg" class="md-nav__link">
    <span class="md-ellipsis">
      dseg
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Functions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.create_from_dseg" class="md-nav__link">
    <span class="md-ellipsis">
      create_from_dseg
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.from_files" class="md-nav__link">
    <span class="md-ellipsis">
      from_files
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.from_itksnap_lut" class="md-nav__link">
    <span class="md-ellipsis">
      from_itksnap_lut
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.from_csv_lut" class="md-nav__link">
    <span class="md-ellipsis">
      from_csv_lut
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.from_tsv_lut" class="md-nav__link">
    <span class="md-ellipsis">
      from_tsv_lut
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.from_labelmapper_lut" class="md-nav__link">
    <span class="md-ellipsis">
      from_labelmapper_lut
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.get_region_info" class="md-nav__link">
    <span class="md-ellipsis">
      get_region_info
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.get_region_mask" class="md-nav__link">
    <span class="md-ellipsis">
      get_region_mask
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.get_region_volume" class="md-nav__link">
    <span class="md-ellipsis">
      get_region_volume
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.aggregate_image_by_regions" class="md-nav__link">
    <span class="md-ellipsis">
      aggregate_image_by_regions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.create_feature_map" class="md-nav__link">
    <span class="md-ellipsis">
      create_feature_map
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.get_region_bounding_box" class="md-nav__link">
    <span class="md-ellipsis">
      get_region_bounding_box
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.sample_region_patches" class="md-nav__link">
    <span class="md-ellipsis">
      sample_region_patches
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.ZarrNiiAtlas.label_centroids" class="md-nav__link">
    <span class="md-ellipsis">
      label_centroids
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform" class="md-nav__link">
    <span class="md-ellipsis">
      AffineTransform
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Functions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform.from_txt" class="md-nav__link">
    <span class="md-ellipsis">
      from_txt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform.from_array" class="md-nav__link">
    <span class="md-ellipsis">
      from_array
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform.identity" class="md-nav__link">
    <span class="md-ellipsis">
      identity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform.apply_transform" class="md-nav__link">
    <span class="md-ellipsis">
      apply_transform
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform.invert" class="md-nav__link">
    <span class="md-ellipsis">
      invert
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.AffineTransform.update_for_orientation" class="md-nav__link">
    <span class="md-ellipsis">
      update_for_orientation
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.transform.DisplacementTransform" class="md-nav__link">
    <span class="md-ellipsis">
      DisplacementTransform
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zarrnii.transform.DisplacementTransform-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Functions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.DisplacementTransform.from_nifti" class="md-nav__link">
    <span class="md-ellipsis">
      from_nifti
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zarrnii.transform.DisplacementTransform.apply_transform" class="md-nav__link">
    <span class="md-ellipsis">
      apply_transform
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="api-reference">API Reference</h1>


<div class="doc doc-object doc-class">



<a id="zarrnii.ZarrNii"></a>
    <div class="doc doc-contents first">


        <p>Zarr-based image with NIfTI compatibility using NgffImage internally.</p>
<p>This class provides chainable operations on OME-Zarr data while maintaining
compatibility with NIfTI workflows. It uses NgffImage objects internally for
better multiscale support and metadata preservation.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <ul>
        <li class="doc-section-item field-body">
          <b><code><span title="zarrnii.ZarrNii.ngff_image">ngff_image</span></code></b>
              (<code><span title="ngff_zarr.NgffImage">NgffImage</span></code>)
          
          <div class="doc-md-description">
            <p>The internal NgffImage object containing data and metadata.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
          <b><code><span title="zarrnii.ZarrNii.axes_order">axes_order</span></code></b>
              (<code><span title="str">str</span></code>)
          
          <div class="doc-md-description">
            <p>The order of the axes for NIfTI compatibility ('ZYX' or 'XYZ').</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
          <b><code><span title="zarrnii.ZarrNii.xyz_orientation">xyz_orientation</span></code></b>
              (<code><span title="str">str</span></code>)
          
          <div class="doc-md-description">
            <p>The anatomical orientation string in XYZ axes order (e.g., 'RAS', 'LPI').</p>
          </div>
        </li>
    </ul>

        <p>Constructor with backward compatibility for old signature.</p>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If affine parameter is provided</p>
          </div>
        </li>
    </ul>








                  <details class="quote">
                    <summary>Source code in <code>zarrnii/core.py</code></summary>
                    <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1655</span>
<span class="normal">1656</span>
<span class="normal">1657</span>
<span class="normal">1658</span>
<span class="normal">1659</span>
<span class="normal">1660</span>
<span class="normal">1661</span>
<span class="normal">1662</span>
<span class="normal">1663</span>
<span class="normal">1664</span>
<span class="normal">1665</span>
<span class="normal">1666</span>
<span class="normal">1667</span>
<span class="normal">1668</span>
<span class="normal">1669</span>
<span class="normal">1670</span>
<span class="normal">1671</span>
<span class="normal">1672</span>
<span class="normal">1673</span>
<span class="normal">1674</span>
<span class="normal">1675</span>
<span class="normal">1676</span>
<span class="normal">1677</span>
<span class="normal">1678</span>
<span class="normal">1679</span>
<span class="normal">1680</span>
<span class="normal">1681</span>
<span class="normal">1682</span>
<span class="normal">1683</span>
<span class="normal">1684</span>
<span class="normal">1685</span>
<span class="normal">1686</span>
<span class="normal">1687</span>
<span class="normal">1688</span>
<span class="normal">1689</span>
<span class="normal">1690</span>
<span class="normal">1691</span>
<span class="normal">1692</span>
<span class="normal">1693</span>
<span class="normal">1694</span>
<span class="normal">1695</span>
<span class="normal">1696</span>
<span class="normal">1697</span>
<span class="normal">1698</span>
<span class="normal">1699</span>
<span class="normal">1700</span>
<span class="normal">1701</span>
<span class="normal">1702</span>
<span class="normal">1703</span>
<span class="normal">1704</span>
<span class="normal">1705</span>
<span class="normal">1706</span>
<span class="normal">1707</span>
<span class="normal">1708</span>
<span class="normal">1709</span>
<span class="normal">1710</span>
<span class="normal">1711</span>
<span class="normal">1712</span>
<span class="normal">1713</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">darr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">axes_order</span><span class="o">=</span><span class="s2">&quot;ZYX&quot;</span><span class="p">,</span>
    <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;RAS&quot;</span><span class="p">,</span>
    <span class="n">xyz_orientation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ngff_image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">spacing</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
    <span class="n">origin</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span><span class="p">,</span>
    <span class="n">_omero</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">affine</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AffineTransform</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructor with backward compatibility for old signature.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If affine parameter is provided</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check for deprecated affine parameter</span>
    <span class="k">if</span> <span class="n">affine</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The &#39;affine&#39; parameter is no longer supported in ZarrNii(). &quot;</span>
            <span class="s2">&quot;Please use &#39;spacing&#39; and &#39;origin&#39; parameters instead. &quot;</span>
            <span class="s2">&quot;If you need to specify a full affine transformation, use from_nifti() &quot;</span>
            <span class="s2">&quot;or construct the NgffImage directly.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Handle backwards compatibility: if xyz_orientation is provided, use it</span>
    <span class="c1"># Otherwise, use orientation for backwards compatibility</span>
    <span class="n">final_orientation</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">xyz_orientation</span> <span class="k">if</span> <span class="n">xyz_orientation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">orientation</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">ngff_image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># New signature</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ngff_image&quot;</span><span class="p">,</span> <span class="n">ngff_image</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;axes_order&quot;</span><span class="p">,</span> <span class="n">axes_order</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;xyz_orientation&quot;</span><span class="p">,</span> <span class="n">final_orientation</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_omero&quot;</span><span class="p">,</span> <span class="n">_omero</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">darr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Legacy signature - delegate to from_darr</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_darr</span><span class="p">(</span>
            <span class="n">darr</span><span class="o">=</span><span class="n">darr</span><span class="p">,</span>
            <span class="n">axes_order</span><span class="o">=</span><span class="n">axes_order</span><span class="p">,</span>
            <span class="n">orientation</span><span class="o">=</span><span class="n">final_orientation</span><span class="p">,</span>
            <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">omero</span><span class="o">=</span><span class="n">_omero</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ngff_image&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">ngff_image</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;axes_order&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">axes_order</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;xyz_orientation&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_omero&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">_omero</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide either ngff_image or darr&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
                  </details>



  <div class="doc doc-children">





<h2 id="zarrnii.ZarrNii-attributes">Attributes</h2>

<div class="doc doc-object doc-attribute">



<h3 id="zarrnii.ZarrNii.data" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">data</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Access the image data (dask array).</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="zarrnii.ZarrNii.darr" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">darr</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Legacy property name for image data.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="zarrnii.ZarrNii.shape" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">shape</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Shape of the image data.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="zarrnii.ZarrNii.dims" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">dims</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Dimension names.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="zarrnii.ZarrNii.scale" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">scale</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Scale information from NgffImage.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="zarrnii.ZarrNii.translation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">translation</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Translation information from NgffImage.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="zarrnii.ZarrNii.name" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">name</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Image name from NgffImage.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="zarrnii.ZarrNii.orientation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">orientation</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Legacy property for backward compatibility.</p>
<p>Returns the xyz_orientation attribute to maintain backward compatibility
with code that expects the 'orientation' property.</p>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>str</code></b> (              <code><span title="str">str</span></code>
)          
          <div class="doc-md-description">
            <p>The anatomical orientation string in XYZ axes order</p>
          </div>
        </li>
    </ul>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="zarrnii.ZarrNii.affine" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">affine</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Affine transformation matrix derived from NgffImage scale and translation.</p>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>AffineTransform</code></b> (              <code><a class="autorefs autorefs-internal" title="zarrnii.transform.AffineTransform" href="#zarrnii.transform.AffineTransform">AffineTransform</a></code>
)          
          <div class="doc-md-description">
            <p>4x4 affine transformation matrix in axes order of self.</p>
          </div>
        </li>
    </ul>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="zarrnii.ZarrNii.axes" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">axes</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Axes metadata - derived from NgffImage for compatibility.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="zarrnii.ZarrNii.coordinate_transformations" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">coordinate_transformations</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Coordinate transformations - derived from NgffImage scale/translation.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="zarrnii.ZarrNii.omero" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">omero</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Omero metadata object.</p>

    </div>

</div>


<h2 id="zarrnii.ZarrNii-functions">Functions</h2>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.get_affine_transform" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">get_affine_transform</span><span class="p">(</span><span class="n">axes_order</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Get AffineTransform object from NgffImage metadata.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>axes_order</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Spatial axes order, defaults to self.axes_order</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><a class="autorefs autorefs-internal" title="zarrnii.transform.AffineTransform" href="#zarrnii.transform.AffineTransform">AffineTransform</a></code>
          
          <div class="doc-md-description">
            <p>AffineTransform object</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_affine_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes_order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AffineTransform</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get AffineTransform object from NgffImage metadata.</span>

<span class="sd">    Args:</span>
<span class="sd">        axes_order: Spatial axes order, defaults to self.axes_order</span>

<span class="sd">    Returns:</span>
<span class="sd">        AffineTransform object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine_matrix</span><span class="p">(</span><span class="n">axes_order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AffineTransform</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.get_zarr_store_info" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">get_zarr_store_info</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Extract zarr store information from the dask array if available.</p>
<p>Attempts to extract the underlying zarr store path and metadata from
the dask array graph. This information can be used for direct zarr
access without triggering dask compute() operations.</p>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="typing.Optional">Optional</span>[<span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]]</code>
          
          <div class="doc-md-description">
            <p>Dictionary containing store information if available:
- 'store_path': Path or URI to the zarr store
- 'dataset_path': Path to the dataset within the zarr group
- 'array_shape': Shape of the full array</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.Optional">Optional</span>[<span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]]</code>
          
          <div class="doc-md-description">
            <p>Returns None if the data is not backed by a zarr store.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If the dask array shape doesn't match the zarr array shape,
indicating lazy operations that change shape (e.g., downsampling).</p>
          </div>
        </li>
    </ul>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Only works if the dask array was created from zarr using da.from_zarr()</li>
<li>Returns None for in-memory arrays or arrays from other sources</li>
<li>Validates that zarr array shape matches dask array shape to ensure
  compatibility with direct zarr access</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span>
<span class="normal">1393</span>
<span class="normal">1394</span>
<span class="normal">1395</span>
<span class="normal">1396</span>
<span class="normal">1397</span>
<span class="normal">1398</span>
<span class="normal">1399</span>
<span class="normal">1400</span>
<span class="normal">1401</span>
<span class="normal">1402</span>
<span class="normal">1403</span>
<span class="normal">1404</span>
<span class="normal">1405</span>
<span class="normal">1406</span>
<span class="normal">1407</span>
<span class="normal">1408</span>
<span class="normal">1409</span>
<span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span>
<span class="normal">1420</span>
<span class="normal">1421</span>
<span class="normal">1422</span>
<span class="normal">1423</span>
<span class="normal">1424</span>
<span class="normal">1425</span>
<span class="normal">1426</span>
<span class="normal">1427</span>
<span class="normal">1428</span>
<span class="normal">1429</span>
<span class="normal">1430</span>
<span class="normal">1431</span>
<span class="normal">1432</span>
<span class="normal">1433</span>
<span class="normal">1434</span>
<span class="normal">1435</span>
<span class="normal">1436</span>
<span class="normal">1437</span>
<span class="normal">1438</span>
<span class="normal">1439</span>
<span class="normal">1440</span>
<span class="normal">1441</span>
<span class="normal">1442</span>
<span class="normal">1443</span>
<span class="normal">1444</span>
<span class="normal">1445</span>
<span class="normal">1446</span>
<span class="normal">1447</span>
<span class="normal">1448</span>
<span class="normal">1449</span>
<span class="normal">1450</span>
<span class="normal">1451</span>
<span class="normal">1452</span>
<span class="normal">1453</span>
<span class="normal">1454</span>
<span class="normal">1455</span>
<span class="normal">1456</span>
<span class="normal">1457</span>
<span class="normal">1458</span>
<span class="normal">1459</span>
<span class="normal">1460</span>
<span class="normal">1461</span>
<span class="normal">1462</span>
<span class="normal">1463</span>
<span class="normal">1464</span>
<span class="normal">1465</span>
<span class="normal">1466</span>
<span class="normal">1467</span>
<span class="normal">1468</span>
<span class="normal">1469</span>
<span class="normal">1470</span>
<span class="normal">1471</span>
<span class="normal">1472</span>
<span class="normal">1473</span>
<span class="normal">1474</span>
<span class="normal">1475</span>
<span class="normal">1476</span>
<span class="normal">1477</span>
<span class="normal">1478</span>
<span class="normal">1479</span>
<span class="normal">1480</span>
<span class="normal">1481</span>
<span class="normal">1482</span>
<span class="normal">1483</span>
<span class="normal">1484</span>
<span class="normal">1485</span>
<span class="normal">1486</span>
<span class="normal">1487</span>
<span class="normal">1488</span>
<span class="normal">1489</span>
<span class="normal">1490</span>
<span class="normal">1491</span>
<span class="normal">1492</span>
<span class="normal">1493</span>
<span class="normal">1494</span>
<span class="normal">1495</span>
<span class="normal">1496</span>
<span class="normal">1497</span>
<span class="normal">1498</span>
<span class="normal">1499</span>
<span class="normal">1500</span>
<span class="normal">1501</span>
<span class="normal">1502</span>
<span class="normal">1503</span>
<span class="normal">1504</span>
<span class="normal">1505</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_zarr_store_info</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract zarr store information from the dask array if available.</span>

<span class="sd">    Attempts to extract the underlying zarr store path and metadata from</span>
<span class="sd">    the dask array graph. This information can be used for direct zarr</span>
<span class="sd">    access without triggering dask compute() operations.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dictionary containing store information if available:</span>
<span class="sd">            - &#39;store_path&#39;: Path or URI to the zarr store</span>
<span class="sd">            - &#39;dataset_path&#39;: Path to the dataset within the zarr group</span>
<span class="sd">            - &#39;array_shape&#39;: Shape of the full array</span>
<span class="sd">        Returns None if the data is not backed by a zarr store.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the dask array shape doesn&#39;t match the zarr array shape,</span>
<span class="sd">            indicating lazy operations that change shape (e.g., downsampling).</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Only works if the dask array was created from zarr using da.from_zarr()</span>
<span class="sd">        - Returns None for in-memory arrays or arrays from other sources</span>
<span class="sd">        - Validates that zarr array shape matches dask array shape to ensure</span>
<span class="sd">          compatibility with direct zarr access</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Check if the dask array has a graph</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">__dask_graph__</span><span class="p">()</span>

        <span class="c1"># Look for zarr array in the graph</span>
        <span class="c1"># The first key in a from_zarr graph typically contains the zarr array</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c1"># Check if this is a zarr array</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="s2">&quot;store&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
                <span class="c1"># Extract store information</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">zarr</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">zarr.storage</span>

                <span class="n">store</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">store</span>
                <span class="n">dataset_path</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>

                <span class="c1"># Determine store path based on store type</span>
                <span class="c1"># Handle both zarr v2 and v3 store types</span>
                <span class="n">store_path</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Try zarr v3 LocalStore first (has &#39;root&#39; attribute)</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s2">&quot;root&quot;</span><span class="p">):</span>
                    <span class="n">store_path</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">root</span>
                <span class="c1"># Try zarr v2 DirectoryStore (has &#39;path&#39; attribute)</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s2">&quot;path&quot;</span><span class="p">):</span>
                    <span class="n">store_path</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">path</span>
                <span class="c1"># Try string representation as fallback</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">store_path</span> <span class="o">=</span> <span class="n">store</span>
                <span class="c1"># Try str(store) which works for LocalStore</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">store_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
                    <span class="c1"># LocalStore repr is like &quot;file:///path/to/store&quot;</span>
                    <span class="k">if</span> <span class="n">store_str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;file://&quot;</span><span class="p">):</span>
                        <span class="n">store_path</span> <span class="o">=</span> <span class="n">store_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;file://&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">store_path</span> <span class="o">=</span> <span class="n">store_str</span>

                <span class="k">if</span> <span class="n">store_path</span><span class="p">:</span>
                    <span class="c1"># Validate that the zarr array shape matches the dask array shape</span>
                    <span class="c1"># This ensures no lazy operations have changed the shape</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Convert store_path to string in case it&#39;s a Path object</span>
                        <span class="n">store_path_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">store_path</span><span class="p">)</span>

                        <span class="c1"># Open the zarr store to get the actual array shape</span>
                        <span class="k">if</span> <span class="n">store_path_str</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.zip&quot;</span><span class="p">):</span>
                            <span class="n">zarr_store</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">ZipStore</span><span class="p">(</span>
                                <span class="n">store_path_str</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span>
                            <span class="p">)</span>
                            <span class="n">root</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="n">zarr_store</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
                            <span class="n">zarr_array</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">dataset_path</span><span class="p">]</span>
                            <span class="n">zarr_store</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">root</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="n">store_path_str</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
                            <span class="n">zarr_array</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="n">dataset_path</span><span class="p">]</span>

                        <span class="n">zarr_shape</span> <span class="o">=</span> <span class="n">zarr_array</span><span class="o">.</span><span class="n">shape</span>
                        <span class="n">dask_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

                        <span class="c1"># Check if spatial dimensions match</span>
                        <span class="c1"># Extract indices of spatial dimensions (x, y, z)</span>
                        <span class="n">spatial_dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>
                        <span class="n">spatial_indices</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">i</span>
                            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">spatial_dims</span>
                        <span class="p">]</span>

                        <span class="c1"># Compare only spatial dimensions</span>
                        <span class="n">zarr_spatial_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                            <span class="n">zarr_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">spatial_indices</span>
                        <span class="p">)</span>
                        <span class="n">dask_spatial_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                            <span class="n">dask_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">spatial_indices</span>
                        <span class="p">)</span>

                        <span class="k">if</span> <span class="n">zarr_spatial_shape</span> <span class="o">!=</span> <span class="n">dask_spatial_shape</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Cannot use direct zarr access for apply_transform: &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;the floating image has lazy operations that change its shape. &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Zarr array shape: </span><span class="si">{</span><span class="n">zarr_shape</span><span class="si">}</span><span class="s2">, but dask array shape: </span><span class="si">{</span><span class="n">dask_shape</span><span class="si">}</span><span class="s2">. &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;Spatial dimensions - Zarr: </span><span class="si">{</span><span class="n">zarr_spatial_shape</span><span class="si">}</span><span class="s2">, Dask: </span><span class="si">{</span><span class="n">dask_spatial_shape</span><span class="si">}</span><span class="s2">. &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;This typically happens when using downsample levels beyond what exists &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;in the zarr store, or when using downsample_near_isotropic option. &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;To fix this, save the floating image to an intermediate zarr file first:</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;  flo_znimg.to_ome_zarr(&#39;intermediate.zarr&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;  flo_znimg = ZarrNii.from_ome_zarr(&#39;intermediate.zarr&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;  transformed = flo_znimg.apply_transform(...)&quot;</span>
                            <span class="p">)</span>

                    <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">FileNotFoundError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="c1"># Dataset doesn&#39;t exist at the specified path</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Cannot use direct zarr access for apply_transform: &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;the specified dataset &#39;</span><span class="si">{</span><span class="n">dataset_path</span><span class="si">}</span><span class="s2">&#39; does not exist in the zarr store &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;at &#39;</span><span class="si">{</span><span class="n">store_path</span><span class="si">}</span><span class="s2">&#39;. This may happen when using a downsample level that &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;doesn&#39;t exist in the zarr store. &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;To fix this, save the floating image to an intermediate zarr file first:</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;  flo_znimg.to_ome_zarr(&#39;intermediate.zarr&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;  flo_znimg = ZarrNii.from_ome_zarr(&#39;intermediate.zarr&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;  transformed = flo_znimg.apply_transform(...)&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

                    <span class="k">return</span> <span class="p">{</span>
                        <span class="s2">&quot;store_path&quot;</span><span class="p">:</span> <span class="n">store_path</span><span class="p">,</span>
                        <span class="s2">&quot;dataset_path&quot;</span><span class="p">:</span> <span class="n">dataset_path</span><span class="p">,</span>
                        <span class="s2">&quot;array_shape&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                    <span class="p">}</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># Re-raise ValueError (our validation errors)</span>
        <span class="k">raise</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="c1"># If we can&#39;t extract store info for other reasons, return None</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.from_ngff_image" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_ngff_image</span><span class="p">(</span><span class="n">ngff_image</span><span class="p">,</span> <span class="n">axes_order</span><span class="o">=</span><span class="s1">&#39;ZYX&#39;</span><span class="p">,</span> <span class="n">xyz_orientation</span><span class="o">=</span><span class="s1">&#39;RAS&#39;</span><span class="p">,</span> <span class="n">omero</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create ZarrNii from an existing NgffImage.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>ngff_image</code></b>
              (<code><span title="ngff_zarr.NgffImage">NgffImage</span></code>)
          
          <div class="doc-md-description">
            <p>NgffImage to wrap</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>axes_order</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;ZYX&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Spatial axes order for NIfTI compatibility</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>xyz_orientation</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;RAS&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Anatomical orientation string in XYZ axes order</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>omero</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="object">object</span>]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional omero metadata object</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>ZarrNii instance</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1554</span>
<span class="normal">1555</span>
<span class="normal">1556</span>
<span class="normal">1557</span>
<span class="normal">1558</span>
<span class="normal">1559</span>
<span class="normal">1560</span>
<span class="normal">1561</span>
<span class="normal">1562</span>
<span class="normal">1563</span>
<span class="normal">1564</span>
<span class="normal">1565</span>
<span class="normal">1566</span>
<span class="normal">1567</span>
<span class="normal">1568</span>
<span class="normal">1569</span>
<span class="normal">1570</span>
<span class="normal">1571</span>
<span class="normal">1572</span>
<span class="normal">1573</span>
<span class="normal">1574</span>
<span class="normal">1575</span>
<span class="normal">1576</span>
<span class="normal">1577</span>
<span class="normal">1578</span>
<span class="normal">1579</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_ngff_image</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span>
    <span class="n">ngff_image</span><span class="p">:</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">,</span>
    <span class="n">axes_order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ZYX&quot;</span><span class="p">,</span>
    <span class="n">xyz_orientation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;RAS&quot;</span><span class="p">,</span>
    <span class="n">omero</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create ZarrNii from an existing NgffImage.</span>

<span class="sd">    Args:</span>
<span class="sd">        ngff_image: NgffImage to wrap</span>
<span class="sd">        axes_order: Spatial axes order for NIfTI compatibility</span>
<span class="sd">        xyz_orientation: Anatomical orientation string in XYZ axes order</span>
<span class="sd">        omero: Optional omero metadata object</span>

<span class="sd">    Returns:</span>
<span class="sd">        ZarrNii instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">_omero</span><span class="o">=</span><span class="n">omero</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.from_darr" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_darr</span><span class="p">(</span><span class="n">darr</span><span class="p">,</span> <span class="n">axes_order</span><span class="o">=</span><span class="s1">&#39;ZYX&#39;</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;RAS&#39;</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;image&#39;</span><span class="p">,</span> <span class="n">omero</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create ZarrNii from dask array (legacy compatibility constructor).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>darr</code></b>
              (<code><span title="dask.array.Array">Array</span></code>)
          
          <div class="doc-md-description">
            <p>Dask array containing image data</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>axes_order</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;ZYX&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Spatial axes order</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>orientation</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;RAS&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Anatomical orientation string</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>spacing</code></b>
              (<code><span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>]</code>, default:
                  <code>(1.0, 1.0, 1.0)</code>
)
          
          <div class="doc-md-description">
            <p>Voxel spacing, in axes_order</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>origin</code></b>
              (<code><span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>]</code>, default:
                  <code>(0.0, 0.0, 0.0)</code>
)
          
          <div class="doc-md-description">
            <p>Origin offset, in axes_order</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>name</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;image&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Image name</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>omero</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="object">object</span>]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional omero metadata</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>affine</code></b>
              (<code><span title="typing.Optional">Optional</span>[<a class="autorefs autorefs-internal" title="zarrnii.transform.AffineTransform" href="#zarrnii.transform.AffineTransform">AffineTransform</a>]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Deprecated parameter - no longer supported</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>ZarrNii instance</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If affine parameter is provided</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1581</span>
<span class="normal">1582</span>
<span class="normal">1583</span>
<span class="normal">1584</span>
<span class="normal">1585</span>
<span class="normal">1586</span>
<span class="normal">1587</span>
<span class="normal">1588</span>
<span class="normal">1589</span>
<span class="normal">1590</span>
<span class="normal">1591</span>
<span class="normal">1592</span>
<span class="normal">1593</span>
<span class="normal">1594</span>
<span class="normal">1595</span>
<span class="normal">1596</span>
<span class="normal">1597</span>
<span class="normal">1598</span>
<span class="normal">1599</span>
<span class="normal">1600</span>
<span class="normal">1601</span>
<span class="normal">1602</span>
<span class="normal">1603</span>
<span class="normal">1604</span>
<span class="normal">1605</span>
<span class="normal">1606</span>
<span class="normal">1607</span>
<span class="normal">1608</span>
<span class="normal">1609</span>
<span class="normal">1610</span>
<span class="normal">1611</span>
<span class="normal">1612</span>
<span class="normal">1613</span>
<span class="normal">1614</span>
<span class="normal">1615</span>
<span class="normal">1616</span>
<span class="normal">1617</span>
<span class="normal">1618</span>
<span class="normal">1619</span>
<span class="normal">1620</span>
<span class="normal">1621</span>
<span class="normal">1622</span>
<span class="normal">1623</span>
<span class="normal">1624</span>
<span class="normal">1625</span>
<span class="normal">1626</span>
<span class="normal">1627</span>
<span class="normal">1628</span>
<span class="normal">1629</span>
<span class="normal">1630</span>
<span class="normal">1631</span>
<span class="normal">1632</span>
<span class="normal">1633</span>
<span class="normal">1634</span>
<span class="normal">1635</span>
<span class="normal">1636</span>
<span class="normal">1637</span>
<span class="normal">1638</span>
<span class="normal">1639</span>
<span class="normal">1640</span>
<span class="normal">1641</span>
<span class="normal">1642</span>
<span class="normal">1643</span>
<span class="normal">1644</span>
<span class="normal">1645</span>
<span class="normal">1646</span>
<span class="normal">1647</span>
<span class="normal">1648</span>
<span class="normal">1649</span>
<span class="normal">1650</span>
<span class="normal">1651</span>
<span class="normal">1652</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_darr</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span>
    <span class="n">darr</span><span class="p">:</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span>
    <span class="n">axes_order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ZYX&quot;</span><span class="p">,</span>
    <span class="n">orientation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;RAS&quot;</span><span class="p">,</span>
    <span class="n">spacing</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
    <span class="n">origin</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span><span class="p">,</span>
    <span class="n">omero</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">affine</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AffineTransform</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create ZarrNii from dask array (legacy compatibility constructor).</span>

<span class="sd">    Args:</span>
<span class="sd">        darr: Dask array containing image data</span>
<span class="sd">        axes_order: Spatial axes order</span>
<span class="sd">        orientation: Anatomical orientation string</span>
<span class="sd">        spacing: Voxel spacing, in axes_order</span>
<span class="sd">        origin: Origin offset, in axes_order</span>
<span class="sd">        name: Image name</span>
<span class="sd">        omero: Optional omero metadata</span>
<span class="sd">        affine: Deprecated parameter - no longer supported</span>

<span class="sd">    Returns:</span>
<span class="sd">        ZarrNii instance</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If affine parameter is provided</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check for deprecated affine parameter</span>
    <span class="k">if</span> <span class="n">affine</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The &#39;affine&#39; parameter is no longer supported in from_darr(). &quot;</span>
            <span class="s2">&quot;Please use &#39;spacing&#39; and &#39;origin&#39; parameters instead. &quot;</span>
            <span class="s2">&quot;If you need to specify a full affine transformation, use from_nifti() &quot;</span>
            <span class="s2">&quot;or construct the NgffImage directly.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Use spacing and origin</span>
    <span class="k">if</span> <span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># XYZ</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">origin</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span>

    <span class="c1"># Create dimensions based on data shape after dimension adjustments</span>
    <span class="n">final_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">darr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">final_ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># 4D: (c, z, y, x) or (c, x, y, z) - standard case</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes_order</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">final_ndim</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="c1"># 5D: (t, c, z, y, x) or (t, c, x, y, z) - time dimension included</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes_order</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Fallback for other cases</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes_order</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

    <span class="c1"># Create NgffImage</span>
    <span class="n">ngff_image</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">darr</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="n">translation</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span>
        <span class="n">_omero</span><span class="o">=</span><span class="n">omero</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.from_ome_zarr" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_ome_zarr</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timepoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">storage_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes_order</span><span class="o">=</span><span class="s1">&#39;ZYX&#39;</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">downsample_near_isotropic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">rechunk</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Load ZarrNii from OME-Zarr store with flexible options.</p>
<p>Creates a ZarrNii instance from an OME-Zarr store, supporting multiscale
pyramids, channel/timepoint selection, and various storage backends.
Automatically handles metadata extraction and format conversion.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>store_or_path</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]</code>)
          
          <div class="doc-md-description">
            <p>Store or path to OME-Zarr file. Supports:
- Local file paths
- Remote URLs (s3://, http://, etc.)
- ZIP files (.zip extension)
- Zarr store objects</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>level</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>0</code>
)
          
          <div class="doc-md-description">
            <p>Pyramid level to load (0 = highest resolution). If level
exceeds available levels, applies lazy downsampling</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>channels</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="int">int</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>List of channel indices to load (0-based). Mutually
exclusive with channel_labels</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>channel_labels</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="str">str</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>List of channel names to load by label. Requires
OMERO metadata. Mutually exclusive with channels</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>timepoints</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="int">int</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>List of timepoint indices to load (0-based). If None,
loads all available timepoints</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>storage_options</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Additional options for zarr storage backend
(e.g., credentials for cloud storage)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>axes_order</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;ZYX&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Spatial axis order for NIfTI compatibility.
Either "ZYX" or "XYZ"</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>orientation</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Default anatomical orientation if not in metadata.
Standard orientations like "RAS", "LPI", etc. This is always
interpreted in XYZ axes order for consistency. This setting will override
any orientation defined in the OME zarr metadata</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>downsample_near_isotropic</code></b>
              (<code><span title="bool">bool</span></code>, default:
                  <code>False</code>
)
          
          <div class="doc-md-description">
            <p>If True, automatically downsample
dimensions with smaller voxel sizes to achieve near-isotropic
resolution</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>chunks</code></b>
              (<code><span title="tuple">tuple</span>[<span title="int">int</span>, <span title="Ellipsis">Ellipsis</span>] | <span title="Literal">Literal</span>[&#39;auto&#39;]</code>, default:
                  <code>&#39;auto&#39;</code>
)
          
          <div class="doc-md-description">
            <p>chunking strategy, or explicit chunk sizes to use if not automatic</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>rechunk</code></b>
              (<code><span title="bool">bool</span></code>, default:
                  <code>False</code>
)
          
          <div class="doc-md-description">
            <p>If True, rechunks the dataset after lazy loading, based
on the chunks parameter</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>ZarrNii instance with loaded data and metadata</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If both channels and channel_labels are specified,
or if invalid level/indices are provided</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="FileNotFoundError">FileNotFoundError</span></code>
            
          <div class="doc-md-description">
            <p>If store_or_path does not exist</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="KeyError">KeyError</span></code>
            
          <div class="doc-md-description">
            <p>If specified channel labels are not found</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="IOError">IOError</span></code>
            
          <div class="doc-md-description">
            <p>If unable to read from the storage backend</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load full resolution data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span> <span class="o">=</span> <span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_ome_zarr</span><span class="p">(</span><span class="s2">&quot;/path/to/data.zarr&quot;</span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load specific channels and pyramid level</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span> <span class="o">=</span> <span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_ome_zarr</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;/path/to/data.zarr&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;LPI&quot;</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load from cloud storage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span> <span class="o">=</span> <span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_ome_zarr</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;s3://bucket/data.zarr&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">storage_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;access_key&quot;</span><span class="p">,</span> <span class="s2">&quot;secret&quot;</span><span class="p">:</span> <span class="s2">&quot;secret&quot;</span><span class="p">}</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre></div>


<details class="notes" open>
  <summary>Notes</summary>
  <p><strong>Orientation Metadata Backwards Compatibility:</strong></p>
<p>This method implements backwards compatibility for orientation metadata:</p>
<ol>
<li>
<p><strong>Override</strong>: Setting the orientation here will override
   any orientation defined in the OME Zarr metadata.</p>
</li>
<li>
<p><strong>Zarr Metadata</strong>: Checks for 'xyz_orientation' first (new format),
   then falls back to 'orientation' (legacy format)</p>
</li>
<li>
<p><strong>Legacy Fallback</strong>: When only legacy 'orientation' is found, the
   orientation string is automatically reversed to convert from ZYX-based
   encoding (legacy) to XYZ-based encoding (current standard)</p>
</li>
<li>
<p><strong>Default Fallback</strong>: If no orientation metadata is found, uses RAS
   orientation as the default.</p>
</li>
</ol>
<p>Examples of the conversion:
- Legacy 'orientation'='SAR' (ZYX)  'xyz_orientation'='RAS' (XYZ)
- Legacy 'orientation'='IPL' (ZYX)  'xyz_orientation'='LPI' (XYZ)</p>
<p>This ensures consistent orientation handling while maintaining backwards
compatibility with existing OME-Zarr files that use the legacy format.</p>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1715</span>
<span class="normal">1716</span>
<span class="normal">1717</span>
<span class="normal">1718</span>
<span class="normal">1719</span>
<span class="normal">1720</span>
<span class="normal">1721</span>
<span class="normal">1722</span>
<span class="normal">1723</span>
<span class="normal">1724</span>
<span class="normal">1725</span>
<span class="normal">1726</span>
<span class="normal">1727</span>
<span class="normal">1728</span>
<span class="normal">1729</span>
<span class="normal">1730</span>
<span class="normal">1731</span>
<span class="normal">1732</span>
<span class="normal">1733</span>
<span class="normal">1734</span>
<span class="normal">1735</span>
<span class="normal">1736</span>
<span class="normal">1737</span>
<span class="normal">1738</span>
<span class="normal">1739</span>
<span class="normal">1740</span>
<span class="normal">1741</span>
<span class="normal">1742</span>
<span class="normal">1743</span>
<span class="normal">1744</span>
<span class="normal">1745</span>
<span class="normal">1746</span>
<span class="normal">1747</span>
<span class="normal">1748</span>
<span class="normal">1749</span>
<span class="normal">1750</span>
<span class="normal">1751</span>
<span class="normal">1752</span>
<span class="normal">1753</span>
<span class="normal">1754</span>
<span class="normal">1755</span>
<span class="normal">1756</span>
<span class="normal">1757</span>
<span class="normal">1758</span>
<span class="normal">1759</span>
<span class="normal">1760</span>
<span class="normal">1761</span>
<span class="normal">1762</span>
<span class="normal">1763</span>
<span class="normal">1764</span>
<span class="normal">1765</span>
<span class="normal">1766</span>
<span class="normal">1767</span>
<span class="normal">1768</span>
<span class="normal">1769</span>
<span class="normal">1770</span>
<span class="normal">1771</span>
<span class="normal">1772</span>
<span class="normal">1773</span>
<span class="normal">1774</span>
<span class="normal">1775</span>
<span class="normal">1776</span>
<span class="normal">1777</span>
<span class="normal">1778</span>
<span class="normal">1779</span>
<span class="normal">1780</span>
<span class="normal">1781</span>
<span class="normal">1782</span>
<span class="normal">1783</span>
<span class="normal">1784</span>
<span class="normal">1785</span>
<span class="normal">1786</span>
<span class="normal">1787</span>
<span class="normal">1788</span>
<span class="normal">1789</span>
<span class="normal">1790</span>
<span class="normal">1791</span>
<span class="normal">1792</span>
<span class="normal">1793</span>
<span class="normal">1794</span>
<span class="normal">1795</span>
<span class="normal">1796</span>
<span class="normal">1797</span>
<span class="normal">1798</span>
<span class="normal">1799</span>
<span class="normal">1800</span>
<span class="normal">1801</span>
<span class="normal">1802</span>
<span class="normal">1803</span>
<span class="normal">1804</span>
<span class="normal">1805</span>
<span class="normal">1806</span>
<span class="normal">1807</span>
<span class="normal">1808</span>
<span class="normal">1809</span>
<span class="normal">1810</span>
<span class="normal">1811</span>
<span class="normal">1812</span>
<span class="normal">1813</span>
<span class="normal">1814</span>
<span class="normal">1815</span>
<span class="normal">1816</span>
<span class="normal">1817</span>
<span class="normal">1818</span>
<span class="normal">1819</span>
<span class="normal">1820</span>
<span class="normal">1821</span>
<span class="normal">1822</span>
<span class="normal">1823</span>
<span class="normal">1824</span>
<span class="normal">1825</span>
<span class="normal">1826</span>
<span class="normal">1827</span>
<span class="normal">1828</span>
<span class="normal">1829</span>
<span class="normal">1830</span>
<span class="normal">1831</span>
<span class="normal">1832</span>
<span class="normal">1833</span>
<span class="normal">1834</span>
<span class="normal">1835</span>
<span class="normal">1836</span>
<span class="normal">1837</span>
<span class="normal">1838</span>
<span class="normal">1839</span>
<span class="normal">1840</span>
<span class="normal">1841</span>
<span class="normal">1842</span>
<span class="normal">1843</span>
<span class="normal">1844</span>
<span class="normal">1845</span>
<span class="normal">1846</span>
<span class="normal">1847</span>
<span class="normal">1848</span>
<span class="normal">1849</span>
<span class="normal">1850</span>
<span class="normal">1851</span>
<span class="normal">1852</span>
<span class="normal">1853</span>
<span class="normal">1854</span>
<span class="normal">1855</span>
<span class="normal">1856</span>
<span class="normal">1857</span>
<span class="normal">1858</span>
<span class="normal">1859</span>
<span class="normal">1860</span>
<span class="normal">1861</span>
<span class="normal">1862</span>
<span class="normal">1863</span>
<span class="normal">1864</span>
<span class="normal">1865</span>
<span class="normal">1866</span>
<span class="normal">1867</span>
<span class="normal">1868</span>
<span class="normal">1869</span>
<span class="normal">1870</span>
<span class="normal">1871</span>
<span class="normal">1872</span>
<span class="normal">1873</span>
<span class="normal">1874</span>
<span class="normal">1875</span>
<span class="normal">1876</span>
<span class="normal">1877</span>
<span class="normal">1878</span>
<span class="normal">1879</span>
<span class="normal">1880</span>
<span class="normal">1881</span>
<span class="normal">1882</span>
<span class="normal">1883</span>
<span class="normal">1884</span>
<span class="normal">1885</span>
<span class="normal">1886</span>
<span class="normal">1887</span>
<span class="normal">1888</span>
<span class="normal">1889</span>
<span class="normal">1890</span>
<span class="normal">1891</span>
<span class="normal">1892</span>
<span class="normal">1893</span>
<span class="normal">1894</span>
<span class="normal">1895</span>
<span class="normal">1896</span>
<span class="normal">1897</span>
<span class="normal">1898</span>
<span class="normal">1899</span>
<span class="normal">1900</span>
<span class="normal">1901</span>
<span class="normal">1902</span>
<span class="normal">1903</span>
<span class="normal">1904</span>
<span class="normal">1905</span>
<span class="normal">1906</span>
<span class="normal">1907</span>
<span class="normal">1908</span>
<span class="normal">1909</span>
<span class="normal">1910</span>
<span class="normal">1911</span>
<span class="normal">1912</span>
<span class="normal">1913</span>
<span class="normal">1914</span>
<span class="normal">1915</span>
<span class="normal">1916</span>
<span class="normal">1917</span>
<span class="normal">1918</span>
<span class="normal">1919</span>
<span class="normal">1920</span>
<span class="normal">1921</span>
<span class="normal">1922</span>
<span class="normal">1923</span>
<span class="normal">1924</span>
<span class="normal">1925</span>
<span class="normal">1926</span>
<span class="normal">1927</span>
<span class="normal">1928</span>
<span class="normal">1929</span>
<span class="normal">1930</span>
<span class="normal">1931</span>
<span class="normal">1932</span>
<span class="normal">1933</span>
<span class="normal">1934</span>
<span class="normal">1935</span>
<span class="normal">1936</span>
<span class="normal">1937</span>
<span class="normal">1938</span>
<span class="normal">1939</span>
<span class="normal">1940</span>
<span class="normal">1941</span>
<span class="normal">1942</span>
<span class="normal">1943</span>
<span class="normal">1944</span>
<span class="normal">1945</span>
<span class="normal">1946</span>
<span class="normal">1947</span>
<span class="normal">1948</span>
<span class="normal">1949</span>
<span class="normal">1950</span>
<span class="normal">1951</span>
<span class="normal">1952</span>
<span class="normal">1953</span>
<span class="normal">1954</span>
<span class="normal">1955</span>
<span class="normal">1956</span>
<span class="normal">1957</span>
<span class="normal">1958</span>
<span class="normal">1959</span>
<span class="normal">1960</span>
<span class="normal">1961</span>
<span class="normal">1962</span>
<span class="normal">1963</span>
<span class="normal">1964</span>
<span class="normal">1965</span>
<span class="normal">1966</span>
<span class="normal">1967</span>
<span class="normal">1968</span>
<span class="normal">1969</span>
<span class="normal">1970</span>
<span class="normal">1971</span>
<span class="normal">1972</span>
<span class="normal">1973</span>
<span class="normal">1974</span>
<span class="normal">1975</span>
<span class="normal">1976</span>
<span class="normal">1977</span>
<span class="normal">1978</span>
<span class="normal">1979</span>
<span class="normal">1980</span>
<span class="normal">1981</span>
<span class="normal">1982</span>
<span class="normal">1983</span>
<span class="normal">1984</span>
<span class="normal">1985</span>
<span class="normal">1986</span>
<span class="normal">1987</span>
<span class="normal">1988</span>
<span class="normal">1989</span>
<span class="normal">1990</span>
<span class="normal">1991</span>
<span class="normal">1992</span>
<span class="normal">1993</span>
<span class="normal">1994</span>
<span class="normal">1995</span>
<span class="normal">1996</span>
<span class="normal">1997</span>
<span class="normal">1998</span>
<span class="normal">1999</span>
<span class="normal">2000</span>
<span class="normal">2001</span>
<span class="normal">2002</span>
<span class="normal">2003</span>
<span class="normal">2004</span>
<span class="normal">2005</span>
<span class="normal">2006</span>
<span class="normal">2007</span>
<span class="normal">2008</span>
<span class="normal">2009</span>
<span class="normal">2010</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_ome_zarr</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span>
    <span class="n">store_or_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">level</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">channels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">channel_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">timepoints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">storage_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axes_order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ZYX&quot;</span><span class="p">,</span>
    <span class="n">orientation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">downsample_near_isotropic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">chunks</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="bp">Ellipsis</span><span class="p">]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="n">rechunk</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load ZarrNii from OME-Zarr store with flexible options.</span>

<span class="sd">    Creates a ZarrNii instance from an OME-Zarr store, supporting multiscale</span>
<span class="sd">    pyramids, channel/timepoint selection, and various storage backends.</span>
<span class="sd">    Automatically handles metadata extraction and format conversion.</span>

<span class="sd">    Args:</span>
<span class="sd">        store_or_path: Store or path to OME-Zarr file. Supports:</span>
<span class="sd">            - Local file paths</span>
<span class="sd">            - Remote URLs (s3://, http://, etc.)</span>
<span class="sd">            - ZIP files (.zip extension)</span>
<span class="sd">            - Zarr store objects</span>
<span class="sd">        level: Pyramid level to load (0 = highest resolution). If level</span>
<span class="sd">            exceeds available levels, applies lazy downsampling</span>
<span class="sd">        channels: List of channel indices to load (0-based). Mutually</span>
<span class="sd">            exclusive with channel_labels</span>
<span class="sd">        channel_labels: List of channel names to load by label. Requires</span>
<span class="sd">            OMERO metadata. Mutually exclusive with channels</span>
<span class="sd">        timepoints: List of timepoint indices to load (0-based). If None,</span>
<span class="sd">            loads all available timepoints</span>
<span class="sd">        storage_options: Additional options for zarr storage backend</span>
<span class="sd">            (e.g., credentials for cloud storage)</span>
<span class="sd">        axes_order: Spatial axis order for NIfTI compatibility.</span>
<span class="sd">            Either &quot;ZYX&quot; or &quot;XYZ&quot;</span>
<span class="sd">        orientation: Default anatomical orientation if not in metadata.</span>
<span class="sd">            Standard orientations like &quot;RAS&quot;, &quot;LPI&quot;, etc. This is always</span>
<span class="sd">            interpreted in XYZ axes order for consistency. This setting will override</span>
<span class="sd">            any orientation defined in the OME zarr metadata</span>
<span class="sd">        downsample_near_isotropic: If True, automatically downsample</span>
<span class="sd">            dimensions with smaller voxel sizes to achieve near-isotropic</span>
<span class="sd">            resolution</span>
<span class="sd">        chunks: chunking strategy, or explicit chunk sizes to use if not automatic</span>
<span class="sd">        rechunk: If True, rechunks the dataset after lazy loading, based</span>
<span class="sd">            on the chunks parameter</span>

<span class="sd">    Returns:</span>
<span class="sd">        ZarrNii instance with loaded data and metadata</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If both channels and channel_labels are specified,</span>
<span class="sd">            or if invalid level/indices are provided</span>
<span class="sd">        FileNotFoundError: If store_or_path does not exist</span>
<span class="sd">        KeyError: If specified channel labels are not found</span>
<span class="sd">        IOError: If unable to read from the storage backend</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Load full resolution data</span>
<span class="sd">        &gt;&gt;&gt; znii = ZarrNii.from_ome_zarr(&quot;/path/to/data.zarr&quot;)</span>

<span class="sd">        &gt;&gt;&gt; # Load specific channels and pyramid level</span>
<span class="sd">        &gt;&gt;&gt; znii = ZarrNii.from_ome_zarr(</span>
<span class="sd">        ...     &quot;/path/to/data.zarr&quot;,</span>
<span class="sd">        ...     level=1,</span>
<span class="sd">        ...     channels=[0, 2],</span>
<span class="sd">        ...     orientation=&quot;LPI&quot;</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; # Load from cloud storage</span>
<span class="sd">        &gt;&gt;&gt; znii = ZarrNii.from_ome_zarr(</span>
<span class="sd">        ...     &quot;s3://bucket/data.zarr&quot;,</span>
<span class="sd">        ...     storage_options={&quot;key&quot;: &quot;access_key&quot;, &quot;secret&quot;: &quot;secret&quot;}</span>
<span class="sd">        ... )</span>

<span class="sd">    Notes:</span>
<span class="sd">        **Orientation Metadata Backwards Compatibility:**</span>

<span class="sd">        This method implements backwards compatibility for orientation metadata:</span>

<span class="sd">        1. **Override**: Setting the orientation here will override</span>
<span class="sd">           any orientation defined in the OME Zarr metadata.</span>

<span class="sd">        2. **Zarr Metadata**: Checks for &#39;xyz_orientation&#39; first (new format),</span>
<span class="sd">           then falls back to &#39;orientation&#39; (legacy format)</span>

<span class="sd">        3. **Legacy Fallback**: When only legacy &#39;orientation&#39; is found, the</span>
<span class="sd">           orientation string is automatically reversed to convert from ZYX-based</span>
<span class="sd">           encoding (legacy) to XYZ-based encoding (current standard)</span>

<span class="sd">        4. **Default Fallback**: If no orientation metadata is found, uses RAS</span>
<span class="sd">           orientation as the default.</span>

<span class="sd">        Examples of the conversion:</span>
<span class="sd">        - Legacy &#39;orientation&#39;=&#39;SAR&#39; (ZYX)  &#39;xyz_orientation&#39;=&#39;RAS&#39; (XYZ)</span>
<span class="sd">        - Legacy &#39;orientation&#39;=&#39;IPL&#39; (ZYX)  &#39;xyz_orientation&#39;=&#39;LPI&#39; (XYZ)</span>

<span class="sd">        This ensures consistent orientation handling while maintaining backwards</span>
<span class="sd">        compatibility with existing OME-Zarr files that use the legacy format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate channel and timepoint selection arguments</span>
    <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">channel_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both &#39;channels&#39; and &#39;channel_labels&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># Load the multiscales object</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Handle ZIP files by creating a ZipStore</span>
            <span class="k">if</span> <span class="n">store_or_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.zip&quot;</span><span class="p">):</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">zarr</span>

                <span class="n">store</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">ZipStore</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">multiscales</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">from_ngff_zarr</span><span class="p">(</span>
                    <span class="n">store</span><span class="p">,</span> <span class="n">storage_options</span><span class="o">=</span><span class="n">storage_options</span> <span class="ow">or</span> <span class="p">{}</span>
                <span class="p">)</span>
                <span class="c1"># Note: We&#39;ll close the store after extracting metadata</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">multiscales</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">from_ngff_zarr</span><span class="p">(</span>
                    <span class="n">store_or_path</span><span class="p">,</span> <span class="n">storage_options</span><span class="o">=</span><span class="n">storage_options</span> <span class="ow">or</span> <span class="p">{}</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">multiscales</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">from_ngff_zarr</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># Fallback for older zarr/ngff_zarr versions</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">store_or_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.zip&quot;</span><span class="p">):</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">zarr</span>

                <span class="n">store</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">ZipStore</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">multiscales</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">from_ngff_zarr</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">store</span> <span class="o">=</span> <span class="n">fsspec</span><span class="o">.</span><span class="n">get_mapper</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="o">**</span><span class="n">storage_options</span> <span class="ow">or</span> <span class="p">{})</span>
                <span class="n">multiscales</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">from_ngff_zarr</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">store</span> <span class="o">=</span> <span class="n">store_or_path</span>
            <span class="n">multiscales</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">from_ngff_zarr</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>

    <span class="c1"># Extract omero metadata if available</span>
    <span class="n">omero_metadata</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">zarr</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">store_or_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.zip&quot;</span><span class="p">):</span>
                <span class="n">zip_store</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">ZipStore</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="n">zip_store</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="c1"># Close zip store after getting group</span>
                <span class="n">zip_store</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">group</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;omero&quot;</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">omero_dict</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;omero&quot;</span><span class="p">]</span>

            <span class="c1"># Create a simple object to hold omero metadata</span>
            <span class="k">class</span><span class="w"> </span><span class="nc">OmeroMetadata</span><span class="p">:</span>
                <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omero_dict</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="s2">&quot;channels&quot;</span> <span class="ow">in</span> <span class="n">omero_dict</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">ch_dict</span> <span class="ow">in</span> <span class="n">omero_dict</span><span class="p">[</span><span class="s2">&quot;channels&quot;</span><span class="p">]:</span>
                            <span class="c1"># Create channel objects</span>
                            <span class="k">class</span><span class="w"> </span><span class="nc">ChannelMetadata</span><span class="p">:</span>
                                <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_dict</span><span class="p">):</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">ch_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">ch_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="s2">&quot;window&quot;</span> <span class="ow">in</span> <span class="n">ch_dict</span><span class="p">:</span>

                                        <span class="k">class</span><span class="w"> </span><span class="nc">WindowMetadata</span><span class="p">:</span>
                                            <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">win_dict</span><span class="p">):</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">win_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">win_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                                                    <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="mf">65535.0</span>
                                                <span class="p">)</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">win_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                                                    <span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="mf">0.0</span>
                                                <span class="p">)</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">win_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                                                    <span class="s2">&quot;end&quot;</span><span class="p">,</span> <span class="mf">65535.0</span>
                                                <span class="p">)</span>

                                        <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">WindowMetadata</span><span class="p">(</span>
                                            <span class="n">ch_dict</span><span class="p">[</span><span class="s2">&quot;window&quot;</span><span class="p">]</span>
                                        <span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="kc">None</span>

                            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ChannelMetadata</span><span class="p">(</span><span class="n">ch_dict</span><span class="p">))</span>

            <span class="n">omero_metadata</span> <span class="o">=</span> <span class="n">OmeroMetadata</span><span class="p">(</span><span class="n">omero_dict</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="c1"># If we can&#39;t load omero metadata, that&#39;s okay</span>
        <span class="k">pass</span>

    <span class="c1"># Read orientation metadata with backwards compatibility support</span>
    <span class="c1"># Priority: xyz_orientation (new) &gt; orientation (legacy, with reversal)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">zarr</span>

        <span class="k">if</span> <span class="n">orientation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">store_or_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.zip&quot;</span><span class="p">):</span>
                    <span class="n">zip_store</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">ZipStore</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
                    <span class="n">group</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="n">zip_store</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
                    <span class="c1"># Check for new xyz_orientation first, then fallback to legacy orientation</span>
                    <span class="k">if</span> <span class="s2">&quot;xyz_orientation&quot;</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                        <span class="n">orientation</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;xyz_orientation&quot;</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="s2">&quot;orientation&quot;</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                        <span class="c1"># Legacy orientation is ZYX-based, reverse it to get XYZ-based orientation</span>
                        <span class="n">legacy_orientation</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">]</span>
                        <span class="n">orientation</span> <span class="o">=</span> <span class="n">reverse_orientation_string</span><span class="p">(</span><span class="n">legacy_orientation</span><span class="p">)</span>
                    <span class="c1"># If neither found, use the provided default orientation</span>
                    <span class="n">zip_store</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">group</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
                    <span class="c1"># Check for new xyz_orientation first, then fallback to legacy orientation</span>
                    <span class="k">if</span> <span class="s2">&quot;xyz_orientation&quot;</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                        <span class="n">orientation</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;xyz_orientation&quot;</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="s2">&quot;orientation&quot;</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                        <span class="c1"># Legacy orientation is ZYX-based, reverse it to get XYZ-based orientation</span>
                        <span class="n">legacy_orientation</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">]</span>
                        <span class="n">orientation</span> <span class="o">=</span> <span class="n">reverse_orientation_string</span><span class="p">(</span><span class="n">legacy_orientation</span><span class="p">)</span>
                    <span class="c1"># If neither found, use the provided default orientation</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="c1"># Check for new xyz_orientation first, then fallback to legacy orientation</span>
                <span class="k">if</span> <span class="s2">&quot;xyz_orientation&quot;</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                    <span class="n">orientation</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;xyz_orientation&quot;</span><span class="p">]</span>
                <span class="k">elif</span> <span class="s2">&quot;orientation&quot;</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                    <span class="c1"># Legacy orientation is ZYX-based, reverse it to get XYZ-based orientation</span>
                    <span class="n">legacy_orientation</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">]</span>
                    <span class="n">orientation</span> <span class="o">=</span> <span class="n">reverse_orientation_string</span><span class="p">(</span><span class="n">legacy_orientation</span><span class="p">)</span>
                <span class="c1"># If neither found, use the provided default orientation</span>

    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="c1"># If we can&#39;t read orientation metadata, use the provided default</span>
        <span class="k">pass</span>

    <span class="c1"># If orientation is still None, use the fallback default</span>
    <span class="k">if</span> <span class="n">orientation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="s2">&quot;RAS&quot;</span>
    <span class="c1"># Determine the available pyramid levels and handle lazy downsampling</span>
    <span class="n">max_level</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">multiscales</span><span class="o">.</span><span class="n">images</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">actual_level</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">max_level</span><span class="p">)</span>
    <span class="n">do_downsample</span> <span class="o">=</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="n">max_level</span>

    <span class="c1"># Get the highest available level</span>
    <span class="n">ngff_image</span> <span class="o">=</span> <span class="n">multiscales</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="n">actual_level</span><span class="p">]</span>

    <span class="c1"># Handle channel and timepoint selection and filter omero metadata accordingly</span>
    <span class="n">filtered_omero</span> <span class="o">=</span> <span class="n">omero_metadata</span>
    <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">channel_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">timepoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ngff_image</span><span class="p">,</span> <span class="n">filtered_omero</span> <span class="o">=</span> <span class="n">_select_dimensions_from_image_with_omero</span><span class="p">(</span>
            <span class="n">ngff_image</span><span class="p">,</span>
            <span class="n">multiscales</span><span class="p">,</span>
            <span class="n">channels</span><span class="p">,</span>
            <span class="n">channel_labels</span><span class="p">,</span>
            <span class="n">timepoints</span><span class="p">,</span>
            <span class="n">omero_metadata</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Create ZarrNii instance with xyz_orientation</span>
    <span class="n">znimg</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span>
        <span class="n">_omero</span><span class="o">=</span><span class="n">filtered_omero</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Apply lazy downsampling if needed</span>
    <span class="k">if</span> <span class="n">do_downsample</span><span class="p">:</span>
        <span class="n">level_ds</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="n">max_level</span>
        <span class="n">downsample_factor</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">level_ds</span>

        <span class="c1"># Get spatial dims based on axes order</span>
        <span class="n">spatial_dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>

        <span class="c1"># Apply downsampling using the existing method</span>
        <span class="n">znimg</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span>
            <span class="n">factors</span><span class="o">=</span><span class="n">downsample_factor</span><span class="p">,</span> <span class="n">spatial_dims</span><span class="o">=</span><span class="n">spatial_dims</span>
        <span class="p">)</span>

    <span class="c1"># Apply near-isotropic downsampling if requested</span>
    <span class="k">if</span> <span class="n">downsample_near_isotropic</span><span class="p">:</span>
        <span class="n">znimg</span> <span class="o">=</span> <span class="n">_apply_near_isotropic_downsampling</span><span class="p">(</span><span class="n">znimg</span><span class="p">,</span> <span class="n">axes_order</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rechunk</span><span class="p">:</span>
        <span class="n">znimg</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rechunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">znimg</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.from_nifti" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_nifti</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">axes_order</span><span class="o">=</span><span class="s1">&#39;XYZ&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_ref</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zooms</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Load ZarrNii from NIfTI file with flexible loading options.</p>
<p>Creates a ZarrNii instance from a NIfTI file, automatically converting
the data to dask arrays and extracting spatial transformation information.
Supports both full data loading and reference-only loading for memory
efficiency. For 4D NIfTI files, the 4th dimension is treated as channels
(XYZC ordering, analogous to CZYX in OME-Zarr).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>path</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="bytes">bytes</span>]</code>)
          
          <div class="doc-md-description">
            <p>File path to NIfTI file (.nii, .nii.gz, .img/.hdr)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>chunks</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="typing.Tuple">Tuple</span>[<span title="int">int</span>, ...]]</code>, default:
                  <code>&#39;auto&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Dask array chunking strategy. Can be:
- "auto": Automatic chunking based on file size
- Tuple of ints: Manual chunk sizes for each dimension
- Dict mapping axis to chunk size</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>axes_order</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;XYZ&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Spatial axis ordering convention. Either:
- "XYZ": X=left-right, Y=anterior-posterior, Z=inferior-superior
- "ZYX": Z=inferior-superior, Y=anterior-posterior, X=left-right</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>name</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional name for the resulting NgffImage. If None,
uses filename without extension</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>as_ref</code></b>
              (<code><span title="bool">bool</span></code>, default:
                  <code>False</code>
)
          
          <div class="doc-md-description">
            <p>If True, creates empty dask array with correct shape/metadata
without loading actual image data (memory efficient for templates)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>zooms</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Target voxel spacing as (x, y, z) in mm. Only valid when
as_ref=True. Adjusts shape and affine accordingly</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>ZarrNii instance containing NIfTI data and spatial metadata. If the</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>NIfTI file contains channel labels in header extensions, they will be</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>preserved in OMERO metadata.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If zooms specified with as_ref=False, or invalid axes_order</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="FileNotFoundError">FileNotFoundError</span></code>
            
          <div class="doc-md-description">
            <p>If NIfTI file does not exist</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="OSError">OSError</span></code>
            
          <div class="doc-md-description">
            <p>If unable to read NIfTI file</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="nibabel.filebasedimages.ImageFileError">ImageFileError</span></code>
            
          <div class="doc-md-description">
            <p>If file is not valid NIfTI</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load full NIfTI data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span> <span class="o">=</span> <span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_nifti</span><span class="p">(</span><span class="s2">&quot;/path/to/brain.nii.gz&quot;</span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load with custom chunking and axis order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span> <span class="o">=</span> <span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_nifti</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;/path/to/data.nii&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">axes_order</span><span class="o">=</span><span class="s2">&quot;ZYX&quot;</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load 4D NIfTI with multiple channels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span> <span class="o">=</span> <span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_nifti</span><span class="p">(</span><span class="s2">&quot;/path/to/multichannel.nii.gz&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">znii</span><span class="o">.</span><span class="n">list_channels</span><span class="p">())</span>  <span class="c1"># Shows channel labels if stored</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create reference with target resolution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii_ref</span> <span class="o">=</span> <span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_nifti</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;/path/to/template.nii.gz&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">as_ref</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">zooms</span><span class="o">=</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre></div>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The method automatically handles NIfTI orientation codes and converts
  them to the specified axes_order for consistency with OME-Zarr workflows</li>
<li>For 4D NIfTI files, the 4th dimension is interpreted as channels (XYZC)</li>
<li>Channel labels stored in NIfTI header extensions are automatically loaded</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2012</span>
<span class="normal">2013</span>
<span class="normal">2014</span>
<span class="normal">2015</span>
<span class="normal">2016</span>
<span class="normal">2017</span>
<span class="normal">2018</span>
<span class="normal">2019</span>
<span class="normal">2020</span>
<span class="normal">2021</span>
<span class="normal">2022</span>
<span class="normal">2023</span>
<span class="normal">2024</span>
<span class="normal">2025</span>
<span class="normal">2026</span>
<span class="normal">2027</span>
<span class="normal">2028</span>
<span class="normal">2029</span>
<span class="normal">2030</span>
<span class="normal">2031</span>
<span class="normal">2032</span>
<span class="normal">2033</span>
<span class="normal">2034</span>
<span class="normal">2035</span>
<span class="normal">2036</span>
<span class="normal">2037</span>
<span class="normal">2038</span>
<span class="normal">2039</span>
<span class="normal">2040</span>
<span class="normal">2041</span>
<span class="normal">2042</span>
<span class="normal">2043</span>
<span class="normal">2044</span>
<span class="normal">2045</span>
<span class="normal">2046</span>
<span class="normal">2047</span>
<span class="normal">2048</span>
<span class="normal">2049</span>
<span class="normal">2050</span>
<span class="normal">2051</span>
<span class="normal">2052</span>
<span class="normal">2053</span>
<span class="normal">2054</span>
<span class="normal">2055</span>
<span class="normal">2056</span>
<span class="normal">2057</span>
<span class="normal">2058</span>
<span class="normal">2059</span>
<span class="normal">2060</span>
<span class="normal">2061</span>
<span class="normal">2062</span>
<span class="normal">2063</span>
<span class="normal">2064</span>
<span class="normal">2065</span>
<span class="normal">2066</span>
<span class="normal">2067</span>
<span class="normal">2068</span>
<span class="normal">2069</span>
<span class="normal">2070</span>
<span class="normal">2071</span>
<span class="normal">2072</span>
<span class="normal">2073</span>
<span class="normal">2074</span>
<span class="normal">2075</span>
<span class="normal">2076</span>
<span class="normal">2077</span>
<span class="normal">2078</span>
<span class="normal">2079</span>
<span class="normal">2080</span>
<span class="normal">2081</span>
<span class="normal">2082</span>
<span class="normal">2083</span>
<span class="normal">2084</span>
<span class="normal">2085</span>
<span class="normal">2086</span>
<span class="normal">2087</span>
<span class="normal">2088</span>
<span class="normal">2089</span>
<span class="normal">2090</span>
<span class="normal">2091</span>
<span class="normal">2092</span>
<span class="normal">2093</span>
<span class="normal">2094</span>
<span class="normal">2095</span>
<span class="normal">2096</span>
<span class="normal">2097</span>
<span class="normal">2098</span>
<span class="normal">2099</span>
<span class="normal">2100</span>
<span class="normal">2101</span>
<span class="normal">2102</span>
<span class="normal">2103</span>
<span class="normal">2104</span>
<span class="normal">2105</span>
<span class="normal">2106</span>
<span class="normal">2107</span>
<span class="normal">2108</span>
<span class="normal">2109</span>
<span class="normal">2110</span>
<span class="normal">2111</span>
<span class="normal">2112</span>
<span class="normal">2113</span>
<span class="normal">2114</span>
<span class="normal">2115</span>
<span class="normal">2116</span>
<span class="normal">2117</span>
<span class="normal">2118</span>
<span class="normal">2119</span>
<span class="normal">2120</span>
<span class="normal">2121</span>
<span class="normal">2122</span>
<span class="normal">2123</span>
<span class="normal">2124</span>
<span class="normal">2125</span>
<span class="normal">2126</span>
<span class="normal">2127</span>
<span class="normal">2128</span>
<span class="normal">2129</span>
<span class="normal">2130</span>
<span class="normal">2131</span>
<span class="normal">2132</span>
<span class="normal">2133</span>
<span class="normal">2134</span>
<span class="normal">2135</span>
<span class="normal">2136</span>
<span class="normal">2137</span>
<span class="normal">2138</span>
<span class="normal">2139</span>
<span class="normal">2140</span>
<span class="normal">2141</span>
<span class="normal">2142</span>
<span class="normal">2143</span>
<span class="normal">2144</span>
<span class="normal">2145</span>
<span class="normal">2146</span>
<span class="normal">2147</span>
<span class="normal">2148</span>
<span class="normal">2149</span>
<span class="normal">2150</span>
<span class="normal">2151</span>
<span class="normal">2152</span>
<span class="normal">2153</span>
<span class="normal">2154</span>
<span class="normal">2155</span>
<span class="normal">2156</span>
<span class="normal">2157</span>
<span class="normal">2158</span>
<span class="normal">2159</span>
<span class="normal">2160</span>
<span class="normal">2161</span>
<span class="normal">2162</span>
<span class="normal">2163</span>
<span class="normal">2164</span>
<span class="normal">2165</span>
<span class="normal">2166</span>
<span class="normal">2167</span>
<span class="normal">2168</span>
<span class="normal">2169</span>
<span class="normal">2170</span>
<span class="normal">2171</span>
<span class="normal">2172</span>
<span class="normal">2173</span>
<span class="normal">2174</span>
<span class="normal">2175</span>
<span class="normal">2176</span>
<span class="normal">2177</span>
<span class="normal">2178</span>
<span class="normal">2179</span>
<span class="normal">2180</span>
<span class="normal">2181</span>
<span class="normal">2182</span>
<span class="normal">2183</span>
<span class="normal">2184</span>
<span class="normal">2185</span>
<span class="normal">2186</span>
<span class="normal">2187</span>
<span class="normal">2188</span>
<span class="normal">2189</span>
<span class="normal">2190</span>
<span class="normal">2191</span>
<span class="normal">2192</span>
<span class="normal">2193</span>
<span class="normal">2194</span>
<span class="normal">2195</span>
<span class="normal">2196</span>
<span class="normal">2197</span>
<span class="normal">2198</span>
<span class="normal">2199</span>
<span class="normal">2200</span>
<span class="normal">2201</span>
<span class="normal">2202</span>
<span class="normal">2203</span>
<span class="normal">2204</span>
<span class="normal">2205</span>
<span class="normal">2206</span>
<span class="normal">2207</span>
<span class="normal">2208</span>
<span class="normal">2209</span>
<span class="normal">2210</span>
<span class="normal">2211</span>
<span class="normal">2212</span>
<span class="normal">2213</span>
<span class="normal">2214</span>
<span class="normal">2215</span>
<span class="normal">2216</span>
<span class="normal">2217</span>
<span class="normal">2218</span>
<span class="normal">2219</span>
<span class="normal">2220</span>
<span class="normal">2221</span>
<span class="normal">2222</span>
<span class="normal">2223</span>
<span class="normal">2224</span>
<span class="normal">2225</span>
<span class="normal">2226</span>
<span class="normal">2227</span>
<span class="normal">2228</span>
<span class="normal">2229</span>
<span class="normal">2230</span>
<span class="normal">2231</span>
<span class="normal">2232</span>
<span class="normal">2233</span>
<span class="normal">2234</span>
<span class="normal">2235</span>
<span class="normal">2236</span>
<span class="normal">2237</span>
<span class="normal">2238</span>
<span class="normal">2239</span>
<span class="normal">2240</span>
<span class="normal">2241</span>
<span class="normal">2242</span>
<span class="normal">2243</span>
<span class="normal">2244</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_nifti</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span>
    <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">],</span>
    <span class="n">chunks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="n">axes_order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;XYZ&quot;</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">as_ref</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">zooms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load ZarrNii from NIfTI file with flexible loading options.</span>

<span class="sd">    Creates a ZarrNii instance from a NIfTI file, automatically converting</span>
<span class="sd">    the data to dask arrays and extracting spatial transformation information.</span>
<span class="sd">    Supports both full data loading and reference-only loading for memory</span>
<span class="sd">    efficiency. For 4D NIfTI files, the 4th dimension is treated as channels</span>
<span class="sd">    (XYZC ordering, analogous to CZYX in OME-Zarr).</span>

<span class="sd">    Args:</span>
<span class="sd">        path: File path to NIfTI file (.nii, .nii.gz, .img/.hdr)</span>
<span class="sd">        chunks: Dask array chunking strategy. Can be:</span>
<span class="sd">            - &quot;auto&quot;: Automatic chunking based on file size</span>
<span class="sd">            - Tuple of ints: Manual chunk sizes for each dimension</span>
<span class="sd">            - Dict mapping axis to chunk size</span>
<span class="sd">        axes_order: Spatial axis ordering convention. Either:</span>
<span class="sd">            - &quot;XYZ&quot;: X=left-right, Y=anterior-posterior, Z=inferior-superior</span>
<span class="sd">            - &quot;ZYX&quot;: Z=inferior-superior, Y=anterior-posterior, X=left-right</span>
<span class="sd">        name: Optional name for the resulting NgffImage. If None,</span>
<span class="sd">            uses filename without extension</span>
<span class="sd">        as_ref: If True, creates empty dask array with correct shape/metadata</span>
<span class="sd">            without loading actual image data (memory efficient for templates)</span>
<span class="sd">        zooms: Target voxel spacing as (x, y, z) in mm. Only valid when</span>
<span class="sd">            as_ref=True. Adjusts shape and affine accordingly</span>

<span class="sd">    Returns:</span>
<span class="sd">        ZarrNii instance containing NIfTI data and spatial metadata. If the</span>
<span class="sd">        NIfTI file contains channel labels in header extensions, they will be</span>
<span class="sd">        preserved in OMERO metadata.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If zooms specified with as_ref=False, or invalid axes_order</span>
<span class="sd">        FileNotFoundError: If NIfTI file does not exist</span>
<span class="sd">        OSError: If unable to read NIfTI file</span>
<span class="sd">        nibabel.filebasedimages.ImageFileError: If file is not valid NIfTI</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Load full NIfTI data</span>
<span class="sd">        &gt;&gt;&gt; znii = ZarrNii.from_nifti(&quot;/path/to/brain.nii.gz&quot;)</span>

<span class="sd">        &gt;&gt;&gt; # Load with custom chunking and axis order</span>
<span class="sd">        &gt;&gt;&gt; znii = ZarrNii.from_nifti(</span>
<span class="sd">        ...     &quot;/path/to/data.nii&quot;,</span>
<span class="sd">        ...     chunks=(64, 64, 64),</span>
<span class="sd">        ...     axes_order=&quot;ZYX&quot;</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; # Load 4D NIfTI with multiple channels</span>
<span class="sd">        &gt;&gt;&gt; znii = ZarrNii.from_nifti(&quot;/path/to/multichannel.nii.gz&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(znii.list_channels())  # Shows channel labels if stored</span>

<span class="sd">        &gt;&gt;&gt; # Create reference with target resolution</span>
<span class="sd">        &gt;&gt;&gt; znii_ref = ZarrNii.from_nifti(</span>
<span class="sd">        ...     &quot;/path/to/template.nii.gz&quot;,</span>
<span class="sd">        ...     as_ref=True,</span>
<span class="sd">        ...     zooms=(2.0, 2.0, 2.0)</span>
<span class="sd">        ... )</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The method automatically handles NIfTI orientation codes and converts</span>
<span class="sd">          them to the specified axes_order for consistency with OME-Zarr workflows</span>
<span class="sd">        - For 4D NIfTI files, the 4th dimension is interpreted as channels (XYZC)</span>
<span class="sd">        - Channel labels stored in NIfTI header extensions are automatically loaded</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">as_ref</span> <span class="ow">and</span> <span class="n">zooms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`zooms` can only be used when `as_ref=True`.&quot;</span><span class="p">)</span>

    <span class="c1"># Load NIfTI file</span>
    <span class="n">nifti_img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">nifti_img</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">get_data_shape</span><span class="p">()</span>
    <span class="n">affine_matrix</span> <span class="o">=</span> <span class="n">nifti_img</span><span class="o">.</span><span class="n">affine</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># infer orientation from the affine</span>
    <span class="n">orientation</span> <span class="o">=</span> <span class="n">_affine_to_orientation</span><span class="p">(</span><span class="n">affine_matrix</span><span class="p">)</span>

    <span class="n">in_zooms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nifti_img</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">get_zooms</span><span class="p">())</span>

    <span class="c1"># Adjust shape and affine if zooms are provided</span>
    <span class="k">if</span> <span class="n">zooms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scaling_factor</span> <span class="o">=</span> <span class="n">in_zooms</span> <span class="o">/</span> <span class="n">zooms</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scaling_factor</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span>  <span class="c1"># Z</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scaling_factor</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>  <span class="c1"># Y</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">scaling_factor</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>  <span class="c1"># X</span>
        <span class="p">]</span>
        <span class="c1"># create affine by specifying orientation, scale and translation</span>
        <span class="n">affine_matrix</span> <span class="o">=</span> <span class="n">_axcodes2aff</span><span class="p">(</span><span class="n">orientation</span><span class="p">,</span> <span class="n">zooms</span><span class="p">,</span> <span class="n">affine_matrix</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">in_zooms</span> <span class="o">=</span> <span class="n">zooms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">shape</span>

    <span class="k">if</span> <span class="n">as_ref</span><span class="p">:</span>
        <span class="c1"># Create an empty dask array with the adjusted shape</span>
        <span class="c1"># Already add channel dimension here</span>
        <span class="n">darr</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">new_shape</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="c1"># Mark that we already added channel dimension</span>
        <span class="n">has_channel_dim</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Load the NIfTI data and convert to a dask array</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">nifti_img</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>
        <span class="n">darr</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">)</span>
        <span class="n">has_channel_dim</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># NIfTI uses XYZ ordering, but we need to handle channels</span>
    <span class="c1"># For 4D NIfTI: XYZC (4th dim is channels, analogous to CZYX in OME-Zarr)</span>
    <span class="n">original_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">darr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">has_channel_dim</span><span class="p">:</span>
        <span class="c1"># Already has channel dimension from as_ref, don&#39;t modify</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">original_ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># 3D data: add channel dimension -&gt; (c, z, y, x) or (c, x, y, z)</span>
        <span class="n">darr</span> <span class="o">=</span> <span class="n">darr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="c1"># If axes_order is to ultimately be ZYX, transpose spatial XYZ to ZYX</span>
        <span class="k">if</span> <span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span><span class="p">:</span>
            <span class="n">darr</span> <span class="o">=</span> <span class="n">darr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># CXYZ -&gt; CZYX</span>
    <span class="k">elif</span> <span class="n">original_ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># 4D data: NIfTI stores as XYZC, we need CZYX or CXYZ</span>
        <span class="k">if</span> <span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span><span class="p">:</span>
            <span class="c1"># Transpose from XYZC to CZYX</span>
            <span class="n">darr</span> <span class="o">=</span> <span class="n">darr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># XYZC -&gt; CZYX</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Transpose from XYZC to CXYZ</span>
            <span class="n">darr</span> <span class="o">=</span> <span class="n">darr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># XYZC -&gt; CXYZ</span>
    <span class="k">elif</span> <span class="n">original_ndim</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="c1"># 5D data: assume (t, z, y, x, c) and handle appropriately</span>
        <span class="k">pass</span>  <span class="c1"># Keep as is - 5D is already the target format</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># For 1D, 2D, or &gt;5D data, add channel dimension and let user handle</span>
        <span class="n">darr</span> <span class="o">=</span> <span class="n">darr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

    <span class="c1"># Create dimensions based on data shape after dimension adjustments</span>
    <span class="n">final_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">darr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">final_ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># 4D: (c, z, y, x) or (c, x, y, z) - standard case</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes_order</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">final_ndim</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="c1"># 5D: (t, c, z, y, x) or (t, c, x, y, z) - time dimension included</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes_order</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Fallback for other cases</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes_order</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

    <span class="c1"># Extract translation from affine, scale from the zooms</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">translation</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">spatial_dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">):</span>
        <span class="n">scale</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">in_zooms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">translation</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">affine_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

    <span class="c1"># Create NgffImage</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;nifti_image_</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">ngff_image</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">darr</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="n">translation</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span>
    <span class="p">)</span>

    <span class="c1"># Extract channel labels from NIfTI header extensions if present</span>
    <span class="n">channel_labels</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="nb">hasattr</span><span class="p">(</span><span class="n">nifti_img</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot;extensions&quot;</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">nifti_img</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">extensions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">nifti_img</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">extensions</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ext</span><span class="o">.</span><span class="n">get_code</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Try to decode the extension content as JSON</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="n">ext</span><span class="o">.</span><span class="n">get_content</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>

                    <span class="c1"># Look for channel_labels in the metadata</span>
                    <span class="k">if</span> <span class="s2">&quot;channel_labels&quot;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
                        <span class="n">channel_labels</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;channel_labels&quot;</span><span class="p">]</span>
                        <span class="k">break</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">,</span> <span class="ne">UnicodeDecodeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="c1"># Skip extensions that aren&#39;t JSON or can&#39;t be decoded</span>
                <span class="k">continue</span>

    <span class="c1"># Create ZarrNii instance</span>
    <span class="c1"># Extract OMERO metadata for channel labels if present</span>
    <span class="n">omero_metadata</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">channel_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Get the number of channels from the data</span>
        <span class="n">num_channels</span> <span class="o">=</span> <span class="n">darr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;c&quot;</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="c1"># Only use channel labels if count matches</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel_labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_channels</span><span class="p">:</span>
            <span class="c1"># Create OMERO metadata with channel labels</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">ngff_zarr</span><span class="w"> </span><span class="kn">import</span> <span class="n">Omero</span><span class="p">,</span> <span class="n">OmeroChannel</span><span class="p">,</span> <span class="n">OmeroWindow</span>

                <span class="c1"># Create OMERO channels with labels</span>
                <span class="n">omero_channels</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">channel_labels</span><span class="p">:</span>
                    <span class="c1"># Create a minimal channel object with label</span>
                    <span class="c1"># Use default color (white) and window values</span>
                    <span class="n">window</span> <span class="o">=</span> <span class="n">OmeroWindow</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
                    <span class="n">omero_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">OmeroChannel</span><span class="p">(</span>
                            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;FFFFFF&quot;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span>  <span class="c1"># white</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                <span class="c1"># Create OMERO metadata</span>
                <span class="n">omero_metadata</span> <span class="o">=</span> <span class="n">Omero</span><span class="p">(</span><span class="n">channels</span><span class="o">=</span><span class="n">omero_channels</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="c1"># If OMERO classes aren&#39;t available or fail, skip</span>
                <span class="k">pass</span>

    <span class="n">zarrnii_instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span>
        <span class="n">_omero</span><span class="o">=</span><span class="n">omero_metadata</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">zarrnii_instance</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.crop" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">bbox_min</span><span class="p">,</span> <span class="n">bbox_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spatial_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">physical_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Extract a spatial region or multiple regions from the image.</p>
<p>Crops the image to the specified bounding box coordinates, preserving
all metadata and non-spatial dimensions (channels, time). The cropping
is performed in voxel coordinates by default, or physical coordinates
if specified. Can crop a single region or multiple regions at once.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>bbox_min</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, ...], <span title="typing.List">List</span>[<span title="typing.Tuple">Tuple</span>[<span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, ...], <span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, ...]]]]</code>)
          
          <div class="doc-md-description">
            <p>Either:
- Minimum corner coordinates of bounding box as tuple
  (when bbox_max is provided). Length should match number of
  spatial dimensions (x, y, z order)
- List of (bbox_min, bbox_max) tuples for batch cropping
  (when bbox_max is None)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>bbox_max</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, ...]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Maximum corner coordinates of bounding box as tuple.
Length should match number of spatial dimensions (x, y, z order).
Should be None when bbox_min is a list of bounding boxes.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>spatial_dims</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="str">str</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Names of spatial dimensions to crop. If None,
automatically derived from axes_order ("z","y","x" for ZYX
or "x","y","z" for XYZ)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>physical_coords</code></b>
              (<code><span title="bool">bool</span></code>, default:
                  <code>False</code>
)
          
          <div class="doc-md-description">
            <p>If True, bbox_min and bbox_max are in physical/world
coordinates (mm). If False, they are in voxel coordinates.
Default is False.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="typing.Union">Union</span>[&#39;ZarrNii&#39;, <span title="typing.List">List</span>[&#39;ZarrNii&#39;]]</code>
          
          <div class="doc-md-description">
            <p>New ZarrNii instance with cropped data (single crop) or list of</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.Union">Union</span>[&#39;ZarrNii&#39;, <span title="typing.List">List</span>[&#39;ZarrNii&#39;]]</code>
          
          <div class="doc-md-description">
            <p>ZarrNii instances (batch crop) with updated spatial metadata</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If bbox coordinates are invalid or out of bounds, or
if both list and bbox_max are provided</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="IndexError">IndexError</span></code>
            
          <div class="doc-md-description">
            <p>If bbox dimensions don't match spatial dimensions</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Crop 3D region (voxel coordinates)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cropped</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">crop</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">130</span><span class="p">))</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Crop with physical coordinates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cropped</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">crop</span><span class="p">((</span><span class="mf">10.5</span><span class="p">,</span> <span class="mf">20.5</span><span class="p">,</span> <span class="mf">30.5</span><span class="p">),</span> <span class="p">(</span><span class="mf">110.5</span><span class="p">,</span> <span class="mf">120.5</span><span class="p">,</span> <span class="mf">130.5</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="n">physical_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Crop with explicit spatial dimensions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cropped</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">),</span> <span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">170</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">spatial_dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Batch crop multiple regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bboxes</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">120</span><span class="p">),</span> <span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">170</span><span class="p">))</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cropped_list</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">bboxes</span><span class="p">,</span> <span class="n">physical_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Coordinates are in voxel space (0-based indexing) by default</li>
<li>Physical coordinates are in RAS orientation (Right-Anterior-Superior)</li>
<li>The cropped region includes bbox_min but excludes bbox_max</li>
<li>All non-spatial dimensions (channels, time) are preserved</li>
<li>Spatial transformations are automatically updated</li>
<li>When batch cropping, all patches share the same spatial_dims and
  physical_coords settings</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2247</span>
<span class="normal">2248</span>
<span class="normal">2249</span>
<span class="normal">2250</span>
<span class="normal">2251</span>
<span class="normal">2252</span>
<span class="normal">2253</span>
<span class="normal">2254</span>
<span class="normal">2255</span>
<span class="normal">2256</span>
<span class="normal">2257</span>
<span class="normal">2258</span>
<span class="normal">2259</span>
<span class="normal">2260</span>
<span class="normal">2261</span>
<span class="normal">2262</span>
<span class="normal">2263</span>
<span class="normal">2264</span>
<span class="normal">2265</span>
<span class="normal">2266</span>
<span class="normal">2267</span>
<span class="normal">2268</span>
<span class="normal">2269</span>
<span class="normal">2270</span>
<span class="normal">2271</span>
<span class="normal">2272</span>
<span class="normal">2273</span>
<span class="normal">2274</span>
<span class="normal">2275</span>
<span class="normal">2276</span>
<span class="normal">2277</span>
<span class="normal">2278</span>
<span class="normal">2279</span>
<span class="normal">2280</span>
<span class="normal">2281</span>
<span class="normal">2282</span>
<span class="normal">2283</span>
<span class="normal">2284</span>
<span class="normal">2285</span>
<span class="normal">2286</span>
<span class="normal">2287</span>
<span class="normal">2288</span>
<span class="normal">2289</span>
<span class="normal">2290</span>
<span class="normal">2291</span>
<span class="normal">2292</span>
<span class="normal">2293</span>
<span class="normal">2294</span>
<span class="normal">2295</span>
<span class="normal">2296</span>
<span class="normal">2297</span>
<span class="normal">2298</span>
<span class="normal">2299</span>
<span class="normal">2300</span>
<span class="normal">2301</span>
<span class="normal">2302</span>
<span class="normal">2303</span>
<span class="normal">2304</span>
<span class="normal">2305</span>
<span class="normal">2306</span>
<span class="normal">2307</span>
<span class="normal">2308</span>
<span class="normal">2309</span>
<span class="normal">2310</span>
<span class="normal">2311</span>
<span class="normal">2312</span>
<span class="normal">2313</span>
<span class="normal">2314</span>
<span class="normal">2315</span>
<span class="normal">2316</span>
<span class="normal">2317</span>
<span class="normal">2318</span>
<span class="normal">2319</span>
<span class="normal">2320</span>
<span class="normal">2321</span>
<span class="normal">2322</span>
<span class="normal">2323</span>
<span class="normal">2324</span>
<span class="normal">2325</span>
<span class="normal">2326</span>
<span class="normal">2327</span>
<span class="normal">2328</span>
<span class="normal">2329</span>
<span class="normal">2330</span>
<span class="normal">2331</span>
<span class="normal">2332</span>
<span class="normal">2333</span>
<span class="normal">2334</span>
<span class="normal">2335</span>
<span class="normal">2336</span>
<span class="normal">2337</span>
<span class="normal">2338</span>
<span class="normal">2339</span>
<span class="normal">2340</span>
<span class="normal">2341</span>
<span class="normal">2342</span>
<span class="normal">2343</span>
<span class="normal">2344</span>
<span class="normal">2345</span>
<span class="normal">2346</span>
<span class="normal">2347</span>
<span class="normal">2348</span>
<span class="normal">2349</span>
<span class="normal">2350</span>
<span class="normal">2351</span>
<span class="normal">2352</span>
<span class="normal">2353</span>
<span class="normal">2354</span>
<span class="normal">2355</span>
<span class="normal">2356</span>
<span class="normal">2357</span>
<span class="normal">2358</span>
<span class="normal">2359</span>
<span class="normal">2360</span>
<span class="normal">2361</span>
<span class="normal">2362</span>
<span class="normal">2363</span>
<span class="normal">2364</span>
<span class="normal">2365</span>
<span class="normal">2366</span>
<span class="normal">2367</span>
<span class="normal">2368</span>
<span class="normal">2369</span>
<span class="normal">2370</span>
<span class="normal">2371</span>
<span class="normal">2372</span>
<span class="normal">2373</span>
<span class="normal">2374</span>
<span class="normal">2375</span>
<span class="normal">2376</span>
<span class="normal">2377</span>
<span class="normal">2378</span>
<span class="normal">2379</span>
<span class="normal">2380</span>
<span class="normal">2381</span>
<span class="normal">2382</span>
<span class="normal">2383</span>
<span class="normal">2384</span>
<span class="normal">2385</span>
<span class="normal">2386</span>
<span class="normal">2387</span>
<span class="normal">2388</span>
<span class="normal">2389</span>
<span class="normal">2390</span>
<span class="normal">2391</span>
<span class="normal">2392</span>
<span class="normal">2393</span>
<span class="normal">2394</span>
<span class="normal">2395</span>
<span class="normal">2396</span>
<span class="normal">2397</span>
<span class="normal">2398</span>
<span class="normal">2399</span>
<span class="normal">2400</span>
<span class="normal">2401</span>
<span class="normal">2402</span>
<span class="normal">2403</span>
<span class="normal">2404</span>
<span class="normal">2405</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">crop</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">bbox_min</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span>
    <span class="p">],</span>
    <span class="n">bbox_max</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">spatial_dims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">physical_coords</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ZarrNii&quot;</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ZarrNii&quot;</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract a spatial region or multiple regions from the image.</span>

<span class="sd">    Crops the image to the specified bounding box coordinates, preserving</span>
<span class="sd">    all metadata and non-spatial dimensions (channels, time). The cropping</span>
<span class="sd">    is performed in voxel coordinates by default, or physical coordinates</span>
<span class="sd">    if specified. Can crop a single region or multiple regions at once.</span>

<span class="sd">    Args:</span>
<span class="sd">        bbox_min: Either:</span>
<span class="sd">            - Minimum corner coordinates of bounding box as tuple</span>
<span class="sd">              (when bbox_max is provided). Length should match number of</span>
<span class="sd">              spatial dimensions (x, y, z order)</span>
<span class="sd">            - List of (bbox_min, bbox_max) tuples for batch cropping</span>
<span class="sd">              (when bbox_max is None)</span>
<span class="sd">        bbox_max: Maximum corner coordinates of bounding box as tuple.</span>
<span class="sd">            Length should match number of spatial dimensions (x, y, z order).</span>
<span class="sd">            Should be None when bbox_min is a list of bounding boxes.</span>
<span class="sd">        spatial_dims: Names of spatial dimensions to crop. If None,</span>
<span class="sd">            automatically derived from axes_order (&quot;z&quot;,&quot;y&quot;,&quot;x&quot; for ZYX</span>
<span class="sd">            or &quot;x&quot;,&quot;y&quot;,&quot;z&quot; for XYZ)</span>
<span class="sd">        physical_coords: If True, bbox_min and bbox_max are in physical/world</span>
<span class="sd">            coordinates (mm). If False, they are in voxel coordinates.</span>
<span class="sd">            Default is False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        New ZarrNii instance with cropped data (single crop) or list of</span>
<span class="sd">        ZarrNii instances (batch crop) with updated spatial metadata</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If bbox coordinates are invalid or out of bounds, or</span>
<span class="sd">            if both list and bbox_max are provided</span>
<span class="sd">        IndexError: If bbox dimensions don&#39;t match spatial dimensions</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Crop 3D region (voxel coordinates)</span>
<span class="sd">        &gt;&gt;&gt; cropped = znii.crop((10, 20, 30), (110, 120, 130))</span>

<span class="sd">        &gt;&gt;&gt; # Crop with physical coordinates</span>
<span class="sd">        &gt;&gt;&gt; cropped = znii.crop((10.5, 20.5, 30.5), (110.5, 120.5, 130.5),</span>
<span class="sd">        ...                      physical_coords=True)</span>

<span class="sd">        &gt;&gt;&gt; # Crop with explicit spatial dimensions</span>
<span class="sd">        &gt;&gt;&gt; cropped = znii.crop(</span>
<span class="sd">        ...     (50, 60, 70), (150, 160, 170),</span>
<span class="sd">        ...     spatial_dims=[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; # Batch crop multiple regions</span>
<span class="sd">        &gt;&gt;&gt; bboxes = [</span>
<span class="sd">        ...     ((10, 20, 30), (60, 70, 80)),</span>
<span class="sd">        ...     ((100, 110, 120), (150, 160, 170))</span>
<span class="sd">        ... ]</span>
<span class="sd">        &gt;&gt;&gt; cropped_list = znii.crop(bboxes, physical_coords=True)</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Coordinates are in voxel space (0-based indexing) by default</span>
<span class="sd">        - Physical coordinates are in RAS orientation (Right-Anterior-Superior)</span>
<span class="sd">        - The cropped region includes bbox_min but excludes bbox_max</span>
<span class="sd">        - All non-spatial dimensions (channels, time) are preserved</span>
<span class="sd">        - Spatial transformations are automatically updated</span>
<span class="sd">        - When batch cropping, all patches share the same spatial_dims and</span>
<span class="sd">          physical_coords settings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if this is batch cropping (list of bounding boxes)</span>
    <span class="c1"># A batch crop is a list of (bbox_min, bbox_max) tuples</span>
    <span class="c1"># Each element should be a tuple/list of two elements</span>
    <span class="n">is_batch_crop</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox_min</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bbox_min</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bbox_min</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bbox_min</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">is_batch_crop</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bbox_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;bbox_max should be None when bbox_min is a list of bounding boxes&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Batch crop: recursively call crop for each bounding box</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">bmin</span><span class="p">,</span> <span class="n">bmax</span><span class="p">,</span> <span class="n">spatial_dims</span><span class="p">,</span> <span class="n">physical_coords</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bmin</span><span class="p">,</span> <span class="n">bmax</span> <span class="ow">in</span> <span class="n">bbox_min</span>
        <span class="p">]</span>

    <span class="c1"># Single crop: original implementation</span>
    <span class="k">if</span> <span class="n">bbox_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bbox_max is required when bbox_min is not a list&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">spatial_dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spatial_dims</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="c1"># Convert physical coordinates to voxel coordinates if needed</span>
    <span class="k">if</span> <span class="n">physical_coords</span><span class="p">:</span>
        <span class="c1"># Physical coords are always in (x, y, z) order</span>
        <span class="c1"># Convert to homogeneous coordinates</span>
        <span class="n">phys_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">bbox_min</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">])</span>
        <span class="n">phys_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">bbox_max</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">])</span>

        <span class="c1"># Get inverse affine to convert from physical to voxel</span>
        <span class="n">affine_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_affine_matrix</span><span class="p">(</span><span class="n">axes_order</span><span class="o">=</span><span class="s2">&quot;XYZ&quot;</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># TODO: should this always be xyz affine??</span>

        <span class="c1"># Transform to voxel coordinates</span>
        <span class="n">voxel_min</span> <span class="o">=</span> <span class="n">affine_inv</span> <span class="o">@</span> <span class="n">phys_min</span>
        <span class="n">voxel_max</span> <span class="o">=</span> <span class="n">affine_inv</span> <span class="o">@</span> <span class="n">phys_max</span>

        <span class="c1"># Extract voxel coordinates (x, y, z)</span>
        <span class="n">voxel_min_xyz</span> <span class="o">=</span> <span class="n">voxel_min</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">voxel_max_xyz</span> <span class="o">=</span> <span class="n">voxel_max</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># Round to nearest integer voxel indices</span>
        <span class="n">voxel_min_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">voxel_min_xyz</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">voxel_max_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">voxel_max_xyz</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Ensure max &gt;= min</span>
        <span class="n">voxel_min_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">voxel_min_xyz</span><span class="p">,</span> <span class="n">voxel_max_xyz</span><span class="p">)</span>
        <span class="n">voxel_max_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">affine_inv</span> <span class="o">@</span> <span class="n">phys_min</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[:</span><span class="mi">3</span><span class="p">],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">affine_inv</span> <span class="o">@</span> <span class="n">phys_max</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[:</span><span class="mi">3</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># Create mapping from x,y,z to voxel coordinates</span>
        <span class="n">bbox_min</span> <span class="o">=</span> <span class="n">voxel_min_xyz</span>
        <span class="n">bbox_max</span> <span class="o">=</span> <span class="n">voxel_max_xyz</span>

    <span class="c1"># Create mapping from x,y,z to voxel coordinates</span>
    <span class="n">bbox_vox_min</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">bbox_min</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">bbox_min</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">bbox_min</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="n">bbox_vox_max</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">bbox_max</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">bbox_max</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">bbox_max</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="n">dim_flips</span> <span class="o">=</span> <span class="n">_axcodes2flips</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">)</span>
    <span class="n">cropped_image</span> <span class="o">=</span> <span class="n">crop_ngff_image</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="p">,</span> <span class="n">bbox_vox_min</span><span class="p">,</span> <span class="n">bbox_vox_max</span><span class="p">,</span> <span class="n">dim_flips</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">ZarrNii</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">cropped_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">_omero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_omero</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.crop_with_bounding_box" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">crop_with_bounding_box</span><span class="p">(</span><span class="n">bbox_min</span><span class="p">,</span> <span class="n">bbox_max</span><span class="p">,</span> <span class="n">ras_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Legacy method name for crop.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>bbox_min</code></b>
          
          <div class="doc-md-description">
            <p>Minimum corner coordinates</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>bbox_max</code></b>
          
          <div class="doc-md-description">
            <p>Maximum corner coordinates</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>ras_coords</code></b>
          
          <div class="doc-md-description">
            <p>If True, coordinates are in RAS physical space (deprecated,
use physical_coords parameter of crop() instead)</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2407</span>
<span class="normal">2408</span>
<span class="normal">2409</span>
<span class="normal">2410</span>
<span class="normal">2411</span>
<span class="normal">2412</span>
<span class="normal">2413</span>
<span class="normal">2414</span>
<span class="normal">2415</span>
<span class="normal">2416</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">crop_with_bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bbox_min</span><span class="p">,</span> <span class="n">bbox_max</span><span class="p">,</span> <span class="n">ras_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Legacy method name for crop.</span>

<span class="sd">    Args:</span>
<span class="sd">        bbox_min: Minimum corner coordinates</span>
<span class="sd">        bbox_max: Maximum corner coordinates</span>
<span class="sd">        ras_coords: If True, coordinates are in RAS physical space (deprecated,</span>
<span class="sd">            use physical_coords parameter of crop() instead)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">bbox_min</span><span class="p">,</span> <span class="n">bbox_max</span><span class="p">,</span> <span class="n">physical_coords</span><span class="o">=</span><span class="n">ras_coords</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.crop_centered" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">crop_centered</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">spatial_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Extract fixed-size patches centered at specified coordinates.</p>
<p>Crops the image to extract patches of a fixed size (in voxels) centered
at the given physical coordinates. This is particularly useful for machine
learning workflows where training patches must have consistent dimensions.
The method can process a single center or multiple centers at once.</p>
<p>Patches that extend beyond image boundaries are padded with the fill_value
to ensure all patches have exactly the requested size.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>centers</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>], <span title="typing.List">List</span>[<span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>]]]</code>)
          
          <div class="doc-md-description">
            <p>Either:
- Single center coordinate as (x, y, z) tuple in physical space (mm)
- List of center coordinates for batch processing</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>patch_size</code></b>
              (<code><span title="typing.Tuple">Tuple</span>[<span title="int">int</span>, <span title="int">int</span>, <span title="int">int</span>]</code>)
          
          <div class="doc-md-description">
            <p>Size of the patch in voxels as (x, y, z) tuple.
This defines the dimensions of each cropped region in voxel space.
All returned patches will have exactly this size.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>spatial_dims</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="str">str</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Names of spatial dimensions to crop. If None,
automatically derived from axes_order ("z","y","x" for ZYX
or "x","y","z" for XYZ). Default is None.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>fill_value</code></b>
              (<code><span title="float">float</span></code>, default:
                  <code>0.0</code>
)
          
          <div class="doc-md-description">
            <p>Value to use for padding when patches extend beyond
image boundaries. Default is 0.0.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="typing.Union">Union</span>[&#39;ZarrNii&#39;, <span title="typing.List">List</span>[&#39;ZarrNii&#39;]]</code>
          
          <div class="doc-md-description">
            <p>Single ZarrNii instance (when centers is a single tuple) or list of</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.Union">Union</span>[&#39;ZarrNii&#39;, <span title="typing.List">List</span>[&#39;ZarrNii&#39;]]</code>
          
          <div class="doc-md-description">
            <p>ZarrNii instances (when centers is a list) with cropped data and</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.Union">Union</span>[&#39;ZarrNii&#39;, <span title="typing.List">List</span>[&#39;ZarrNii&#39;]]</code>
          
          <div class="doc-md-description">
            <p>updated spatial metadata. All patches will have exactly the shape</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.Union">Union</span>[&#39;ZarrNii&#39;, <span title="typing.List">List</span>[&#39;ZarrNii&#39;]]</code>
          
          <div class="doc-md-description">
            <p>specified by patch_size (plus any non-spatial dimensions).</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If coordinates/dimensions are invalid</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="IndexError">IndexError</span></code>
            
          <div class="doc-md-description">
            <p>If patch_size dimensions don't match spatial dimensions</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Extract single 256x256x256 voxel patch at a coordinate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="mf">50.0</span><span class="p">,</span> <span class="mf">60.0</span><span class="p">,</span> <span class="mf">70.0</span><span class="p">)</span>  <span class="c1"># physical coordinates in mm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patch</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">crop_centered</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">patch_size</span><span class="o">=</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Extract multiple patches for ML training</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centers</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mf">50.0</span><span class="p">,</span> <span class="mf">60.0</span><span class="p">,</span> <span class="mf">70.0</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mf">100.0</span><span class="p">,</span> <span class="mf">110.0</span><span class="p">,</span> <span class="mf">120.0</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mf">150.0</span><span class="p">,</span> <span class="mf">160.0</span><span class="p">,</span> <span class="mf">170.0</span><span class="p">)</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patches</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">crop_centered</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">patch_size</span><span class="o">=</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Returns list of 3 ZarrNii instances, all with shape (1, 128, 128, 128)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use with atlas sampling for ML training workflow</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centers</span> <span class="o">=</span> <span class="n">atlas</span><span class="o">.</span><span class="n">sample_region_patches</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">n_patches</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">region_ids</span><span class="o">=</span><span class="s2">&quot;cortex&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">seed</span><span class="o">=</span><span class="mi">42</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patches</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">crop_centered</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">patch_size</span><span class="o">=</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use custom fill value for padding</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patch</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">crop_centered</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">patch_size</span><span class="o">=</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">)</span>
</code></pre></div>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Centers are in physical/world coordinates (mm), always in (x, y, z) order</li>
<li>patch_size is in voxels, in (x, y, z) order</li>
<li>The patch is centered at the given coordinate, extending patch_size/2</li>
<li>If patch_size is odd, the center voxel is included</li>
<li>Patches near boundaries are padded with fill_value to maintain size</li>
<li>All patches are guaranteed to have exactly the requested size</li>
<li>Useful for ML training where fixed patch sizes are required</li>
<li>Coordinates from atlas.sample_region_patches() can be used directly</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2418</span>
<span class="normal">2419</span>
<span class="normal">2420</span>
<span class="normal">2421</span>
<span class="normal">2422</span>
<span class="normal">2423</span>
<span class="normal">2424</span>
<span class="normal">2425</span>
<span class="normal">2426</span>
<span class="normal">2427</span>
<span class="normal">2428</span>
<span class="normal">2429</span>
<span class="normal">2430</span>
<span class="normal">2431</span>
<span class="normal">2432</span>
<span class="normal">2433</span>
<span class="normal">2434</span>
<span class="normal">2435</span>
<span class="normal">2436</span>
<span class="normal">2437</span>
<span class="normal">2438</span>
<span class="normal">2439</span>
<span class="normal">2440</span>
<span class="normal">2441</span>
<span class="normal">2442</span>
<span class="normal">2443</span>
<span class="normal">2444</span>
<span class="normal">2445</span>
<span class="normal">2446</span>
<span class="normal">2447</span>
<span class="normal">2448</span>
<span class="normal">2449</span>
<span class="normal">2450</span>
<span class="normal">2451</span>
<span class="normal">2452</span>
<span class="normal">2453</span>
<span class="normal">2454</span>
<span class="normal">2455</span>
<span class="normal">2456</span>
<span class="normal">2457</span>
<span class="normal">2458</span>
<span class="normal">2459</span>
<span class="normal">2460</span>
<span class="normal">2461</span>
<span class="normal">2462</span>
<span class="normal">2463</span>
<span class="normal">2464</span>
<span class="normal">2465</span>
<span class="normal">2466</span>
<span class="normal">2467</span>
<span class="normal">2468</span>
<span class="normal">2469</span>
<span class="normal">2470</span>
<span class="normal">2471</span>
<span class="normal">2472</span>
<span class="normal">2473</span>
<span class="normal">2474</span>
<span class="normal">2475</span>
<span class="normal">2476</span>
<span class="normal">2477</span>
<span class="normal">2478</span>
<span class="normal">2479</span>
<span class="normal">2480</span>
<span class="normal">2481</span>
<span class="normal">2482</span>
<span class="normal">2483</span>
<span class="normal">2484</span>
<span class="normal">2485</span>
<span class="normal">2486</span>
<span class="normal">2487</span>
<span class="normal">2488</span>
<span class="normal">2489</span>
<span class="normal">2490</span>
<span class="normal">2491</span>
<span class="normal">2492</span>
<span class="normal">2493</span>
<span class="normal">2494</span>
<span class="normal">2495</span>
<span class="normal">2496</span>
<span class="normal">2497</span>
<span class="normal">2498</span>
<span class="normal">2499</span>
<span class="normal">2500</span>
<span class="normal">2501</span>
<span class="normal">2502</span>
<span class="normal">2503</span>
<span class="normal">2504</span>
<span class="normal">2505</span>
<span class="normal">2506</span>
<span class="normal">2507</span>
<span class="normal">2508</span>
<span class="normal">2509</span>
<span class="normal">2510</span>
<span class="normal">2511</span>
<span class="normal">2512</span>
<span class="normal">2513</span>
<span class="normal">2514</span>
<span class="normal">2515</span>
<span class="normal">2516</span>
<span class="normal">2517</span>
<span class="normal">2518</span>
<span class="normal">2519</span>
<span class="normal">2520</span>
<span class="normal">2521</span>
<span class="normal">2522</span>
<span class="normal">2523</span>
<span class="normal">2524</span>
<span class="normal">2525</span>
<span class="normal">2526</span>
<span class="normal">2527</span>
<span class="normal">2528</span>
<span class="normal">2529</span>
<span class="normal">2530</span>
<span class="normal">2531</span>
<span class="normal">2532</span>
<span class="normal">2533</span>
<span class="normal">2534</span>
<span class="normal">2535</span>
<span class="normal">2536</span>
<span class="normal">2537</span>
<span class="normal">2538</span>
<span class="normal">2539</span>
<span class="normal">2540</span>
<span class="normal">2541</span>
<span class="normal">2542</span>
<span class="normal">2543</span>
<span class="normal">2544</span>
<span class="normal">2545</span>
<span class="normal">2546</span>
<span class="normal">2547</span>
<span class="normal">2548</span>
<span class="normal">2549</span>
<span class="normal">2550</span>
<span class="normal">2551</span>
<span class="normal">2552</span>
<span class="normal">2553</span>
<span class="normal">2554</span>
<span class="normal">2555</span>
<span class="normal">2556</span>
<span class="normal">2557</span>
<span class="normal">2558</span>
<span class="normal">2559</span>
<span class="normal">2560</span>
<span class="normal">2561</span>
<span class="normal">2562</span>
<span class="normal">2563</span>
<span class="normal">2564</span>
<span class="normal">2565</span>
<span class="normal">2566</span>
<span class="normal">2567</span>
<span class="normal">2568</span>
<span class="normal">2569</span>
<span class="normal">2570</span>
<span class="normal">2571</span>
<span class="normal">2572</span>
<span class="normal">2573</span>
<span class="normal">2574</span>
<span class="normal">2575</span>
<span class="normal">2576</span>
<span class="normal">2577</span>
<span class="normal">2578</span>
<span class="normal">2579</span>
<span class="normal">2580</span>
<span class="normal">2581</span>
<span class="normal">2582</span>
<span class="normal">2583</span>
<span class="normal">2584</span>
<span class="normal">2585</span>
<span class="normal">2586</span>
<span class="normal">2587</span>
<span class="normal">2588</span>
<span class="normal">2589</span>
<span class="normal">2590</span>
<span class="normal">2591</span>
<span class="normal">2592</span>
<span class="normal">2593</span>
<span class="normal">2594</span>
<span class="normal">2595</span>
<span class="normal">2596</span>
<span class="normal">2597</span>
<span class="normal">2598</span>
<span class="normal">2599</span>
<span class="normal">2600</span>
<span class="normal">2601</span>
<span class="normal">2602</span>
<span class="normal">2603</span>
<span class="normal">2604</span>
<span class="normal">2605</span>
<span class="normal">2606</span>
<span class="normal">2607</span>
<span class="normal">2608</span>
<span class="normal">2609</span>
<span class="normal">2610</span>
<span class="normal">2611</span>
<span class="normal">2612</span>
<span class="normal">2613</span>
<span class="normal">2614</span>
<span class="normal">2615</span>
<span class="normal">2616</span>
<span class="normal">2617</span>
<span class="normal">2618</span>
<span class="normal">2619</span>
<span class="normal">2620</span>
<span class="normal">2621</span>
<span class="normal">2622</span>
<span class="normal">2623</span>
<span class="normal">2624</span>
<span class="normal">2625</span>
<span class="normal">2626</span>
<span class="normal">2627</span>
<span class="normal">2628</span>
<span class="normal">2629</span>
<span class="normal">2630</span>
<span class="normal">2631</span>
<span class="normal">2632</span>
<span class="normal">2633</span>
<span class="normal">2634</span>
<span class="normal">2635</span>
<span class="normal">2636</span>
<span class="normal">2637</span>
<span class="normal">2638</span>
<span class="normal">2639</span>
<span class="normal">2640</span>
<span class="normal">2641</span>
<span class="normal">2642</span>
<span class="normal">2643</span>
<span class="normal">2644</span>
<span class="normal">2645</span>
<span class="normal">2646</span>
<span class="normal">2647</span>
<span class="normal">2648</span>
<span class="normal">2649</span>
<span class="normal">2650</span>
<span class="normal">2651</span>
<span class="normal">2652</span>
<span class="normal">2653</span>
<span class="normal">2654</span>
<span class="normal">2655</span>
<span class="normal">2656</span>
<span class="normal">2657</span>
<span class="normal">2658</span>
<span class="normal">2659</span>
<span class="normal">2660</span>
<span class="normal">2661</span>
<span class="normal">2662</span>
<span class="normal">2663</span>
<span class="normal">2664</span>
<span class="normal">2665</span>
<span class="normal">2666</span>
<span class="normal">2667</span>
<span class="normal">2668</span>
<span class="normal">2669</span>
<span class="normal">2670</span>
<span class="normal">2671</span>
<span class="normal">2672</span>
<span class="normal">2673</span>
<span class="normal">2674</span>
<span class="normal">2675</span>
<span class="normal">2676</span>
<span class="normal">2677</span>
<span class="normal">2678</span>
<span class="normal">2679</span>
<span class="normal">2680</span>
<span class="normal">2681</span>
<span class="normal">2682</span>
<span class="normal">2683</span>
<span class="normal">2684</span>
<span class="normal">2685</span>
<span class="normal">2686</span>
<span class="normal">2687</span>
<span class="normal">2688</span>
<span class="normal">2689</span>
<span class="normal">2690</span>
<span class="normal">2691</span>
<span class="normal">2692</span>
<span class="normal">2693</span>
<span class="normal">2694</span>
<span class="normal">2695</span>
<span class="normal">2696</span>
<span class="normal">2697</span>
<span class="normal">2698</span>
<span class="normal">2699</span>
<span class="normal">2700</span>
<span class="normal">2701</span>
<span class="normal">2702</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">crop_centered</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">centers</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]],</span>
    <span class="n">patch_size</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">spatial_dims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ZarrNii&quot;</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ZarrNii&quot;</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract fixed-size patches centered at specified coordinates.</span>

<span class="sd">    Crops the image to extract patches of a fixed size (in voxels) centered</span>
<span class="sd">    at the given physical coordinates. This is particularly useful for machine</span>
<span class="sd">    learning workflows where training patches must have consistent dimensions.</span>
<span class="sd">    The method can process a single center or multiple centers at once.</span>

<span class="sd">    Patches that extend beyond image boundaries are padded with the fill_value</span>
<span class="sd">    to ensure all patches have exactly the requested size.</span>

<span class="sd">    Args:</span>
<span class="sd">        centers: Either:</span>
<span class="sd">            - Single center coordinate as (x, y, z) tuple in physical space (mm)</span>
<span class="sd">            - List of center coordinates for batch processing</span>
<span class="sd">        patch_size: Size of the patch in voxels as (x, y, z) tuple.</span>
<span class="sd">            This defines the dimensions of each cropped region in voxel space.</span>
<span class="sd">            All returned patches will have exactly this size.</span>
<span class="sd">        spatial_dims: Names of spatial dimensions to crop. If None,</span>
<span class="sd">            automatically derived from axes_order (&quot;z&quot;,&quot;y&quot;,&quot;x&quot; for ZYX</span>
<span class="sd">            or &quot;x&quot;,&quot;y&quot;,&quot;z&quot; for XYZ). Default is None.</span>
<span class="sd">        fill_value: Value to use for padding when patches extend beyond</span>
<span class="sd">            image boundaries. Default is 0.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Single ZarrNii instance (when centers is a single tuple) or list of</span>
<span class="sd">        ZarrNii instances (when centers is a list) with cropped data and</span>
<span class="sd">        updated spatial metadata. All patches will have exactly the shape</span>
<span class="sd">        specified by patch_size (plus any non-spatial dimensions).</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If coordinates/dimensions are invalid</span>
<span class="sd">        IndexError: If patch_size dimensions don&#39;t match spatial dimensions</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Extract single 256x256x256 voxel patch at a coordinate</span>
<span class="sd">        &gt;&gt;&gt; center = (50.0, 60.0, 70.0)  # physical coordinates in mm</span>
<span class="sd">        &gt;&gt;&gt; patch = znii.crop_centered(center, patch_size=(256, 256, 256))</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Extract multiple patches for ML training</span>
<span class="sd">        &gt;&gt;&gt; centers = [</span>
<span class="sd">        ...     (50.0, 60.0, 70.0),</span>
<span class="sd">        ...     (100.0, 110.0, 120.0),</span>
<span class="sd">        ...     (150.0, 160.0, 170.0)</span>
<span class="sd">        ... ]</span>
<span class="sd">        &gt;&gt;&gt; patches = znii.crop_centered(centers, patch_size=(128, 128, 128))</span>
<span class="sd">        &gt;&gt;&gt; # Returns list of 3 ZarrNii instances, all with shape (1, 128, 128, 128)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Use with atlas sampling for ML training workflow</span>
<span class="sd">        &gt;&gt;&gt; centers = atlas.sample_region_patches(</span>
<span class="sd">        ...     n_patches=100,</span>
<span class="sd">        ...     region_ids=&quot;cortex&quot;,</span>
<span class="sd">        ...     seed=42</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; patches = image.crop_centered(centers, patch_size=(256, 256, 256))</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Use custom fill value for padding</span>
<span class="sd">        &gt;&gt;&gt; patch = znii.crop_centered(center, patch_size=(256, 256, 256), fill_value=-1.0)</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Centers are in physical/world coordinates (mm), always in (x, y, z) order</span>
<span class="sd">        - patch_size is in voxels, in (x, y, z) order</span>
<span class="sd">        - The patch is centered at the given coordinate, extending patch_size/2</span>
<span class="sd">        - If patch_size is odd, the center voxel is included</span>
<span class="sd">        - Patches near boundaries are padded with fill_value to maintain size</span>
<span class="sd">        - All patches are guaranteed to have exactly the requested size</span>
<span class="sd">        - Useful for ML training where fixed patch sizes are required</span>
<span class="sd">        - Coordinates from atlas.sample_region_patches() can be used directly</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if this is batch processing (list of centers)</span>
    <span class="n">is_batch</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_batch</span><span class="p">:</span>
        <span class="c1"># Batch processing: recursively call crop_centered for each center</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">crop_centered</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">patch_size</span><span class="p">,</span> <span class="n">spatial_dims</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">center</span> <span class="ow">in</span> <span class="n">centers</span>
        <span class="p">]</span>

    <span class="c1"># Single center processing</span>
    <span class="k">if</span> <span class="n">spatial_dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spatial_dims</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="c1"># Convert center from physical to voxel coordinates</span>
    <span class="c1"># Centers are always in (x, y, z) order</span>
    <span class="n">center_phys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">])</span>

    <span class="c1"># Get inverse affine to convert from physical to voxel</span>
    <span class="n">affine_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_affine_matrix</span><span class="p">(</span><span class="n">axes_order</span><span class="o">=</span><span class="s2">&quot;XYZ&quot;</span><span class="p">))</span>

    <span class="c1"># Transform to voxel coordinates</span>
    <span class="n">center_voxel</span> <span class="o">=</span> <span class="n">affine_inv</span> <span class="o">@</span> <span class="n">center_phys</span>
    <span class="n">center_voxel_xyz</span> <span class="o">=</span> <span class="n">center_voxel</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1"># patch_size is in voxels, in (x, y, z) order</span>
    <span class="n">patch_size_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">patch_size</span><span class="p">)</span>
    <span class="n">half_patch</span> <span class="o">=</span> <span class="n">patch_size_np</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="c1"># Calculate desired bounding box in voxel coordinates (may extend beyond image)</span>
    <span class="n">voxel_min_xyz</span> <span class="o">=</span> <span class="n">center_voxel_xyz</span> <span class="o">-</span> <span class="n">half_patch</span>
    <span class="n">voxel_max_xyz</span> <span class="o">=</span> <span class="n">center_voxel_xyz</span> <span class="o">+</span> <span class="n">half_patch</span>

    <span class="c1"># Round to nearest integer voxel indices</span>
    <span class="n">voxel_min_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">voxel_min_xyz</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">voxel_max_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">voxel_max_xyz</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Ensure we get exactly the requested patch size</span>
    <span class="c1"># Adjust max to ensure patch_size is respected</span>
    <span class="n">voxel_max_xyz</span> <span class="o">=</span> <span class="n">voxel_min_xyz</span> <span class="o">+</span> <span class="n">patch_size_np</span>

    <span class="c1"># Get image dimensions in voxel space</span>
    <span class="c1"># Map spatial dims to their indices</span>
    <span class="n">spatial_dim_indices</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">spatial_dims</span><span class="p">]:</span>
            <span class="n">spatial_dim_indices</span><span class="p">[</span><span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="n">image_shape_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">spatial_dim_indices</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">spatial_dim_indices</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">spatial_dim_indices</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]],</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Calculate the actual crop region (clipped to image bounds)</span>
    <span class="n">crop_min_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">voxel_min_xyz</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">crop_max_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">voxel_max_xyz</span><span class="p">,</span> <span class="n">image_shape_xyz</span><span class="p">)</span>

    <span class="c1"># Ensure crop_max &gt;= crop_min to avoid empty arrays</span>
    <span class="n">crop_max_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">crop_min_xyz</span><span class="p">,</span> <span class="n">crop_max_xyz</span><span class="p">)</span>

    <span class="c1"># Calculate padding needed on each side</span>
    <span class="n">pad_before_xyz</span> <span class="o">=</span> <span class="n">crop_min_xyz</span> <span class="o">-</span> <span class="n">voxel_min_xyz</span>  <span class="c1"># How much we&#39;re clipped at start</span>
    <span class="n">pad_after_xyz</span> <span class="o">=</span> <span class="n">voxel_max_xyz</span> <span class="o">-</span> <span class="n">crop_max_xyz</span>  <span class="c1"># How much we&#39;re clipped at end</span>

    <span class="c1"># Check if the entire patch is outside the image bounds</span>
    <span class="c1"># This happens when crop_min &gt;= crop_max in any dimension after clipping</span>
    <span class="n">is_completely_outside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">crop_min_xyz</span> <span class="o">&gt;=</span> <span class="n">crop_max_xyz</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_completely_outside</span><span class="p">:</span>
        <span class="c1"># The entire patch is outside the image bounds</span>
        <span class="c1"># Create a completely padded array with the fill value</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">dask.array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">da</span>

        <span class="c1"># Build the full patch shape</span>
        <span class="n">full_shape</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spatial_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">spatial_dims</span><span class="p">]:</span>
                <span class="n">full_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch_size_np</span><span class="p">[</span><span class="n">spatial_idx</span><span class="p">])</span>
                <span class="n">spatial_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Non-spatial dimension - keep original size</span>
                <span class="n">dim_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                <span class="n">full_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim_idx</span><span class="p">])</span>

        <span class="c1"># Create array filled with fill_value</span>
        <span class="n">padded_data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">full_shape</span><span class="p">),</span>
            <span class="n">fill_value</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">chunks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">chunksize</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Calculate translation for the patch center</span>
        <span class="c1"># The translation should be at voxel_min_xyz (the desired start of patch)</span>
        <span class="n">new_translation</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">spatial_dims</span><span class="p">]:</span>
                <span class="n">dim_lower</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">dim_lower</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
                    <span class="n">voxel_start</span> <span class="o">=</span> <span class="n">voxel_min_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">dim_lower</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                    <span class="n">voxel_start</span> <span class="o">=</span> <span class="n">voxel_min_xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">dim_lower</span> <span class="o">==</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span>
                    <span class="n">voxel_start</span> <span class="o">=</span> <span class="n">voxel_min_xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">voxel_start</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Translation is voxel_start * scale + original translation</span>
                <span class="n">new_translation</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">voxel_start</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">dim</span><span class="p">,</span> <span class="mf">1.0</span>
                <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">translation</span><span class="p">:</span>
                <span class="n">new_translation</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">translation</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="c1"># Create NgffImage with the padded data</span>
        <span class="n">padded_image</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">padded_data</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">translation</span><span class="o">=</span><span class="n">new_translation</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">ZarrNii</span><span class="p">(</span>
            <span class="n">ngff_image</span><span class="o">=</span><span class="n">padded_image</span><span class="p">,</span>
            <span class="n">axes_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
            <span class="n">xyz_orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
            <span class="n">_omero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_omero</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Create mapping from x,y,z to voxel coordinates for cropping</span>
    <span class="n">bbox_vox_min</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">crop_min_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">crop_min_xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">crop_min_xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="n">bbox_vox_max</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">crop_max_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">crop_max_xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">crop_max_xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="n">dim_flips</span> <span class="o">=</span> <span class="n">_axcodes2flips</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">)</span>
    <span class="c1"># Crop the actual image data that exists</span>
    <span class="n">cropped_image</span> <span class="o">=</span> <span class="n">crop_ngff_image</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="p">,</span> <span class="n">bbox_vox_min</span><span class="p">,</span> <span class="n">bbox_vox_max</span><span class="p">,</span> <span class="n">dim_flips</span>
    <span class="p">)</span>

    <span class="c1"># Check if padding is needed</span>
    <span class="n">needs_padding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pad_before_xyz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pad_after_xyz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">needs_padding</span><span class="p">:</span>
        <span class="c1"># Build padding specification for all dimensions</span>
        <span class="n">pad_width</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spatial_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">cropped_image</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">spatial_dims</span><span class="p">]:</span>
                <span class="c1"># Spatial dimension - may need padding</span>
                <span class="n">dim_lower</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">dim_lower</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
                    <span class="n">pad_width</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pad_before_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pad_after_xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="n">dim_lower</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                    <span class="n">pad_width</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pad_before_xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pad_after_xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="n">dim_lower</span> <span class="o">==</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span>
                    <span class="n">pad_width</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pad_before_xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">pad_after_xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="n">spatial_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Non-spatial dimension - no padding</span>
                <span class="n">pad_width</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="c1"># Apply padding</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">dask.array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">da</span>

        <span class="n">padded_data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
            <span class="n">cropped_image</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">pad_width</span><span class="o">=</span><span class="n">pad_width</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
            <span class="n">constant_values</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Adjust translation for the padding</span>
        <span class="n">new_translation</span> <span class="o">=</span> <span class="n">cropped_image</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bbox_vox_min</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">new_translation</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_translation</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+</span> <span class="n">dim_flips</span><span class="p">[</span>
                <span class="n">dim</span>
            <span class="p">]</span> <span class="o">*</span> <span class="n">pad_before_xyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">cropped_image</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># Create padded NgffImage</span>
        <span class="n">cropped_image</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">padded_data</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">cropped_image</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">scale</span><span class="o">=</span><span class="n">cropped_image</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
            <span class="n">translation</span><span class="o">=</span><span class="n">new_translation</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">cropped_image</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">ZarrNii</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">cropped_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">_omero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_omero</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.downsample" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">factors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">along_x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">along_y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">along_z</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spatial_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Reduce image resolution by downsampling.</p>
<p>Performs spatial downsampling by averaging blocks of voxels, effectively
reducing image resolution and size. Multiple parameter options provide
flexibility for different downsampling strategies.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>factors</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="typing.List">List</span>[<span title="int">int</span>]]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Downsampling factors for spatial dimensions. Can be:
- int: Same factor applied to all spatial dimensions
- List[int]: Per-dimension factors matching spatial_dims order
- None: Use other parameters to determine factors</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>along_x</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>1</code>
)
          
          <div class="doc-md-description">
            <p>Downsampling factor for X dimension (legacy parameter)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>along_y</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>1</code>
)
          
          <div class="doc-md-description">
            <p>Downsampling factor for Y dimension (legacy parameter)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>along_z</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>1</code>
)
          
          <div class="doc-md-description">
            <p>Downsampling factor for Z dimension (legacy parameter)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>level</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="int">int</span>]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Power-of-2 downsampling level (factors = 2^level).
Takes precedence over along_* parameters</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>spatial_dims</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="str">str</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Names of spatial dimensions. If None, derived
from axes_order</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>New ZarrNii instance with downsampled data and updated metadata</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If conflicting parameters provided or invalid factors</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Isotropic downsampling by factor of 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">downsampled</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">factors</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Anisotropic downsampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">downsampled</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">factors</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Using legacy parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">downsampled</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">along_x</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">along_y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">along_z</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Power-of-2 downsampling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">downsampled</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># factors = 4</span>
</code></pre></div>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Downsampling uses block averaging for anti-aliasing</li>
<li>Spatial transformations are automatically scaled</li>
<li>Non-spatial dimensions (channels, time) are preserved</li>
<li>Original data remains unchanged (creates new instance)</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2704</span>
<span class="normal">2705</span>
<span class="normal">2706</span>
<span class="normal">2707</span>
<span class="normal">2708</span>
<span class="normal">2709</span>
<span class="normal">2710</span>
<span class="normal">2711</span>
<span class="normal">2712</span>
<span class="normal">2713</span>
<span class="normal">2714</span>
<span class="normal">2715</span>
<span class="normal">2716</span>
<span class="normal">2717</span>
<span class="normal">2718</span>
<span class="normal">2719</span>
<span class="normal">2720</span>
<span class="normal">2721</span>
<span class="normal">2722</span>
<span class="normal">2723</span>
<span class="normal">2724</span>
<span class="normal">2725</span>
<span class="normal">2726</span>
<span class="normal">2727</span>
<span class="normal">2728</span>
<span class="normal">2729</span>
<span class="normal">2730</span>
<span class="normal">2731</span>
<span class="normal">2732</span>
<span class="normal">2733</span>
<span class="normal">2734</span>
<span class="normal">2735</span>
<span class="normal">2736</span>
<span class="normal">2737</span>
<span class="normal">2738</span>
<span class="normal">2739</span>
<span class="normal">2740</span>
<span class="normal">2741</span>
<span class="normal">2742</span>
<span class="normal">2743</span>
<span class="normal">2744</span>
<span class="normal">2745</span>
<span class="normal">2746</span>
<span class="normal">2747</span>
<span class="normal">2748</span>
<span class="normal">2749</span>
<span class="normal">2750</span>
<span class="normal">2751</span>
<span class="normal">2752</span>
<span class="normal">2753</span>
<span class="normal">2754</span>
<span class="normal">2755</span>
<span class="normal">2756</span>
<span class="normal">2757</span>
<span class="normal">2758</span>
<span class="normal">2759</span>
<span class="normal">2760</span>
<span class="normal">2761</span>
<span class="normal">2762</span>
<span class="normal">2763</span>
<span class="normal">2764</span>
<span class="normal">2765</span>
<span class="normal">2766</span>
<span class="normal">2767</span>
<span class="normal">2768</span>
<span class="normal">2769</span>
<span class="normal">2770</span>
<span class="normal">2771</span>
<span class="normal">2772</span>
<span class="normal">2773</span>
<span class="normal">2774</span>
<span class="normal">2775</span>
<span class="normal">2776</span>
<span class="normal">2777</span>
<span class="normal">2778</span>
<span class="normal">2779</span>
<span class="normal">2780</span>
<span class="normal">2781</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">downsample</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">factors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">along_x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">along_y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">along_z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">level</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">spatial_dims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reduce image resolution by downsampling.</span>

<span class="sd">    Performs spatial downsampling by averaging blocks of voxels, effectively</span>
<span class="sd">    reducing image resolution and size. Multiple parameter options provide</span>
<span class="sd">    flexibility for different downsampling strategies.</span>

<span class="sd">    Args:</span>
<span class="sd">        factors: Downsampling factors for spatial dimensions. Can be:</span>
<span class="sd">            - int: Same factor applied to all spatial dimensions</span>
<span class="sd">            - List[int]: Per-dimension factors matching spatial_dims order</span>
<span class="sd">            - None: Use other parameters to determine factors</span>
<span class="sd">        along_x: Downsampling factor for X dimension (legacy parameter)</span>
<span class="sd">        along_y: Downsampling factor for Y dimension (legacy parameter)</span>
<span class="sd">        along_z: Downsampling factor for Z dimension (legacy parameter)</span>
<span class="sd">        level: Power-of-2 downsampling level (factors = 2^level).</span>
<span class="sd">            Takes precedence over along_* parameters</span>
<span class="sd">        spatial_dims: Names of spatial dimensions. If None, derived</span>
<span class="sd">            from axes_order</span>

<span class="sd">    Returns:</span>
<span class="sd">        New ZarrNii instance with downsampled data and updated metadata</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If conflicting parameters provided or invalid factors</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Isotropic downsampling by factor of 2</span>
<span class="sd">        &gt;&gt;&gt; downsampled = znii.downsample(factors=2)</span>

<span class="sd">        &gt;&gt;&gt; # Anisotropic downsampling</span>
<span class="sd">        &gt;&gt;&gt; downsampled = znii.downsample(factors=[1, 2, 2])</span>

<span class="sd">        &gt;&gt;&gt; # Using legacy parameters</span>
<span class="sd">        &gt;&gt;&gt; downsampled = znii.downsample(along_x=2, along_y=2, along_z=1)</span>

<span class="sd">        &gt;&gt;&gt; # Power-of-2 downsampling</span>
<span class="sd">        &gt;&gt;&gt; downsampled = znii.downsample(level=2)  # factors = 4</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Downsampling uses block averaging for anti-aliasing</span>
<span class="sd">        - Spatial transformations are automatically scaled</span>
<span class="sd">        - Non-spatial dimensions (channels, time) are preserved</span>
<span class="sd">        - Original data remains unchanged (creates new instance)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Handle legacy parameters</span>
    <span class="k">if</span> <span class="n">factors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">factors</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">level</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">factors</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="n">along_z</span><span class="p">,</span> <span class="n">along_y</span><span class="p">,</span> <span class="n">along_x</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span>
                <span class="k">else</span> <span class="p">[</span><span class="n">along_x</span><span class="p">,</span> <span class="n">along_y</span><span class="p">,</span> <span class="n">along_z</span><span class="p">]</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">spatial_dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spatial_dims</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="n">downsampled_image</span> <span class="o">=</span> <span class="n">downsample_ngff_image</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="p">,</span> <span class="n">factors</span><span class="p">,</span> <span class="n">spatial_dims</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">ZarrNii</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">downsampled_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">_omero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_omero</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.upsample" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">upsample</span><span class="p">(</span><span class="n">along_x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">along_y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">along_z</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">to_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Upsamples the ZarrNii instance using <code>scipy.ndimage.zoom</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>along_x</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>1</code>
)
          
          <div class="doc-md-description">
            <p>Upsampling factor along the X-axis (default: 1).</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>along_y</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>1</code>
)
          
          <div class="doc-md-description">
            <p>Upsampling factor along the Y-axis (default: 1).</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>along_z</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>1</code>
)
          
          <div class="doc-md-description">
            <p>Upsampling factor along the Z-axis (default: 1).</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>to_shape</code></b>
              (<code><span title="tuple">tuple</span></code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Target shape for upsampling. Should include all dimensions
                         (e.g., <code>(c, z, y, x)</code> for ZYX or <code>(c, x, y, z)</code> for XYZ).
                         If provided, <code>along_x</code>, <code>along_y</code>, and <code>along_z</code> are ignored.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>ZarrNii</code></b>          
          <div class="doc-md-description">
            <p>A new ZarrNii instance with the upsampled data and updated affine.</p>
          </div>
        </li>
    </ul>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>This method supports both direct scaling via <code>along_*</code> factors or target shape via <code>to_shape</code>.</li>
<li>If <code>to_shape</code> is provided, chunk sizes and scaling factors are dynamically calculated.</li>
<li>The affine matrix is updated to reflect the new voxel size after upsampling.</li>
</ul>
</details>

<details class="example" open>
  <summary>Example</summary>
  <h4 id="zarrnii.ZarrNii.upsample--upsample-with-scaling-factors">Upsample with scaling factors</h4>
<p>upsampled_znimg = znimg.upsample(along_x=2, along_y=2, along_z=2)</p>
<h4 id="zarrnii.ZarrNii.upsample--upsample-to-a-specific-shape">Upsample to a specific shape</h4>
<p>upsampled_znimg = znimg.upsample(to_shape=(1, 256, 256, 256))</p>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2783</span>
<span class="normal">2784</span>
<span class="normal">2785</span>
<span class="normal">2786</span>
<span class="normal">2787</span>
<span class="normal">2788</span>
<span class="normal">2789</span>
<span class="normal">2790</span>
<span class="normal">2791</span>
<span class="normal">2792</span>
<span class="normal">2793</span>
<span class="normal">2794</span>
<span class="normal">2795</span>
<span class="normal">2796</span>
<span class="normal">2797</span>
<span class="normal">2798</span>
<span class="normal">2799</span>
<span class="normal">2800</span>
<span class="normal">2801</span>
<span class="normal">2802</span>
<span class="normal">2803</span>
<span class="normal">2804</span>
<span class="normal">2805</span>
<span class="normal">2806</span>
<span class="normal">2807</span>
<span class="normal">2808</span>
<span class="normal">2809</span>
<span class="normal">2810</span>
<span class="normal">2811</span>
<span class="normal">2812</span>
<span class="normal">2813</span>
<span class="normal">2814</span>
<span class="normal">2815</span>
<span class="normal">2816</span>
<span class="normal">2817</span>
<span class="normal">2818</span>
<span class="normal">2819</span>
<span class="normal">2820</span>
<span class="normal">2821</span>
<span class="normal">2822</span>
<span class="normal">2823</span>
<span class="normal">2824</span>
<span class="normal">2825</span>
<span class="normal">2826</span>
<span class="normal">2827</span>
<span class="normal">2828</span>
<span class="normal">2829</span>
<span class="normal">2830</span>
<span class="normal">2831</span>
<span class="normal">2832</span>
<span class="normal">2833</span>
<span class="normal">2834</span>
<span class="normal">2835</span>
<span class="normal">2836</span>
<span class="normal">2837</span>
<span class="normal">2838</span>
<span class="normal">2839</span>
<span class="normal">2840</span>
<span class="normal">2841</span>
<span class="normal">2842</span>
<span class="normal">2843</span>
<span class="normal">2844</span>
<span class="normal">2845</span>
<span class="normal">2846</span>
<span class="normal">2847</span>
<span class="normal">2848</span>
<span class="normal">2849</span>
<span class="normal">2850</span>
<span class="normal">2851</span>
<span class="normal">2852</span>
<span class="normal">2853</span>
<span class="normal">2854</span>
<span class="normal">2855</span>
<span class="normal">2856</span>
<span class="normal">2857</span>
<span class="normal">2858</span>
<span class="normal">2859</span>
<span class="normal">2860</span>
<span class="normal">2861</span>
<span class="normal">2862</span>
<span class="normal">2863</span>
<span class="normal">2864</span>
<span class="normal">2865</span>
<span class="normal">2866</span>
<span class="normal">2867</span>
<span class="normal">2868</span>
<span class="normal">2869</span>
<span class="normal">2870</span>
<span class="normal">2871</span>
<span class="normal">2872</span>
<span class="normal">2873</span>
<span class="normal">2874</span>
<span class="normal">2875</span>
<span class="normal">2876</span>
<span class="normal">2877</span>
<span class="normal">2878</span>
<span class="normal">2879</span>
<span class="normal">2880</span>
<span class="normal">2881</span>
<span class="normal">2882</span>
<span class="normal">2883</span>
<span class="normal">2884</span>
<span class="normal">2885</span>
<span class="normal">2886</span>
<span class="normal">2887</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">upsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">along_x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">along_y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">along_z</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">to_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Upsamples the ZarrNii instance using `scipy.ndimage.zoom`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        along_x (int, optional): Upsampling factor along the X-axis (default: 1).</span>
<span class="sd">        along_y (int, optional): Upsampling factor along the Y-axis (default: 1).</span>
<span class="sd">        along_z (int, optional): Upsampling factor along the Z-axis (default: 1).</span>
<span class="sd">        to_shape (tuple, optional): Target shape for upsampling. Should include all dimensions</span>
<span class="sd">                                     (e.g., `(c, z, y, x)` for ZYX or `(c, x, y, z)` for XYZ).</span>
<span class="sd">                                     If provided, `along_x`, `along_y`, and `along_z` are ignored.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ZarrNii: A new ZarrNii instance with the upsampled data and updated affine.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - This method supports both direct scaling via `along_*` factors or target shape via `to_shape`.</span>
<span class="sd">        - If `to_shape` is provided, chunk sizes and scaling factors are dynamically calculated.</span>
<span class="sd">        - The affine matrix is updated to reflect the new voxel size after upsampling.</span>

<span class="sd">    Example:</span>
<span class="sd">        # Upsample with scaling factors</span>
<span class="sd">        upsampled_znimg = znimg.upsample(along_x=2, along_y=2, along_z=2)</span>

<span class="sd">        # Upsample to a specific shape</span>
<span class="sd">        upsampled_znimg = znimg.upsample(to_shape=(1, 256, 256, 256))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine scaling and chunks based on input parameters</span>
    <span class="k">if</span> <span class="n">to_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;XYZ&quot;</span><span class="p">:</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">along_x</span><span class="p">,</span> <span class="n">along_y</span><span class="p">,</span> <span class="n">along_z</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">along_z</span><span class="p">,</span> <span class="n">along_y</span><span class="p">,</span> <span class="n">along_x</span><span class="p">)</span>

        <span class="n">chunks_out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">scale</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunks_i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">chunks_i</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chunks_out</span><span class="p">,</span> <span class="n">scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_upsampled_chunks</span><span class="p">(</span><span class="n">to_shape</span><span class="p">)</span>

    <span class="c1"># Define block-wise upsampling function</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">zoom_blocks</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">block_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scales blocks to the desired size using `scipy.ndimage.zoom`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            x (np.ndarray): Input block data.</span>
<span class="sd">            block_info (dict, optional): Metadata about the current block.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The upscaled block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate scaling factors based on input and output chunk shapes</span>
        <span class="n">scaling</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">out_n</span> <span class="o">/</span> <span class="n">in_n</span>
            <span class="k">for</span> <span class="n">out_n</span><span class="p">,</span> <span class="n">in_n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">block_info</span><span class="p">[</span><span class="kc">None</span><span class="p">][</span><span class="s2">&quot;chunk-shape&quot;</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">zoom</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">scaling</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prefilter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Perform block-wise upsampling</span>
    <span class="n">darr_scaled</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span>
        <span class="n">zoom_blocks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks_out</span>
    <span class="p">)</span>

    <span class="c1"># Update the affine matrix to reflect the new voxel size</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;XYZ&quot;</span><span class="p">:</span>
        <span class="n">scaling_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scaling_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Create new NgffImage with upsampled data</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;XYZ&quot;</span><span class="p">:</span>
        <span class="n">new_scale</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">dims</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_scale</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">dims</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">dims</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="p">}</span>

    <span class="n">upsampled_ngff</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">to_ngff_image</span><span class="p">(</span>
        <span class="n">darr_scaled</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">new_scale</span><span class="p">,</span>
        <span class="n">translation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Return a new ZarrNii instance with the upsampled data</span>
    <span class="k">return</span> <span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_ngff_image</span><span class="p">(</span>
        <span class="n">upsampled_ngff</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">omero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">omero</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.get_bounded_subregion" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">get_bounded_subregion</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Extracts a bounded subregion of the dask array containing the specified points,
along with the grid points for interpolation.</p>
<p>If the points extend beyond the domain of the dask array, the extent is capped
at the boundaries. If all points are outside the domain, the function returns
<code>(None, None)</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>points</code></b>
              (<code><span title="numpy.ndarray">ndarray</span></code>)
          
          <div class="doc-md-description">
            <p>Nx3 or Nx4 array of coordinates in the array's space.
                 If Nx4, the last column is assumed to be the homogeneous
                 coordinate and is ignored.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>tuple</code></b>          
          <div class="doc-md-description">
            <p>grid_points (tuple): A tuple of three 1D arrays representing the grid
                     points along each axis (X, Y, Z) in the subregion.
subvol (np.ndarray or None): The extracted subregion as a NumPy array.
                             Returns <code>None</code> if all points are outside
                             the array domain.</p>
          </div>
        </li>
    </ul>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>The function uses <code>compute()</code> on the dask array to immediately load the
  subregion, as Dask doesn't support the type of indexing required for
  interpolation.</li>
<li>A padding of 1 voxel is applied around the extent of the points.</li>
</ul>
</details>

<details class="example" open>
  <summary>Example</summary>
  <p>grid_points, subvol = znimg.get_bounded_subregion(points)
if subvol is not None:
    print("Subvolume shape:", subvol.shape)</p>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2960</span>
<span class="normal">2961</span>
<span class="normal">2962</span>
<span class="normal">2963</span>
<span class="normal">2964</span>
<span class="normal">2965</span>
<span class="normal">2966</span>
<span class="normal">2967</span>
<span class="normal">2968</span>
<span class="normal">2969</span>
<span class="normal">2970</span>
<span class="normal">2971</span>
<span class="normal">2972</span>
<span class="normal">2973</span>
<span class="normal">2974</span>
<span class="normal">2975</span>
<span class="normal">2976</span>
<span class="normal">2977</span>
<span class="normal">2978</span>
<span class="normal">2979</span>
<span class="normal">2980</span>
<span class="normal">2981</span>
<span class="normal">2982</span>
<span class="normal">2983</span>
<span class="normal">2984</span>
<span class="normal">2985</span>
<span class="normal">2986</span>
<span class="normal">2987</span>
<span class="normal">2988</span>
<span class="normal">2989</span>
<span class="normal">2990</span>
<span class="normal">2991</span>
<span class="normal">2992</span>
<span class="normal">2993</span>
<span class="normal">2994</span>
<span class="normal">2995</span>
<span class="normal">2996</span>
<span class="normal">2997</span>
<span class="normal">2998</span>
<span class="normal">2999</span>
<span class="normal">3000</span>
<span class="normal">3001</span>
<span class="normal">3002</span>
<span class="normal">3003</span>
<span class="normal">3004</span>
<span class="normal">3005</span>
<span class="normal">3006</span>
<span class="normal">3007</span>
<span class="normal">3008</span>
<span class="normal">3009</span>
<span class="normal">3010</span>
<span class="normal">3011</span>
<span class="normal">3012</span>
<span class="normal">3013</span>
<span class="normal">3014</span>
<span class="normal">3015</span>
<span class="normal">3016</span>
<span class="normal">3017</span>
<span class="normal">3018</span>
<span class="normal">3019</span>
<span class="normal">3020</span>
<span class="normal">3021</span>
<span class="normal">3022</span>
<span class="normal">3023</span>
<span class="normal">3024</span>
<span class="normal">3025</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_bounded_subregion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts a bounded subregion of the dask array containing the specified points,</span>
<span class="sd">    along with the grid points for interpolation.</span>

<span class="sd">    If the points extend beyond the domain of the dask array, the extent is capped</span>
<span class="sd">    at the boundaries. If all points are outside the domain, the function returns</span>
<span class="sd">    `(None, None)`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        points (np.ndarray): Nx3 or Nx4 array of coordinates in the array&#39;s space.</span>
<span class="sd">                             If Nx4, the last column is assumed to be the homogeneous</span>
<span class="sd">                             coordinate and is ignored.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            grid_points (tuple): A tuple of three 1D arrays representing the grid</span>
<span class="sd">                                 points along each axis (X, Y, Z) in the subregion.</span>
<span class="sd">            subvol (np.ndarray or None): The extracted subregion as a NumPy array.</span>
<span class="sd">                                         Returns `None` if all points are outside</span>
<span class="sd">                                         the array domain.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - The function uses `compute()` on the dask array to immediately load the</span>
<span class="sd">          subregion, as Dask doesn&#39;t support the type of indexing required for</span>
<span class="sd">          interpolation.</span>
<span class="sd">        - A padding of 1 voxel is applied around the extent of the points.</span>

<span class="sd">    Example:</span>
<span class="sd">        grid_points, subvol = znimg.get_bounded_subregion(points)</span>
<span class="sd">        if subvol is not None:</span>
<span class="sd">            print(&quot;Subvolume shape:&quot;, subvol.shape)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pad</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Padding around the extent of the points</span>

    <span class="c1"># Compute the extent of the points in the array&#39;s coordinate space</span>
    <span class="n">min_extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="n">max_extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">pad</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>

    <span class="c1"># Clip the extents to ensure they stay within the bounds of the array</span>
    <span class="n">clip_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">min_extent</span><span class="p">)</span>
    <span class="n">clip_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">darr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span>  <span class="c1"># Z, Y, X dimensions</span>

    <span class="n">min_extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">min_extent</span><span class="p">,</span> <span class="n">clip_min</span><span class="p">,</span> <span class="n">clip_max</span><span class="p">)</span>
    <span class="n">max_extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">max_extent</span><span class="p">,</span> <span class="n">clip_min</span><span class="p">,</span> <span class="n">clip_max</span><span class="p">)</span>

    <span class="c1"># Check if all points are outside the domain</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">max_extent</span> <span class="o">&lt;=</span> <span class="n">min_extent</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1"># Extract the subvolume using the computed extents</span>
    <span class="n">subvol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">darr</span><span class="p">[</span>
        <span class="p">:,</span>
        <span class="n">min_extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">max_extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">min_extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="n">max_extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">min_extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">:</span> <span class="n">max_extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

    <span class="c1"># Generate grid points for interpolation</span>
    <span class="n">grid_points</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>  <span class="c1"># Z</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">max_extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>  <span class="c1"># Y</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">max_extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>  <span class="c1"># X</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">grid_points</span><span class="p">,</span> <span class="n">subvol</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.apply_transform" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">apply_transform</span><span class="p">(</span><span class="o">*</span><span class="n">transforms</span><span class="p">,</span> <span class="n">ref_znimg</span><span class="p">,</span> <span class="n">spatial_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Apply spatial transformations to image data.</p>
<p>Transforms the image data to align with a reference image space using
the provided transformation(s). This enables registration, resampling,
and coordinate system conversions.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>*transforms</code></b>
              (<code><span title="zarrnii.transform.Transform">Transform</span></code>, default:
                  <code>()</code>
)
          
          <div class="doc-md-description">
            <p>Variable number of Transform objects to apply sequentially.
Supported transform types:
- AffineTransform: Linear transformations (rotation, scaling, translation)
- DisplacementTransform: Non-linear deformation fields</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>ref_znimg</code></b>
              (<code>&#39;ZarrNii&#39;</code>)
          
          <div class="doc-md-description">
            <p>Reference ZarrNii image defining the target coordinate system,
grid spacing, and field of view for the output</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>spatial_dims</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="str">str</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Names of spatial dimensions for transformation. If None,
automatically derived from axes_order</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>New ZarrNii instance with transformed data in reference space</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If no transforms provided or reference image incompatible</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="TypeError">TypeError</span></code>
            
          <div class="doc-md-description">
            <p>If transforms are not valid Transform objects</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Apply affine transformation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">affine</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="o">.</span><span class="n">from_txt</span><span class="p">(</span><span class="s2">&quot;transform.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformed</span> <span class="o">=</span> <span class="n">moving</span><span class="o">.</span><span class="n">apply_transform</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="n">ref_znimg</span><span class="o">=</span><span class="n">reference</span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Apply multiple transforms sequentially</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">affine</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span> <span class="o">=</span> <span class="n">DisplacementTransform</span><span class="o">.</span><span class="n">from_nifti</span><span class="p">(</span><span class="s2">&quot;warp.nii.gz&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">moving</span><span class="o">.</span><span class="n">apply_transform</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="n">warp</span><span class="p">,</span> <span class="n">ref_znimg</span><span class="o">=</span><span class="n">reference</span><span class="p">)</span>
</code></pre></div>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Transformations are applied in the order specified</li>
<li>Output data inherits spatial properties from ref_znimg</li>
<li>Uses interpolation for non-integer coordinate mappings</li>
<li>Non-spatial dimensions (channels, time) are preserved</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">3027</span>
<span class="normal">3028</span>
<span class="normal">3029</span>
<span class="normal">3030</span>
<span class="normal">3031</span>
<span class="normal">3032</span>
<span class="normal">3033</span>
<span class="normal">3034</span>
<span class="normal">3035</span>
<span class="normal">3036</span>
<span class="normal">3037</span>
<span class="normal">3038</span>
<span class="normal">3039</span>
<span class="normal">3040</span>
<span class="normal">3041</span>
<span class="normal">3042</span>
<span class="normal">3043</span>
<span class="normal">3044</span>
<span class="normal">3045</span>
<span class="normal">3046</span>
<span class="normal">3047</span>
<span class="normal">3048</span>
<span class="normal">3049</span>
<span class="normal">3050</span>
<span class="normal">3051</span>
<span class="normal">3052</span>
<span class="normal">3053</span>
<span class="normal">3054</span>
<span class="normal">3055</span>
<span class="normal">3056</span>
<span class="normal">3057</span>
<span class="normal">3058</span>
<span class="normal">3059</span>
<span class="normal">3060</span>
<span class="normal">3061</span>
<span class="normal">3062</span>
<span class="normal">3063</span>
<span class="normal">3064</span>
<span class="normal">3065</span>
<span class="normal">3066</span>
<span class="normal">3067</span>
<span class="normal">3068</span>
<span class="normal">3069</span>
<span class="normal">3070</span>
<span class="normal">3071</span>
<span class="normal">3072</span>
<span class="normal">3073</span>
<span class="normal">3074</span>
<span class="normal">3075</span>
<span class="normal">3076</span>
<span class="normal">3077</span>
<span class="normal">3078</span>
<span class="normal">3079</span>
<span class="normal">3080</span>
<span class="normal">3081</span>
<span class="normal">3082</span>
<span class="normal">3083</span>
<span class="normal">3084</span>
<span class="normal">3085</span>
<span class="normal">3086</span>
<span class="normal">3087</span>
<span class="normal">3088</span>
<span class="normal">3089</span>
<span class="normal">3090</span>
<span class="normal">3091</span>
<span class="normal">3092</span>
<span class="normal">3093</span>
<span class="normal">3094</span>
<span class="normal">3095</span>
<span class="normal">3096</span>
<span class="normal">3097</span>
<span class="normal">3098</span>
<span class="normal">3099</span>
<span class="normal">3100</span>
<span class="normal">3101</span>
<span class="normal">3102</span>
<span class="normal">3103</span>
<span class="normal">3104</span>
<span class="normal">3105</span>
<span class="normal">3106</span>
<span class="normal">3107</span>
<span class="normal">3108</span>
<span class="normal">3109</span>
<span class="normal">3110</span>
<span class="normal">3111</span>
<span class="normal">3112</span>
<span class="normal">3113</span>
<span class="normal">3114</span>
<span class="normal">3115</span>
<span class="normal">3116</span>
<span class="normal">3117</span>
<span class="normal">3118</span>
<span class="normal">3119</span>
<span class="normal">3120</span>
<span class="normal">3121</span>
<span class="normal">3122</span>
<span class="normal">3123</span>
<span class="normal">3124</span>
<span class="normal">3125</span>
<span class="normal">3126</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apply_transform</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">transforms</span><span class="p">:</span> <span class="n">Transform</span><span class="p">,</span>
    <span class="n">ref_znimg</span><span class="p">:</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">,</span>
    <span class="n">spatial_dims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply spatial transformations to image data.</span>

<span class="sd">    Transforms the image data to align with a reference image space using</span>
<span class="sd">    the provided transformation(s). This enables registration, resampling,</span>
<span class="sd">    and coordinate system conversions.</span>

<span class="sd">    Args:</span>
<span class="sd">        *transforms: Variable number of Transform objects to apply sequentially.</span>
<span class="sd">            Supported transform types:</span>
<span class="sd">            - AffineTransform: Linear transformations (rotation, scaling, translation)</span>
<span class="sd">            - DisplacementTransform: Non-linear deformation fields</span>
<span class="sd">        ref_znimg: Reference ZarrNii image defining the target coordinate system,</span>
<span class="sd">            grid spacing, and field of view for the output</span>
<span class="sd">        spatial_dims: Names of spatial dimensions for transformation. If None,</span>
<span class="sd">            automatically derived from axes_order</span>

<span class="sd">    Returns:</span>
<span class="sd">        New ZarrNii instance with transformed data in reference space</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If no transforms provided or reference image incompatible</span>
<span class="sd">        TypeError: If transforms are not valid Transform objects</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Apply affine transformation</span>
<span class="sd">        &gt;&gt;&gt; affine = AffineTransform.from_txt(&quot;transform.txt&quot;)</span>
<span class="sd">        &gt;&gt;&gt; transformed = moving.apply_transform(affine, ref_znimg=reference)</span>

<span class="sd">        &gt;&gt;&gt; # Apply multiple transforms sequentially</span>
<span class="sd">        &gt;&gt;&gt; affine = AffineTransform.identity()</span>
<span class="sd">        &gt;&gt;&gt; warp = DisplacementTransform.from_nifti(&quot;warp.nii.gz&quot;)</span>
<span class="sd">        &gt;&gt;&gt; result = moving.apply_transform(affine, warp, ref_znimg=reference)</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Transformations are applied in the order specified</span>
<span class="sd">        - Output data inherits spatial properties from ref_znimg</span>
<span class="sd">        - Uses interpolation for non-integer coordinate mappings</span>
<span class="sd">        - Non-spatial dimensions (channels, time) are preserved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">spatial_dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spatial_dims</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="c1"># Initialize the list of transformations to apply</span>
    <span class="n">tfms_to_apply</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref_znimg</span><span class="o">.</span><span class="n">affine</span><span class="p">]</span>  <span class="c1"># Start with the reference image affine</span>

    <span class="c1"># Append all transformations passed as arguments</span>
    <span class="n">tfms_to_apply</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span>

    <span class="c1"># Append the inverse of the current image&#39;s affine</span>
    <span class="n">tfms_to_apply</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="o">.</span><span class="n">invert</span><span class="p">())</span>

    <span class="c1"># Create new NgffImage from ref image</span>
    <span class="n">interp_ngff_image</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">ref_znimg</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="n">ref_znimg</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">ref_znimg</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">translation</span><span class="o">=</span><span class="n">ref_znimg</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_transformed_to_</span><span class="si">{</span><span class="n">ref_znimg</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Try to get zarr store information for direct access (avoids nested compute)</span>
    <span class="n">store_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_zarr_store_info</span><span class="p">()</span>

    <span class="c1"># Lazily apply the transformations using dask</span>
    <span class="k">if</span> <span class="n">store_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Use direct zarr access to avoid nested compute() calls</span>
        <span class="n">interp_ngff_image</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span>
            <span class="n">interp_by_block</span><span class="p">,</span>  <span class="c1"># Function to interpolate each block</span>
            <span class="n">ref_znimg</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>  <span class="c1"># Reference image data</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>  <span class="c1"># Output data type</span>
            <span class="n">transforms</span><span class="o">=</span><span class="n">tfms_to_apply</span><span class="p">,</span>  <span class="c1"># Transformations to apply</span>
            <span class="n">flo_store_path</span><span class="o">=</span><span class="n">store_info</span><span class="p">[</span><span class="s2">&quot;store_path&quot;</span><span class="p">],</span>
            <span class="n">flo_array_shape</span><span class="o">=</span><span class="n">store_info</span><span class="p">[</span><span class="s2">&quot;array_shape&quot;</span><span class="p">],</span>
            <span class="n">flo_dataset_path</span><span class="o">=</span><span class="n">store_info</span><span class="p">[</span><span class="s2">&quot;dataset_path&quot;</span><span class="p">],</span>
            <span class="n">flo_storage_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO: Extract from dask array if available</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Fall back to passing ZarrNii instance (legacy behavior with nested compute)</span>
        <span class="n">interp_ngff_image</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span>
            <span class="n">interp_by_block</span><span class="p">,</span>  <span class="c1"># Function to interpolate each block</span>
            <span class="n">ref_znimg</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>  <span class="c1"># Reference image data</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>  <span class="c1"># Output data type</span>
            <span class="n">transforms</span><span class="o">=</span><span class="n">tfms_to_apply</span><span class="p">,</span>  <span class="c1"># Transformations to apply</span>
            <span class="n">flo_znimg</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>  <span class="c1"># Floating image to align (legacy)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_ngff_image</span><span class="p">(</span>
        <span class="n">interp_ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="n">ref_znimg</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="n">ref_znimg</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">omero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">omero</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.to_ome_zarr" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">to_ome_zarr</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="n">max_layer</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">scale_factors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;ome-zarr-py&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Save to OME-Zarr store with multiscale pyramid.</p>
<p>Creates an OME-Zarr dataset with automatic multiscale pyramid generation
for efficient visualization and processing at multiple resolutions.
Preserves spatial metadata and supports various storage backends.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>store_or_path</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]</code>)
          
          <div class="doc-md-description">
            <p>Target location for OME-Zarr store. Supports:
- Local directory path
- Remote URLs (s3://, gs://, etc.)
- ZIP files (.zip extension for compressed storage)
- Zarr store objects</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>max_layer</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>4</code>
)
          
          <div class="doc-md-description">
            <p>Maximum number of pyramid levels to create (including level 0).
Higher values create more downsampled levels</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>scale_factors</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="int">int</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Custom downsampling factors for each pyramid level.
If None, uses powers of 2: [2, 4, 8, 16, ...]</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>backend</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;ome-zarr-py&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Backend library to use for writing. Options:
- 'ngff-zarr': Use ngff-zarr library (default)
- 'ome-zarr-py': Use ome-zarr-py library for better dask integration</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>**kwargs</code></b>
              (<code><span title="typing.Any">Any</span></code>, default:
                  <code>{}</code>
)
          
          <div class="doc-md-description">
            <p>Additional arguments passed to the save function.
For 'ngff-zarr': passed to to_ngff_zarr function
For 'ome-zarr-py': passed to write_image (e.g., scaling_method, compute)</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>Self for method chaining</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="OSError">OSError</span></code>
            
          <div class="doc-md-description">
            <p>If unable to write to target location</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If invalid scale_factors or backend provided</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save with default pyramid levels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span><span class="o">.</span><span class="n">to_ome_zarr</span><span class="p">(</span><span class="s2">&quot;/path/to/output.zarr&quot;</span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save to compressed ZIP with custom pyramid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span><span class="o">.</span><span class="n">to_ome_zarr</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;/path/to/output.zarr.zip&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">max_layer</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">scale_factors</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use ome-zarr-py backend for better dask performance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span><span class="o">.</span><span class="n">to_ome_zarr</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;/path/to/output.zarr&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">backend</span><span class="o">=</span><span class="s2">&quot;ome-zarr-py&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">scaling_method</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Chain with other operations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">znii</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>              <span class="o">.</span><span class="n">crop</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="gp">... </span>              <span class="o">.</span><span class="n">to_ome_zarr</span><span class="p">(</span><span class="s2">&quot;processed.zarr&quot;</span><span class="p">))</span>
</code></pre></div>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>OME-Zarr files are always saved in ZYX axis order</li>
<li>Automatic axis reordering if current order is XYZ</li>
<li>Spatial transformations and metadata are preserved</li>
<li>Orientation information is stored using the new 'xyz_orientation'
  metadata key for consistency and future compatibility</li>
<li>The 'ome-zarr-py' backend provides better performance with dask
  and dask distributed workflows</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">3129</span>
<span class="normal">3130</span>
<span class="normal">3131</span>
<span class="normal">3132</span>
<span class="normal">3133</span>
<span class="normal">3134</span>
<span class="normal">3135</span>
<span class="normal">3136</span>
<span class="normal">3137</span>
<span class="normal">3138</span>
<span class="normal">3139</span>
<span class="normal">3140</span>
<span class="normal">3141</span>
<span class="normal">3142</span>
<span class="normal">3143</span>
<span class="normal">3144</span>
<span class="normal">3145</span>
<span class="normal">3146</span>
<span class="normal">3147</span>
<span class="normal">3148</span>
<span class="normal">3149</span>
<span class="normal">3150</span>
<span class="normal">3151</span>
<span class="normal">3152</span>
<span class="normal">3153</span>
<span class="normal">3154</span>
<span class="normal">3155</span>
<span class="normal">3156</span>
<span class="normal">3157</span>
<span class="normal">3158</span>
<span class="normal">3159</span>
<span class="normal">3160</span>
<span class="normal">3161</span>
<span class="normal">3162</span>
<span class="normal">3163</span>
<span class="normal">3164</span>
<span class="normal">3165</span>
<span class="normal">3166</span>
<span class="normal">3167</span>
<span class="normal">3168</span>
<span class="normal">3169</span>
<span class="normal">3170</span>
<span class="normal">3171</span>
<span class="normal">3172</span>
<span class="normal">3173</span>
<span class="normal">3174</span>
<span class="normal">3175</span>
<span class="normal">3176</span>
<span class="normal">3177</span>
<span class="normal">3178</span>
<span class="normal">3179</span>
<span class="normal">3180</span>
<span class="normal">3181</span>
<span class="normal">3182</span>
<span class="normal">3183</span>
<span class="normal">3184</span>
<span class="normal">3185</span>
<span class="normal">3186</span>
<span class="normal">3187</span>
<span class="normal">3188</span>
<span class="normal">3189</span>
<span class="normal">3190</span>
<span class="normal">3191</span>
<span class="normal">3192</span>
<span class="normal">3193</span>
<span class="normal">3194</span>
<span class="normal">3195</span>
<span class="normal">3196</span>
<span class="normal">3197</span>
<span class="normal">3198</span>
<span class="normal">3199</span>
<span class="normal">3200</span>
<span class="normal">3201</span>
<span class="normal">3202</span>
<span class="normal">3203</span>
<span class="normal">3204</span>
<span class="normal">3205</span>
<span class="normal">3206</span>
<span class="normal">3207</span>
<span class="normal">3208</span>
<span class="normal">3209</span>
<span class="normal">3210</span>
<span class="normal">3211</span>
<span class="normal">3212</span>
<span class="normal">3213</span>
<span class="normal">3214</span>
<span class="normal">3215</span>
<span class="normal">3216</span>
<span class="normal">3217</span>
<span class="normal">3218</span>
<span class="normal">3219</span>
<span class="normal">3220</span>
<span class="normal">3221</span>
<span class="normal">3222</span>
<span class="normal">3223</span>
<span class="normal">3224</span>
<span class="normal">3225</span>
<span class="normal">3226</span>
<span class="normal">3227</span>
<span class="normal">3228</span>
<span class="normal">3229</span>
<span class="normal">3230</span>
<span class="normal">3231</span>
<span class="normal">3232</span>
<span class="normal">3233</span>
<span class="normal">3234</span>
<span class="normal">3235</span>
<span class="normal">3236</span>
<span class="normal">3237</span>
<span class="normal">3238</span>
<span class="normal">3239</span>
<span class="normal">3240</span>
<span class="normal">3241</span>
<span class="normal">3242</span>
<span class="normal">3243</span>
<span class="normal">3244</span>
<span class="normal">3245</span>
<span class="normal">3246</span>
<span class="normal">3247</span>
<span class="normal">3248</span>
<span class="normal">3249</span>
<span class="normal">3250</span>
<span class="normal">3251</span>
<span class="normal">3252</span>
<span class="normal">3253</span>
<span class="normal">3254</span>
<span class="normal">3255</span>
<span class="normal">3256</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">to_ome_zarr</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">store_or_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">max_layer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">scale_factors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ome-zarr-py&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Save to OME-Zarr store with multiscale pyramid.</span>

<span class="sd">    Creates an OME-Zarr dataset with automatic multiscale pyramid generation</span>
<span class="sd">    for efficient visualization and processing at multiple resolutions.</span>
<span class="sd">    Preserves spatial metadata and supports various storage backends.</span>

<span class="sd">    Args:</span>
<span class="sd">        store_or_path: Target location for OME-Zarr store. Supports:</span>
<span class="sd">            - Local directory path</span>
<span class="sd">            - Remote URLs (s3://, gs://, etc.)</span>
<span class="sd">            - ZIP files (.zip extension for compressed storage)</span>
<span class="sd">            - Zarr store objects</span>
<span class="sd">        max_layer: Maximum number of pyramid levels to create (including level 0).</span>
<span class="sd">            Higher values create more downsampled levels</span>
<span class="sd">        scale_factors: Custom downsampling factors for each pyramid level.</span>
<span class="sd">            If None, uses powers of 2: [2, 4, 8, 16, ...]</span>
<span class="sd">        backend: Backend library to use for writing. Options:</span>
<span class="sd">            - &#39;ngff-zarr&#39;: Use ngff-zarr library (default)</span>
<span class="sd">            - &#39;ome-zarr-py&#39;: Use ome-zarr-py library for better dask integration</span>
<span class="sd">        **kwargs: Additional arguments passed to the save function.</span>
<span class="sd">            For &#39;ngff-zarr&#39;: passed to to_ngff_zarr function</span>
<span class="sd">            For &#39;ome-zarr-py&#39;: passed to write_image (e.g., scaling_method, compute)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Self for method chaining</span>

<span class="sd">    Raises:</span>
<span class="sd">        OSError: If unable to write to target location</span>
<span class="sd">        ValueError: If invalid scale_factors or backend provided</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Save with default pyramid levels</span>
<span class="sd">        &gt;&gt;&gt; znii.to_ome_zarr(&quot;/path/to/output.zarr&quot;)</span>

<span class="sd">        &gt;&gt;&gt; # Save to compressed ZIP with custom pyramid</span>
<span class="sd">        &gt;&gt;&gt; znii.to_ome_zarr(</span>
<span class="sd">        ...     &quot;/path/to/output.zarr.zip&quot;,</span>
<span class="sd">        ...     max_layer=3,</span>
<span class="sd">        ...     scale_factors=[2, 4]</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; # Use ome-zarr-py backend for better dask performance</span>
<span class="sd">        &gt;&gt;&gt; znii.to_ome_zarr(</span>
<span class="sd">        ...     &quot;/path/to/output.zarr&quot;,</span>
<span class="sd">        ...     backend=&quot;ome-zarr-py&quot;,</span>
<span class="sd">        ...     scaling_method=&quot;gaussian&quot;</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; # Chain with other operations</span>
<span class="sd">        &gt;&gt;&gt; result = (znii.downsample(2)</span>
<span class="sd">        ...               .crop((0,0,0), (100,100,100))</span>
<span class="sd">        ...               .to_ome_zarr(&quot;processed.zarr&quot;))</span>

<span class="sd">    Notes:</span>
<span class="sd">        - OME-Zarr files are always saved in ZYX axis order</span>
<span class="sd">        - Automatic axis reordering if current order is XYZ</span>
<span class="sd">        - Spatial transformations and metadata are preserved</span>
<span class="sd">        - Orientation information is stored using the new &#39;xyz_orientation&#39;</span>
<span class="sd">          metadata key for consistency and future compatibility</span>
<span class="sd">        - The &#39;ome-zarr-py&#39; backend provides better performance with dask</span>
<span class="sd">          and dask distributed workflows</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate backend parameter</span>
    <span class="k">if</span> <span class="n">backend</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ngff-zarr&quot;</span><span class="p">,</span> <span class="s2">&quot;ome-zarr-py&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Invalid backend &#39;</span><span class="si">{</span><span class="n">backend</span><span class="si">}</span><span class="s2">&#39;. Must be &#39;ngff-zarr&#39; or &#39;ome-zarr-py&#39;&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Determine the image to save</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;XYZ&quot;</span><span class="p">:</span>
        <span class="c1"># Need to reorder data from XYZ to ZYX for OME-Zarr</span>
        <span class="n">ngff_image_to_save</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_zyx_ngff_image</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Already in ZYX order</span>
        <span class="n">ngff_image_to_save</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span>

    <span class="c1"># Use the appropriate save function based on backend</span>
    <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;ngff-zarr&quot;</span><span class="p">:</span>
        <span class="n">save_ngff_image</span><span class="p">(</span>
            <span class="n">ngff_image_to_save</span><span class="p">,</span>
            <span class="n">store_or_path</span><span class="p">,</span>
            <span class="n">max_layer</span><span class="p">,</span>
            <span class="n">scale_factors</span><span class="p">,</span>
            <span class="n">xyz_orientation</span><span class="o">=</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;xyz_orientation&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="p">),</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;ome-zarr-py&quot;</span><span class="p">:</span>
        <span class="n">save_ngff_image_with_ome_zarr</span><span class="p">(</span>
            <span class="n">ngff_image_to_save</span><span class="p">,</span>
            <span class="n">store_or_path</span><span class="p">,</span>
            <span class="n">max_layer</span><span class="p">,</span>
            <span class="n">scale_factors</span><span class="p">,</span>
            <span class="n">omero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_omero</span><span class="p">,</span>
            <span class="n">xyz_orientation</span><span class="o">=</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;xyz_orientation&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="p">),</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Add orientation metadata to the zarr store (only for non-ZIP files)</span>
    <span class="c1"># For ZIP files, orientation is handled inside save_ngff_image</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">store_or_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.zip&quot;</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">zarr</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="n">store_or_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r+&quot;</span><span class="p">)</span>

            <span class="c1"># Add metadata for xyz_orientation (new format)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;xyz_orientation&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">:</span>
                <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;xyz_orientation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># If we can&#39;t write orientation metadata, that&#39;s not critical</span>
            <span class="k">pass</span>

    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.to_nifti" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">to_nifti</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Convert to NIfTI format with automatic dimension handling.</p>
<p>Converts the ZarrNii image to NIfTI-1 format, handling dimension
reordering, singleton dimension removal, and spatial transformation
conversion. NIfTI files are always written in XYZ axis order.</p>
<p>For multi-channel data, the 4th dimension is used for channels (XYZC),
and channel labels are preserved in NIfTI header extensions.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>filename</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="bytes">bytes</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Output file path for saving. Supported extensions:
- .nii: Uncompressed NIfTI
- .nii.gz: Compressed NIfTI (recommended)
If None, returns nibabel image object without saving</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="typing.Union">Union</span>[<span title="nibabel.Nifti1Image">Nifti1Image</span>, <span title="str">str</span>]</code>
          
          <div class="doc-md-description">
            <p>If filename is None: nibabel.Nifti1Image object</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.Union">Union</span>[<span title="nibabel.Nifti1Image">Nifti1Image</span>, <span title="str">str</span>]</code>
          
          <div class="doc-md-description">
            <p>If filename provided: path to saved file</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If data has non-singleton time dimension (time is not
supported in NIfTI output, but multiple channels are supported)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="OSError">OSError</span></code>
            
          <div class="doc-md-description">
            <p>If unable to write to specified filename</p>
          </div>
        </li>
    </ul>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Automatically reorders data from ZYX to XYZ if necessary</li>
<li>Removes singleton time dimensions automatically</li>
<li>Supports multi-channel data via 4th dimension (XYZC ordering)</li>
<li>Channel labels are saved in NIfTI header extensions as JSON</li>
<li>Spatial transformations are converted to NIfTI affine format</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save to compressed NIfTI file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span><span class="o">.</span><span class="n">to_nifti</span><span class="p">(</span><span class="s2">&quot;output.nii.gz&quot;</span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get nibabel object without saving</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nifti_img</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">to_nifti</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nifti_img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save multi-channel data with channel labels preserved</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span><span class="o">.</span><span class="n">to_nifti</span><span class="p">(</span><span class="s2">&quot;multichannel.nii.gz&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Channel labels are automatically saved in header extensions</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Select specific channels before saving</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span><span class="o">.</span><span class="n">select_channels</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">to_nifti</span><span class="p">(</span><span class="s2">&quot;selected.nii.gz&quot;</span><span class="p">)</span>
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">3258</span>
<span class="normal">3259</span>
<span class="normal">3260</span>
<span class="normal">3261</span>
<span class="normal">3262</span>
<span class="normal">3263</span>
<span class="normal">3264</span>
<span class="normal">3265</span>
<span class="normal">3266</span>
<span class="normal">3267</span>
<span class="normal">3268</span>
<span class="normal">3269</span>
<span class="normal">3270</span>
<span class="normal">3271</span>
<span class="normal">3272</span>
<span class="normal">3273</span>
<span class="normal">3274</span>
<span class="normal">3275</span>
<span class="normal">3276</span>
<span class="normal">3277</span>
<span class="normal">3278</span>
<span class="normal">3279</span>
<span class="normal">3280</span>
<span class="normal">3281</span>
<span class="normal">3282</span>
<span class="normal">3283</span>
<span class="normal">3284</span>
<span class="normal">3285</span>
<span class="normal">3286</span>
<span class="normal">3287</span>
<span class="normal">3288</span>
<span class="normal">3289</span>
<span class="normal">3290</span>
<span class="normal">3291</span>
<span class="normal">3292</span>
<span class="normal">3293</span>
<span class="normal">3294</span>
<span class="normal">3295</span>
<span class="normal">3296</span>
<span class="normal">3297</span>
<span class="normal">3298</span>
<span class="normal">3299</span>
<span class="normal">3300</span>
<span class="normal">3301</span>
<span class="normal">3302</span>
<span class="normal">3303</span>
<span class="normal">3304</span>
<span class="normal">3305</span>
<span class="normal">3306</span>
<span class="normal">3307</span>
<span class="normal">3308</span>
<span class="normal">3309</span>
<span class="normal">3310</span>
<span class="normal">3311</span>
<span class="normal">3312</span>
<span class="normal">3313</span>
<span class="normal">3314</span>
<span class="normal">3315</span>
<span class="normal">3316</span>
<span class="normal">3317</span>
<span class="normal">3318</span>
<span class="normal">3319</span>
<span class="normal">3320</span>
<span class="normal">3321</span>
<span class="normal">3322</span>
<span class="normal">3323</span>
<span class="normal">3324</span>
<span class="normal">3325</span>
<span class="normal">3326</span>
<span class="normal">3327</span>
<span class="normal">3328</span>
<span class="normal">3329</span>
<span class="normal">3330</span>
<span class="normal">3331</span>
<span class="normal">3332</span>
<span class="normal">3333</span>
<span class="normal">3334</span>
<span class="normal">3335</span>
<span class="normal">3336</span>
<span class="normal">3337</span>
<span class="normal">3338</span>
<span class="normal">3339</span>
<span class="normal">3340</span>
<span class="normal">3341</span>
<span class="normal">3342</span>
<span class="normal">3343</span>
<span class="normal">3344</span>
<span class="normal">3345</span>
<span class="normal">3346</span>
<span class="normal">3347</span>
<span class="normal">3348</span>
<span class="normal">3349</span>
<span class="normal">3350</span>
<span class="normal">3351</span>
<span class="normal">3352</span>
<span class="normal">3353</span>
<span class="normal">3354</span>
<span class="normal">3355</span>
<span class="normal">3356</span>
<span class="normal">3357</span>
<span class="normal">3358</span>
<span class="normal">3359</span>
<span class="normal">3360</span>
<span class="normal">3361</span>
<span class="normal">3362</span>
<span class="normal">3363</span>
<span class="normal">3364</span>
<span class="normal">3365</span>
<span class="normal">3366</span>
<span class="normal">3367</span>
<span class="normal">3368</span>
<span class="normal">3369</span>
<span class="normal">3370</span>
<span class="normal">3371</span>
<span class="normal">3372</span>
<span class="normal">3373</span>
<span class="normal">3374</span>
<span class="normal">3375</span>
<span class="normal">3376</span>
<span class="normal">3377</span>
<span class="normal">3378</span>
<span class="normal">3379</span>
<span class="normal">3380</span>
<span class="normal">3381</span>
<span class="normal">3382</span>
<span class="normal">3383</span>
<span class="normal">3384</span>
<span class="normal">3385</span>
<span class="normal">3386</span>
<span class="normal">3387</span>
<span class="normal">3388</span>
<span class="normal">3389</span>
<span class="normal">3390</span>
<span class="normal">3391</span>
<span class="normal">3392</span>
<span class="normal">3393</span>
<span class="normal">3394</span>
<span class="normal">3395</span>
<span class="normal">3396</span>
<span class="normal">3397</span>
<span class="normal">3398</span>
<span class="normal">3399</span>
<span class="normal">3400</span>
<span class="normal">3401</span>
<span class="normal">3402</span>
<span class="normal">3403</span>
<span class="normal">3404</span>
<span class="normal">3405</span>
<span class="normal">3406</span>
<span class="normal">3407</span>
<span class="normal">3408</span>
<span class="normal">3409</span>
<span class="normal">3410</span>
<span class="normal">3411</span>
<span class="normal">3412</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">to_nifti</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">nib</span><span class="o">.</span><span class="n">Nifti1Image</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert to NIfTI format with automatic dimension handling.</span>

<span class="sd">    Converts the ZarrNii image to NIfTI-1 format, handling dimension</span>
<span class="sd">    reordering, singleton dimension removal, and spatial transformation</span>
<span class="sd">    conversion. NIfTI files are always written in XYZ axis order.</span>

<span class="sd">    For multi-channel data, the 4th dimension is used for channels (XYZC),</span>
<span class="sd">    and channel labels are preserved in NIfTI header extensions.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename: Output file path for saving. Supported extensions:</span>
<span class="sd">            - .nii: Uncompressed NIfTI</span>
<span class="sd">            - .nii.gz: Compressed NIfTI (recommended)</span>
<span class="sd">            If None, returns nibabel image object without saving</span>

<span class="sd">    Returns:</span>
<span class="sd">        If filename is None: nibabel.Nifti1Image object</span>
<span class="sd">        If filename provided: path to saved file</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If data has non-singleton time dimension (time is not</span>
<span class="sd">            supported in NIfTI output, but multiple channels are supported)</span>
<span class="sd">        OSError: If unable to write to specified filename</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Automatically reorders data from ZYX to XYZ if necessary</span>
<span class="sd">        - Removes singleton time dimensions automatically</span>
<span class="sd">        - Supports multi-channel data via 4th dimension (XYZC ordering)</span>
<span class="sd">        - Channel labels are saved in NIfTI header extensions as JSON</span>
<span class="sd">        - Spatial transformations are converted to NIfTI affine format</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Save to compressed NIfTI file</span>
<span class="sd">        &gt;&gt;&gt; znii.to_nifti(&quot;output.nii.gz&quot;)</span>

<span class="sd">        &gt;&gt;&gt; # Get nibabel object without saving</span>
<span class="sd">        &gt;&gt;&gt; nifti_img = znii.to_nifti()</span>
<span class="sd">        &gt;&gt;&gt; print(nifti_img.shape)</span>

<span class="sd">        &gt;&gt;&gt; # Save multi-channel data with channel labels preserved</span>
<span class="sd">        &gt;&gt;&gt; znii.to_nifti(&quot;multichannel.nii.gz&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # Channel labels are automatically saved in header extensions</span>

<span class="sd">        &gt;&gt;&gt; # Select specific channels before saving</span>
<span class="sd">        &gt;&gt;&gt; znii.select_channels([0, 2]).to_nifti(&quot;selected.nii.gz&quot;)</span>

<span class="sd">    Warnings:</span>
<span class="sd">        Large images will be computed in memory during conversion.</span>
<span class="sd">        Consider downsampling or cropping first for very large datasets.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get data and dimensions</span>
    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

    <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>

    <span class="c1"># Handle dimensional reduction for NIfTI compatibility</span>
    <span class="c1"># NIfTI supports up to 4D, and we use 4th dimension for channels (XYZC)</span>
    <span class="n">squeeze_axes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_dims</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Remove singleton time dimension</span>
            <span class="n">squeeze_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Non-singleton time dimension - not supported</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;NIfTI format doesn&#39;t support non-singleton time dimension. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Dimension &#39;t&#39; has size </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Consider selecting a specific timepoint first.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Singleton channel - can be squeezed</span>
            <span class="n">squeeze_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># Don&#39;t add to new_dims</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Keep this dimension (spatial or multi-channel)</span>
            <span class="n">new_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

    <span class="c1"># Squeeze out singleton dimensions</span>
    <span class="k">if</span> <span class="n">squeeze_axes</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">squeeze_axes</span><span class="p">))</span>

    <span class="c1"># Check final dimensionality</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Resulting data has </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions, but NIfTI supports maximum 4D&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Now handle spatial reordering based on axes_order</span>
    <span class="c1"># We need to reorder to XYZC for NIfTI (or XYZ for 3D)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span><span class="p">:</span>
        <span class="c1"># Data spatial dimensions are in ZYX order, need to transpose to XYZ</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Pure spatial data: ZYX -&gt; XYZ</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># Check what the dimension order is</span>
            <span class="k">if</span> <span class="n">new_dims</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">]:</span>
                <span class="c1"># CZYX -&gt; XYZC</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">new_dims</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]:</span>
                <span class="c1"># ZYXC -&gt; XYZC</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Fallback: assume CZYX</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Get affine matrix in XYZ order</span>
        <span class="n">affine_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine_matrix</span><span class="p">(</span><span class="n">axes_order</span><span class="o">=</span><span class="s2">&quot;XYZ&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Data is in XYZ order</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Pure spatial data: XYZ (no change needed)</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># Check what the dimension order is</span>
            <span class="k">if</span> <span class="n">new_dims</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]:</span>
                <span class="c1"># CXYZ -&gt; XYZC</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">new_dims</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]:</span>
                <span class="c1"># XYZC -&gt; XYZC (already correct!)</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Fallback: assume CXYZ</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">affine_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine_matrix</span><span class="p">(</span><span class="n">axes_order</span><span class="o">=</span><span class="s2">&quot;XYZ&quot;</span><span class="p">)</span>

    <span class="c1"># Create NIfTI image</span>
    <span class="n">nifti_img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">Nifti1Image</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">affine_matrix</span><span class="p">)</span>

    <span class="c1"># Add channel labels to NIfTI header extensions if available</span>
    <span class="n">channel_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_channels</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">channel_labels</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># Only add channel labels if we have multi-channel 4D data</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

        <span class="n">channel_metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;channel_labels&quot;</span><span class="p">:</span> <span class="n">channel_labels</span><span class="p">}</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">Nifti1Extension</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">channel_metadata</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span>
                <span class="s2">&quot;utf-8&quot;</span>
            <span class="p">),</span>  <span class="c1"># code 1 is reserved/unspecified in NIfTI standard, suitable for custom metadata</span>
        <span class="p">)</span>
        <span class="n">nifti_img</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">extensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nib</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">nifti_img</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filename</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nifti_img</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.to_tiff_stack" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">to_tiff_stack</span><span class="p">(</span><span class="n">filename_pattern</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timepoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Save data as a stack of 2D TIFF images.</p>
<p>Saves the image data as a series of 2D TIFF files, with each Z-slice
saved as a separate file. This format is useful for compatibility with
tools that don't support OME-Zarr or napari plugins that require
individual TIFF files.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>filename_pattern</code></b>
              (<code><span title="str">str</span></code>)
          
          <div class="doc-md-description">
            <p>Output filename pattern. Should contain '{z:04d}' or similar
format specifier for the Z-slice number. Examples:
- "output_z{z:04d}.tif"
- "data/slice_{z:03d}.tiff"
If pattern doesn't contain format specifier, '_{z:04d}' is appended
before the extension.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>channel</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="int">int</span>]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Channel index to save (0-based). If None and data has multiple
channels, all channels will be saved as separate channel dimensions
in each TIFF file (multi-channel TIFFs).</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>timepoint</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="int">int</span>]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Timepoint index to save (0-based). If None and data has multiple
timepoints, raises ValueError (must select single timepoint).</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>compress</code></b>
              (<code><span title="bool">bool</span></code>, default:
                  <code>True</code>
)
          
          <div class="doc-md-description">
            <p>Whether to use LZW compression (default: True)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>dtype</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>, default:
                  <code>&#39;uint16&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Output data type for TIFF files. Options:
- 'uint8': 8-bit unsigned integer (0-255)
- 'uint16': 16-bit unsigned integer (0-65535) [default]
- 'int16': 16-bit signed integer (-32768 to 32767)
- 'float32': 32-bit float (preserves original data)
Default 'uint16' provides good range and compatibility.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>rescale</code></b>
              (<code><span title="bool">bool</span></code>, default:
                  <code>True</code>
)
          
          <div class="doc-md-description">
            <p>Whether to rescale data to fit the output dtype range.
If True, data is linearly scaled from [min, max] to the full
range of the output dtype. If False, data is clipped to the
output dtype range. Default: True</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="str">str</span></code>
          
          <div class="doc-md-description">
            <p>Base directory path where files were saved</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If data has multiple timepoints but none selected,
or if selected channel/timepoint is out of range,
or if dtype is not supported</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="OSError">OSError</span></code>
            
          <div class="doc-md-description">
            <p>If unable to write to specified directory</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save as 16-bit with auto-rescaling (default, recommended)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span><span class="o">.</span><span class="n">to_tiff_stack</span><span class="p">(</span><span class="s2">&quot;output_z</span><span class="si">{z:04d}</span><span class="s2">.tif&quot;</span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save as 8-bit for smaller file sizes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span><span class="o">.</span><span class="n">to_tiff_stack</span><span class="p">(</span><span class="s2">&quot;output_z</span><span class="si">{z:04d}</span><span class="s2">.tif&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save specific channel without rescaling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span><span class="o">.</span><span class="n">to_tiff_stack</span><span class="p">(</span><span class="s2">&quot;channel0_z</span><span class="si">{z:04d}</span><span class="s2">.tif&quot;</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save as float32 to preserve original precision</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">znii</span><span class="o">.</span><span class="n">to_tiff_stack</span><span class="p">(</span><span class="s2">&quot;precise_z</span><span class="si">{z:04d}</span><span class="s2">.tif&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
</code></pre></div>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Z-dimension becomes the stack (file) dimension</li>
<li>Time and channel dimensions are handled as specified</li>
<li>Spatial transformations are not preserved in TIFF format</li>
<li>For 5D data (T,C,Z,Y,X), you must select a single timepoint</li>
<li>Multi-channel data can be saved as multi-channel TIFFs or selected</li>
<li>Data type conversion helps ensure compatibility with analysis tools</li>
<li>uint16 is recommended for most scientific applications (good range + compatibility)</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">3414</span>
<span class="normal">3415</span>
<span class="normal">3416</span>
<span class="normal">3417</span>
<span class="normal">3418</span>
<span class="normal">3419</span>
<span class="normal">3420</span>
<span class="normal">3421</span>
<span class="normal">3422</span>
<span class="normal">3423</span>
<span class="normal">3424</span>
<span class="normal">3425</span>
<span class="normal">3426</span>
<span class="normal">3427</span>
<span class="normal">3428</span>
<span class="normal">3429</span>
<span class="normal">3430</span>
<span class="normal">3431</span>
<span class="normal">3432</span>
<span class="normal">3433</span>
<span class="normal">3434</span>
<span class="normal">3435</span>
<span class="normal">3436</span>
<span class="normal">3437</span>
<span class="normal">3438</span>
<span class="normal">3439</span>
<span class="normal">3440</span>
<span class="normal">3441</span>
<span class="normal">3442</span>
<span class="normal">3443</span>
<span class="normal">3444</span>
<span class="normal">3445</span>
<span class="normal">3446</span>
<span class="normal">3447</span>
<span class="normal">3448</span>
<span class="normal">3449</span>
<span class="normal">3450</span>
<span class="normal">3451</span>
<span class="normal">3452</span>
<span class="normal">3453</span>
<span class="normal">3454</span>
<span class="normal">3455</span>
<span class="normal">3456</span>
<span class="normal">3457</span>
<span class="normal">3458</span>
<span class="normal">3459</span>
<span class="normal">3460</span>
<span class="normal">3461</span>
<span class="normal">3462</span>
<span class="normal">3463</span>
<span class="normal">3464</span>
<span class="normal">3465</span>
<span class="normal">3466</span>
<span class="normal">3467</span>
<span class="normal">3468</span>
<span class="normal">3469</span>
<span class="normal">3470</span>
<span class="normal">3471</span>
<span class="normal">3472</span>
<span class="normal">3473</span>
<span class="normal">3474</span>
<span class="normal">3475</span>
<span class="normal">3476</span>
<span class="normal">3477</span>
<span class="normal">3478</span>
<span class="normal">3479</span>
<span class="normal">3480</span>
<span class="normal">3481</span>
<span class="normal">3482</span>
<span class="normal">3483</span>
<span class="normal">3484</span>
<span class="normal">3485</span>
<span class="normal">3486</span>
<span class="normal">3487</span>
<span class="normal">3488</span>
<span class="normal">3489</span>
<span class="normal">3490</span>
<span class="normal">3491</span>
<span class="normal">3492</span>
<span class="normal">3493</span>
<span class="normal">3494</span>
<span class="normal">3495</span>
<span class="normal">3496</span>
<span class="normal">3497</span>
<span class="normal">3498</span>
<span class="normal">3499</span>
<span class="normal">3500</span>
<span class="normal">3501</span>
<span class="normal">3502</span>
<span class="normal">3503</span>
<span class="normal">3504</span>
<span class="normal">3505</span>
<span class="normal">3506</span>
<span class="normal">3507</span>
<span class="normal">3508</span>
<span class="normal">3509</span>
<span class="normal">3510</span>
<span class="normal">3511</span>
<span class="normal">3512</span>
<span class="normal">3513</span>
<span class="normal">3514</span>
<span class="normal">3515</span>
<span class="normal">3516</span>
<span class="normal">3517</span>
<span class="normal">3518</span>
<span class="normal">3519</span>
<span class="normal">3520</span>
<span class="normal">3521</span>
<span class="normal">3522</span>
<span class="normal">3523</span>
<span class="normal">3524</span>
<span class="normal">3525</span>
<span class="normal">3526</span>
<span class="normal">3527</span>
<span class="normal">3528</span>
<span class="normal">3529</span>
<span class="normal">3530</span>
<span class="normal">3531</span>
<span class="normal">3532</span>
<span class="normal">3533</span>
<span class="normal">3534</span>
<span class="normal">3535</span>
<span class="normal">3536</span>
<span class="normal">3537</span>
<span class="normal">3538</span>
<span class="normal">3539</span>
<span class="normal">3540</span>
<span class="normal">3541</span>
<span class="normal">3542</span>
<span class="normal">3543</span>
<span class="normal">3544</span>
<span class="normal">3545</span>
<span class="normal">3546</span>
<span class="normal">3547</span>
<span class="normal">3548</span>
<span class="normal">3549</span>
<span class="normal">3550</span>
<span class="normal">3551</span>
<span class="normal">3552</span>
<span class="normal">3553</span>
<span class="normal">3554</span>
<span class="normal">3555</span>
<span class="normal">3556</span>
<span class="normal">3557</span>
<span class="normal">3558</span>
<span class="normal">3559</span>
<span class="normal">3560</span>
<span class="normal">3561</span>
<span class="normal">3562</span>
<span class="normal">3563</span>
<span class="normal">3564</span>
<span class="normal">3565</span>
<span class="normal">3566</span>
<span class="normal">3567</span>
<span class="normal">3568</span>
<span class="normal">3569</span>
<span class="normal">3570</span>
<span class="normal">3571</span>
<span class="normal">3572</span>
<span class="normal">3573</span>
<span class="normal">3574</span>
<span class="normal">3575</span>
<span class="normal">3576</span>
<span class="normal">3577</span>
<span class="normal">3578</span>
<span class="normal">3579</span>
<span class="normal">3580</span>
<span class="normal">3581</span>
<span class="normal">3582</span>
<span class="normal">3583</span>
<span class="normal">3584</span>
<span class="normal">3585</span>
<span class="normal">3586</span>
<span class="normal">3587</span>
<span class="normal">3588</span>
<span class="normal">3589</span>
<span class="normal">3590</span>
<span class="normal">3591</span>
<span class="normal">3592</span>
<span class="normal">3593</span>
<span class="normal">3594</span>
<span class="normal">3595</span>
<span class="normal">3596</span>
<span class="normal">3597</span>
<span class="normal">3598</span>
<span class="normal">3599</span>
<span class="normal">3600</span>
<span class="normal">3601</span>
<span class="normal">3602</span>
<span class="normal">3603</span>
<span class="normal">3604</span>
<span class="normal">3605</span>
<span class="normal">3606</span>
<span class="normal">3607</span>
<span class="normal">3608</span>
<span class="normal">3609</span>
<span class="normal">3610</span>
<span class="normal">3611</span>
<span class="normal">3612</span>
<span class="normal">3613</span>
<span class="normal">3614</span>
<span class="normal">3615</span>
<span class="normal">3616</span>
<span class="normal">3617</span>
<span class="normal">3618</span>
<span class="normal">3619</span>
<span class="normal">3620</span>
<span class="normal">3621</span>
<span class="normal">3622</span>
<span class="normal">3623</span>
<span class="normal">3624</span>
<span class="normal">3625</span>
<span class="normal">3626</span>
<span class="normal">3627</span>
<span class="normal">3628</span>
<span class="normal">3629</span>
<span class="normal">3630</span>
<span class="normal">3631</span>
<span class="normal">3632</span>
<span class="normal">3633</span>
<span class="normal">3634</span>
<span class="normal">3635</span>
<span class="normal">3636</span>
<span class="normal">3637</span>
<span class="normal">3638</span>
<span class="normal">3639</span>
<span class="normal">3640</span>
<span class="normal">3641</span>
<span class="normal">3642</span>
<span class="normal">3643</span>
<span class="normal">3644</span>
<span class="normal">3645</span>
<span class="normal">3646</span>
<span class="normal">3647</span>
<span class="normal">3648</span>
<span class="normal">3649</span>
<span class="normal">3650</span>
<span class="normal">3651</span>
<span class="normal">3652</span>
<span class="normal">3653</span>
<span class="normal">3654</span>
<span class="normal">3655</span>
<span class="normal">3656</span>
<span class="normal">3657</span>
<span class="normal">3658</span>
<span class="normal">3659</span>
<span class="normal">3660</span>
<span class="normal">3661</span>
<span class="normal">3662</span>
<span class="normal">3663</span>
<span class="normal">3664</span>
<span class="normal">3665</span>
<span class="normal">3666</span>
<span class="normal">3667</span>
<span class="normal">3668</span>
<span class="normal">3669</span>
<span class="normal">3670</span>
<span class="normal">3671</span>
<span class="normal">3672</span>
<span class="normal">3673</span>
<span class="normal">3674</span>
<span class="normal">3675</span>
<span class="normal">3676</span>
<span class="normal">3677</span>
<span class="normal">3678</span>
<span class="normal">3679</span>
<span class="normal">3680</span>
<span class="normal">3681</span>
<span class="normal">3682</span>
<span class="normal">3683</span>
<span class="normal">3684</span>
<span class="normal">3685</span>
<span class="normal">3686</span>
<span class="normal">3687</span>
<span class="normal">3688</span>
<span class="normal">3689</span>
<span class="normal">3690</span>
<span class="normal">3691</span>
<span class="normal">3692</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">to_tiff_stack</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">filename_pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">channel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">timepoint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">compress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;uint16&quot;</span><span class="p">,</span>
    <span class="n">rescale</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Save data as a stack of 2D TIFF images.</span>

<span class="sd">    Saves the image data as a series of 2D TIFF files, with each Z-slice</span>
<span class="sd">    saved as a separate file. This format is useful for compatibility with</span>
<span class="sd">    tools that don&#39;t support OME-Zarr or napari plugins that require</span>
<span class="sd">    individual TIFF files.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename_pattern: Output filename pattern. Should contain &#39;{z:04d}&#39; or similar</span>
<span class="sd">            format specifier for the Z-slice number. Examples:</span>
<span class="sd">            - &quot;output_z{z:04d}.tif&quot;</span>
<span class="sd">            - &quot;data/slice_{z:03d}.tiff&quot;</span>
<span class="sd">            If pattern doesn&#39;t contain format specifier, &#39;_{z:04d}&#39; is appended</span>
<span class="sd">            before the extension.</span>
<span class="sd">        channel: Channel index to save (0-based). If None and data has multiple</span>
<span class="sd">            channels, all channels will be saved as separate channel dimensions</span>
<span class="sd">            in each TIFF file (multi-channel TIFFs).</span>
<span class="sd">        timepoint: Timepoint index to save (0-based). If None and data has multiple</span>
<span class="sd">            timepoints, raises ValueError (must select single timepoint).</span>
<span class="sd">        compress: Whether to use LZW compression (default: True)</span>
<span class="sd">        dtype: Output data type for TIFF files. Options:</span>
<span class="sd">            - &#39;uint8&#39;: 8-bit unsigned integer (0-255)</span>
<span class="sd">            - &#39;uint16&#39;: 16-bit unsigned integer (0-65535) [default]</span>
<span class="sd">            - &#39;int16&#39;: 16-bit signed integer (-32768 to 32767)</span>
<span class="sd">            - &#39;float32&#39;: 32-bit float (preserves original data)</span>
<span class="sd">            Default &#39;uint16&#39; provides good range and compatibility.</span>
<span class="sd">        rescale: Whether to rescale data to fit the output dtype range.</span>
<span class="sd">            If True, data is linearly scaled from [min, max] to the full</span>
<span class="sd">            range of the output dtype. If False, data is clipped to the</span>
<span class="sd">            output dtype range. Default: True</span>

<span class="sd">    Returns:</span>
<span class="sd">        Base directory path where files were saved</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If data has multiple timepoints but none selected,</span>
<span class="sd">            or if selected channel/timepoint is out of range,</span>
<span class="sd">            or if dtype is not supported</span>
<span class="sd">        OSError: If unable to write to specified directory</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Save as 16-bit with auto-rescaling (default, recommended)</span>
<span class="sd">        &gt;&gt;&gt; znii.to_tiff_stack(&quot;output_z{z:04d}.tif&quot;)</span>

<span class="sd">        &gt;&gt;&gt; # Save as 8-bit for smaller file sizes</span>
<span class="sd">        &gt;&gt;&gt; znii.to_tiff_stack(&quot;output_z{z:04d}.tif&quot;, dtype=&#39;uint8&#39;)</span>

<span class="sd">        &gt;&gt;&gt; # Save specific channel without rescaling</span>
<span class="sd">        &gt;&gt;&gt; znii.to_tiff_stack(&quot;channel0_z{z:04d}.tif&quot;, channel=0, rescale=False)</span>

<span class="sd">        &gt;&gt;&gt; # Save as float32 to preserve original precision</span>
<span class="sd">        &gt;&gt;&gt; znii.to_tiff_stack(&quot;precise_z{z:04d}.tif&quot;, dtype=&#39;float32&#39;)</span>

<span class="sd">    Warnings:</span>
<span class="sd">        This method loads all data into memory. For large datasets,</span>
<span class="sd">        consider cropping or downsampling first to reduce memory usage.</span>
<span class="sd">        The cellseg3d napari plugin and similar tools work best with</span>
<span class="sd">        cropped regions rather than full-resolution whole-brain images.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Z-dimension becomes the stack (file) dimension</span>
<span class="sd">        - Time and channel dimensions are handled as specified</span>
<span class="sd">        - Spatial transformations are not preserved in TIFF format</span>
<span class="sd">        - For 5D data (T,C,Z,Y,X), you must select a single timepoint</span>
<span class="sd">        - Multi-channel data can be saved as multi-channel TIFFs or selected</span>
<span class="sd">        - Data type conversion helps ensure compatibility with analysis tools</span>
<span class="sd">        - uint16 is recommended for most scientific applications (good range + compatibility)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">tifffile</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
            <span class="s2">&quot;tifffile is required for TIFF stack support. &quot;</span>
            <span class="s2">&quot;Install with: pip install tifffile&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Get data and dimensions</span>
    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>

    <span class="c1"># Create output directory if needed</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

    <span class="n">output_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename_pattern</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">output_dir</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="c1"># Handle dimensional selection and validation</span>
    <span class="c1"># Remove singleton dimensions first, similar to to_nifti</span>
    <span class="n">squeeze_axes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">remaining_dims</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">time_dim_size</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">channel_dim_size</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">time_dim_size</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">squeeze_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">timepoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Data has </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> timepoints. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Must specify &#39;timepoint&#39; parameter to select a single timepoint.&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">timepoint</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Timepoint </span><span class="si">{</span><span class="n">timepoint</span><span class="si">}</span><span class="s2"> is out of range (data has </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> timepoints)&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">remaining_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
            <span class="n">channel_dim_size</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">squeeze_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Data has </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> channels. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Must specify &#39;channel&#39; parameter to select a single channel.&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">channel</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> is out of range (data has </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> channels)&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">remaining_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">remaining_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

    <span class="c1"># Select specific timepoint if needed</span>
    <span class="k">if</span> <span class="n">time_dim_size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">timepoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">time_axis</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">timepoint</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">time_axis</span><span class="p">)</span>
        <span class="c1"># Update dims list</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">time_axis</span><span class="p">]</span>

    <span class="c1"># Select specific channel if needed</span>
    <span class="k">if</span> <span class="n">channel_dim_size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">channel_axis</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">channel_axis</span><span class="p">)</span>
        <span class="c1"># Update dims list</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">channel_axis</span><span class="p">]</span>

    <span class="c1"># Squeeze singleton dimensions</span>
    <span class="k">if</span> <span class="n">squeeze_axes</span><span class="p">:</span>
        <span class="c1"># Recalculate squeeze axes after potential dimension removal</span>
        <span class="n">current_squeeze_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">squeeze_axes</span><span class="p">:</span>
            <span class="c1"># Count how many axes were removed before this one</span>
            <span class="n">removed_before</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="mi">1</span>
                <span class="k">for</span> <span class="n">removed_axis</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">time_dim_size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">timepoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="p">),</span>
                    <span class="p">(</span>
                        <span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">channel_dim_size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="p">),</span>
                <span class="p">]</span>
                <span class="k">if</span> <span class="n">removed_axis</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">removed_axis</span> <span class="o">&lt;</span> <span class="n">axis</span>
            <span class="p">)</span>
            <span class="n">current_squeeze_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axis</span> <span class="o">-</span> <span class="n">removed_before</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">current_squeeze_axes</span><span class="p">))</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_squeeze_axes</span><span class="p">]</span>

    <span class="c1"># Find Z dimension for stacking</span>
    <span class="k">if</span> <span class="s2">&quot;z&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data must have a Z dimension for TIFF stack export&quot;</span><span class="p">)</span>

    <span class="n">z_axis</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>
    <span class="n">z_size</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">z_axis</span><span class="p">]</span>

    <span class="c1"># Check filename pattern contains format specifier</span>
    <span class="k">if</span> <span class="s2">&quot;{z&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">filename_pattern</span><span class="p">:</span>
        <span class="c1"># Add default z format before extension</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename_pattern</span><span class="p">)</span>
        <span class="n">filename_pattern</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="se">{{</span><span class="s2">z:04d</span><span class="se">}}</span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># Move Z axis to first position for easy iteration</span>
    <span class="n">axes_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="n">axes_order</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axes_order</span><span class="p">[</span><span class="n">z_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">axes_order</span><span class="p">[</span><span class="n">z_axis</span><span class="p">],</span> <span class="n">axes_order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes_order</span><span class="p">)</span>

    <span class="c1"># Handle data type conversion and rescaling</span>
    <span class="n">supported_dtypes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;uint8&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
        <span class="s2">&quot;uint16&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span>
        <span class="s2">&quot;int16&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span>
        <span class="s2">&quot;float32&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_dtypes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unsupported dtype &#39;</span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&#39;. Supported types: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">supported_dtypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">target_dtype</span> <span class="o">=</span> <span class="n">supported_dtypes</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">rescale</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;float32&quot;</span><span class="p">:</span>
        <span class="c1"># Get the data range</span>
        <span class="n">data_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">data_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data_min</span> <span class="o">==</span> <span class="n">data_max</span><span class="p">:</span>
            <span class="c1"># Handle constant data case</span>
            <span class="n">data_scaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">target_dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get target range for the dtype</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;uint8&quot;</span><span class="p">:</span>
                <span class="n">target_min</span><span class="p">,</span> <span class="n">target_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span>
            <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;uint16&quot;</span><span class="p">:</span>
                <span class="n">target_min</span><span class="p">,</span> <span class="n">target_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">65535</span>
            <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;int16&quot;</span><span class="p">:</span>
                <span class="n">target_min</span><span class="p">,</span> <span class="n">target_max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">32767</span>

            <span class="c1"># Convert data to float to avoid overflow during rescaling</span>
            <span class="c1"># Linear rescaling formula:</span>
            <span class="c1"># new_value = (value - data_min) * (target_max - target_min)</span>
            <span class="c1">#             / (data_max - data_min) + target_min</span>
            <span class="n">data_float</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">data_scaled</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">data_float</span> <span class="o">-</span> <span class="n">data_min</span><span class="p">)</span>
                <span class="o">*</span> <span class="p">(</span><span class="n">target_max</span> <span class="o">-</span> <span class="n">target_min</span><span class="p">)</span>
                <span class="o">/</span> <span class="p">(</span><span class="n">data_max</span> <span class="o">-</span> <span class="n">data_min</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">target_min</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_dtype</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Rescaled data from [</span><span class="si">{</span><span class="n">data_min</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">data_max</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">] to </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> range&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># No rescaling - just clip and convert</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;uint8&quot;</span><span class="p">:</span>
            <span class="n">data_scaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;uint16&quot;</span><span class="p">:</span>
            <span class="n">data_scaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">65535</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;int16&quot;</span><span class="p">:</span>
            <span class="n">data_scaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">-</span><span class="mi">32768</span><span class="p">,</span> <span class="mi">32767</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># float32</span>
            <span class="n">data_scaled</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">target_dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;float32&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converted data to </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> with clipping (no rescaling)&quot;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data_scaled</span>

    <span class="c1"># Save each Z-slice as a separate TIFF file</span>
    <span class="n">compression</span> <span class="o">=</span> <span class="s2">&quot;lzw&quot;</span> <span class="k">if</span> <span class="n">compress</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">saved_files</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">z_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z_size</span><span class="p">):</span>
        <span class="n">slice_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">z_idx</span><span class="p">]</span>

        <span class="c1"># Generate filename for this slice</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename_pattern</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">z_idx</span><span class="p">)</span>

        <span class="c1"># Save the 2D slice</span>
        <span class="n">tifffile</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">slice_data</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>
        <span class="n">saved_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_files</span><span class="p">)</span><span class="si">}</span><span class="s2"> TIFF files to </span><span class="si">{</span><span class="n">output_dir</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="s1">&#39;.&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Files: </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">saved_files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2"> ... </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">saved_files</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">output_dir</span> <span class="ow">or</span> <span class="s2">&quot;.&quot;</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.from_imaris" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_imaris</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">timepoint</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">axes_order</span><span class="o">=</span><span class="s1">&#39;ZYX&#39;</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;RAS&#39;</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Load from Imaris (.ims) file format.</p>
<p>Imaris files use HDF5 format with specific dataset structure.
This method requires the 'imaris' extra dependency (h5py).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>path</code></b>
              (<code><span title="str">str</span></code>)
          
          <div class="doc-md-description">
            <p>Path to Imaris (.ims) file</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>level</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>0</code>
)
          
          <div class="doc-md-description">
            <p>Resolution level to load (0 = full resolution)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>timepoint</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>0</code>
)
          
          <div class="doc-md-description">
            <p>Time point to load (default: 0)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>channel</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>0</code>
)
          
          <div class="doc-md-description">
            <p>Channel to load (default: 0)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>chunks</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;auto&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Chunking strategy for dask array</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>axes_order</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;ZYX&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Spatial axes order for compatibility (default: "ZYX")</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>orientation</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;RAS&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Default orientation (default: "RAS")</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>ZarrNii instance</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ImportError">ImportError</span></code>
            
          <div class="doc-md-description">
            <p>If h5py is not available</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If the file is not a valid Imaris file</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">3694</span>
<span class="normal">3695</span>
<span class="normal">3696</span>
<span class="normal">3697</span>
<span class="normal">3698</span>
<span class="normal">3699</span>
<span class="normal">3700</span>
<span class="normal">3701</span>
<span class="normal">3702</span>
<span class="normal">3703</span>
<span class="normal">3704</span>
<span class="normal">3705</span>
<span class="normal">3706</span>
<span class="normal">3707</span>
<span class="normal">3708</span>
<span class="normal">3709</span>
<span class="normal">3710</span>
<span class="normal">3711</span>
<span class="normal">3712</span>
<span class="normal">3713</span>
<span class="normal">3714</span>
<span class="normal">3715</span>
<span class="normal">3716</span>
<span class="normal">3717</span>
<span class="normal">3718</span>
<span class="normal">3719</span>
<span class="normal">3720</span>
<span class="normal">3721</span>
<span class="normal">3722</span>
<span class="normal">3723</span>
<span class="normal">3724</span>
<span class="normal">3725</span>
<span class="normal">3726</span>
<span class="normal">3727</span>
<span class="normal">3728</span>
<span class="normal">3729</span>
<span class="normal">3730</span>
<span class="normal">3731</span>
<span class="normal">3732</span>
<span class="normal">3733</span>
<span class="normal">3734</span>
<span class="normal">3735</span>
<span class="normal">3736</span>
<span class="normal">3737</span>
<span class="normal">3738</span>
<span class="normal">3739</span>
<span class="normal">3740</span>
<span class="normal">3741</span>
<span class="normal">3742</span>
<span class="normal">3743</span>
<span class="normal">3744</span>
<span class="normal">3745</span>
<span class="normal">3746</span>
<span class="normal">3747</span>
<span class="normal">3748</span>
<span class="normal">3749</span>
<span class="normal">3750</span>
<span class="normal">3751</span>
<span class="normal">3752</span>
<span class="normal">3753</span>
<span class="normal">3754</span>
<span class="normal">3755</span>
<span class="normal">3756</span>
<span class="normal">3757</span>
<span class="normal">3758</span>
<span class="normal">3759</span>
<span class="normal">3760</span>
<span class="normal">3761</span>
<span class="normal">3762</span>
<span class="normal">3763</span>
<span class="normal">3764</span>
<span class="normal">3765</span>
<span class="normal">3766</span>
<span class="normal">3767</span>
<span class="normal">3768</span>
<span class="normal">3769</span>
<span class="normal">3770</span>
<span class="normal">3771</span>
<span class="normal">3772</span>
<span class="normal">3773</span>
<span class="normal">3774</span>
<span class="normal">3775</span>
<span class="normal">3776</span>
<span class="normal">3777</span>
<span class="normal">3778</span>
<span class="normal">3779</span>
<span class="normal">3780</span>
<span class="normal">3781</span>
<span class="normal">3782</span>
<span class="normal">3783</span>
<span class="normal">3784</span>
<span class="normal">3785</span>
<span class="normal">3786</span>
<span class="normal">3787</span>
<span class="normal">3788</span>
<span class="normal">3789</span>
<span class="normal">3790</span>
<span class="normal">3791</span>
<span class="normal">3792</span>
<span class="normal">3793</span>
<span class="normal">3794</span>
<span class="normal">3795</span>
<span class="normal">3796</span>
<span class="normal">3797</span>
<span class="normal">3798</span>
<span class="normal">3799</span>
<span class="normal">3800</span>
<span class="normal">3801</span>
<span class="normal">3802</span>
<span class="normal">3803</span>
<span class="normal">3804</span>
<span class="normal">3805</span>
<span class="normal">3806</span>
<span class="normal">3807</span>
<span class="normal">3808</span>
<span class="normal">3809</span>
<span class="normal">3810</span>
<span class="normal">3811</span>
<span class="normal">3812</span>
<span class="normal">3813</span>
<span class="normal">3814</span>
<span class="normal">3815</span>
<span class="normal">3816</span>
<span class="normal">3817</span>
<span class="normal">3818</span>
<span class="normal">3819</span>
<span class="normal">3820</span>
<span class="normal">3821</span>
<span class="normal">3822</span>
<span class="normal">3823</span>
<span class="normal">3824</span>
<span class="normal">3825</span>
<span class="normal">3826</span>
<span class="normal">3827</span>
<span class="normal">3828</span>
<span class="normal">3829</span>
<span class="normal">3830</span>
<span class="normal">3831</span>
<span class="normal">3832</span>
<span class="normal">3833</span>
<span class="normal">3834</span>
<span class="normal">3835</span>
<span class="normal">3836</span>
<span class="normal">3837</span>
<span class="normal">3838</span>
<span class="normal">3839</span>
<span class="normal">3840</span>
<span class="normal">3841</span>
<span class="normal">3842</span>
<span class="normal">3843</span>
<span class="normal">3844</span>
<span class="normal">3845</span>
<span class="normal">3846</span>
<span class="normal">3847</span>
<span class="normal">3848</span>
<span class="normal">3849</span>
<span class="normal">3850</span>
<span class="normal">3851</span>
<span class="normal">3852</span>
<span class="normal">3853</span>
<span class="normal">3854</span>
<span class="normal">3855</span>
<span class="normal">3856</span>
<span class="normal">3857</span>
<span class="normal">3858</span>
<span class="normal">3859</span>
<span class="normal">3860</span>
<span class="normal">3861</span>
<span class="normal">3862</span>
<span class="normal">3863</span>
<span class="normal">3864</span>
<span class="normal">3865</span>
<span class="normal">3866</span>
<span class="normal">3867</span>
<span class="normal">3868</span>
<span class="normal">3869</span>
<span class="normal">3870</span>
<span class="normal">3871</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_imaris</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span>
    <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">level</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">timepoint</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">channel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">chunks</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="n">axes_order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ZYX&quot;</span><span class="p">,</span>
    <span class="n">orientation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;RAS&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load from Imaris (.ims) file format.</span>

<span class="sd">    Imaris files use HDF5 format with specific dataset structure.</span>
<span class="sd">    This method requires the &#39;imaris&#39; extra dependency (h5py).</span>

<span class="sd">    Args:</span>
<span class="sd">        path: Path to Imaris (.ims) file</span>
<span class="sd">        level: Resolution level to load (0 = full resolution)</span>
<span class="sd">        timepoint: Time point to load (default: 0)</span>
<span class="sd">        channel: Channel to load (default: 0)</span>
<span class="sd">        chunks: Chunking strategy for dask array</span>
<span class="sd">        axes_order: Spatial axes order for compatibility (default: &quot;ZYX&quot;)</span>
<span class="sd">        orientation: Default orientation (default: &quot;RAS&quot;)</span>

<span class="sd">    Returns:</span>
<span class="sd">        ZarrNii instance</span>

<span class="sd">    Raises:</span>
<span class="sd">        ImportError: If h5py is not available</span>
<span class="sd">        ValueError: If the file is not a valid Imaris file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
            <span class="s2">&quot;h5py is required for Imaris support. &quot;</span>
            <span class="s2">&quot;Install with: pip install zarrnii[imaris] or pip install h5py&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Open Imaris file</span>
    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Verify it&#39;s an Imaris file by checking for standard structure</span>
        <span class="k">if</span> <span class="s2">&quot;DataSet&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;File </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> does not appear to be a valid Imaris file (missing DataSet group)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Navigate to the specific dataset</span>
        <span class="n">dataset_group</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;DataSet&quot;</span><span class="p">]</span>

        <span class="c1"># Find available resolution levels</span>
        <span class="n">resolution_levels</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dataset_group</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;ResolutionLevel&quot;</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">resolution_levels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No resolution levels found in Imaris file&quot;</span><span class="p">)</span>

        <span class="c1"># Validate level parameter</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">resolution_levels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Level </span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2"> not available. Available levels: 0-</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">resolution_levels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Navigate to specified resolution level</span>
        <span class="n">res_level_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;ResolutionLevel </span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">res_level_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dataset_group</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resolution level </span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2"> not found&quot;</span><span class="p">)</span>

        <span class="n">res_group</span> <span class="o">=</span> <span class="n">dataset_group</span><span class="p">[</span><span class="n">res_level_key</span><span class="p">]</span>

        <span class="c1"># Find available timepoints</span>
        <span class="n">timepoints</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">res_group</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;TimePoint&quot;</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">timepoints</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No timepoints found in Imaris file&quot;</span><span class="p">)</span>

        <span class="c1"># Validate timepoint parameter</span>
        <span class="k">if</span> <span class="n">timepoint</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">timepoints</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Timepoint </span><span class="si">{</span><span class="n">timepoint</span><span class="si">}</span><span class="s2"> not available. Available timepoints: 0-</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">timepoints</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Navigate to specified timepoint</span>
        <span class="n">time_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;TimePoint </span><span class="si">{</span><span class="n">timepoint</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">time_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res_group</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Timepoint </span><span class="si">{</span><span class="n">timepoint</span><span class="si">}</span><span class="s2"> not found&quot;</span><span class="p">)</span>

        <span class="n">time_group</span> <span class="o">=</span> <span class="n">res_group</span><span class="p">[</span><span class="n">time_key</span><span class="p">]</span>

        <span class="c1"># Find available channels</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">time_group</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Channel&quot;</span><span class="p">)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No channels found in Imaris file&quot;</span><span class="p">)</span>

        <span class="c1"># Validate channel parameter</span>
        <span class="k">if</span> <span class="n">channel</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> not available. Available channels: 0-</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Navigate to specified channel</span>
        <span class="n">channel_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">channel_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">time_group</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2"> not found&quot;</span><span class="p">)</span>

        <span class="n">channel_group</span> <span class="o">=</span> <span class="n">time_group</span><span class="p">[</span><span class="n">channel_key</span><span class="p">]</span>

        <span class="c1"># Load the actual data</span>
        <span class="k">if</span> <span class="s2">&quot;Data&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channel_group</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No Data dataset found in channel group&quot;</span><span class="p">)</span>

        <span class="n">data_dataset</span> <span class="o">=</span> <span class="n">channel_group</span><span class="p">[</span><span class="s2">&quot;Data&quot;</span><span class="p">]</span>

        <span class="c1"># Load data into memory first (necessary because HDF5 file will be closed)</span>
        <span class="n">data_numpy</span> <span class="o">=</span> <span class="n">data_dataset</span><span class="p">[:]</span>

        <span class="c1"># Create dask array from numpy array</span>
        <span class="n">data_array</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">data_numpy</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">)</span>

        <span class="c1"># Add channel dimension if not present</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">data_array</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

        <span class="c1"># Extract spatial metadata</span>
        <span class="c1"># Try to get spacing information from Imaris metadata</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>  <span class="c1"># Default spacing</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>  <span class="c1"># Default origin</span>

        <span class="c1"># Look for ImageSizeX, ImageSizeY, ImageSizeZ attributes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Navigate back to get image info</span>
            <span class="k">if</span> <span class="s2">&quot;ImageSizeX&quot;</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="n">x_size</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ImageSizeX&quot;</span><span class="p">]</span>
                <span class="n">y_size</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ImageSizeY&quot;</span><span class="p">]</span>
                <span class="n">z_size</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ImageSizeZ&quot;</span><span class="p">]</span>

                <span class="c1"># Calculate spacing based on physical size and voxel count</span>
                <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># X dimension</span>
                    <span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_size</span> <span class="o">/</span> <span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Y dimension</span>
                    <span class="n">spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_size</span> <span class="o">/</span> <span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Z dimension</span>
                    <span class="n">spacing</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_size</span> <span class="o">/</span> <span class="n">data_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="c1"># Use default spacing if metadata is not available</span>
            <span class="k">pass</span>

        <span class="c1"># Create dimensions</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes_order</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

        <span class="c1"># Create scale and translation dictionaries</span>
        <span class="n">scale_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">translation_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">spatial_dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spatial_dims</span><span class="p">):</span>
            <span class="n">scale_dict</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">spacing</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">translation_dict</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">origin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Create NgffImage</span>
        <span class="n">ngff_image</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data_array</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">scale</span><span class="o">=</span><span class="n">scale_dict</span><span class="p">,</span>
            <span class="n">translation</span><span class="o">=</span><span class="n">translation_dict</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;imaris_image_</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">timepoint</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Create and return ZarrNii instance</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span>
        <span class="n">_omero</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.to_imaris" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">to_imaris</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s1">&#39;gzip&#39;</span><span class="p">,</span> <span class="n">compression_opts</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Save to Imaris (.ims) file format using HDF5.</p>
<p>This method creates Imaris files compatible with Imaris software by
following the exact HDF5 structure from correctly-formed reference files.
All attributes use byte-array encoding as required by Imaris.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>path</code></b>
              (<code><span title="str">str</span></code>)
          
          <div class="doc-md-description">
            <p>Output path for Imaris (.ims) file</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>compression</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;gzip&#39;</code>
)
          
          <div class="doc-md-description">
            <p>HDF5 compression method (default: "gzip")</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>compression_opts</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>6</code>
)
          
          <div class="doc-md-description">
            <p>Compression level (default: 6)</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>str</code></b> (              <code><span title="str">str</span></code>
)          
          <div class="doc-md-description">
            <p>Path to the saved file</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ImportError">ImportError</span></code>
            
          <div class="doc-md-description">
            <p>If h5py is not available</p>
          </div>
        </li>
    </ul>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Imaris files are always saved in ZYX axis order</li>
<li>Automatic axis reordering from XYZ to ZYX if needed</li>
<li>Spatial transformations and metadata are preserved</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">3873</span>
<span class="normal">3874</span>
<span class="normal">3875</span>
<span class="normal">3876</span>
<span class="normal">3877</span>
<span class="normal">3878</span>
<span class="normal">3879</span>
<span class="normal">3880</span>
<span class="normal">3881</span>
<span class="normal">3882</span>
<span class="normal">3883</span>
<span class="normal">3884</span>
<span class="normal">3885</span>
<span class="normal">3886</span>
<span class="normal">3887</span>
<span class="normal">3888</span>
<span class="normal">3889</span>
<span class="normal">3890</span>
<span class="normal">3891</span>
<span class="normal">3892</span>
<span class="normal">3893</span>
<span class="normal">3894</span>
<span class="normal">3895</span>
<span class="normal">3896</span>
<span class="normal">3897</span>
<span class="normal">3898</span>
<span class="normal">3899</span>
<span class="normal">3900</span>
<span class="normal">3901</span>
<span class="normal">3902</span>
<span class="normal">3903</span>
<span class="normal">3904</span>
<span class="normal">3905</span>
<span class="normal">3906</span>
<span class="normal">3907</span>
<span class="normal">3908</span>
<span class="normal">3909</span>
<span class="normal">3910</span>
<span class="normal">3911</span>
<span class="normal">3912</span>
<span class="normal">3913</span>
<span class="normal">3914</span>
<span class="normal">3915</span>
<span class="normal">3916</span>
<span class="normal">3917</span>
<span class="normal">3918</span>
<span class="normal">3919</span>
<span class="normal">3920</span>
<span class="normal">3921</span>
<span class="normal">3922</span>
<span class="normal">3923</span>
<span class="normal">3924</span>
<span class="normal">3925</span>
<span class="normal">3926</span>
<span class="normal">3927</span>
<span class="normal">3928</span>
<span class="normal">3929</span>
<span class="normal">3930</span>
<span class="normal">3931</span>
<span class="normal">3932</span>
<span class="normal">3933</span>
<span class="normal">3934</span>
<span class="normal">3935</span>
<span class="normal">3936</span>
<span class="normal">3937</span>
<span class="normal">3938</span>
<span class="normal">3939</span>
<span class="normal">3940</span>
<span class="normal">3941</span>
<span class="normal">3942</span>
<span class="normal">3943</span>
<span class="normal">3944</span>
<span class="normal">3945</span>
<span class="normal">3946</span>
<span class="normal">3947</span>
<span class="normal">3948</span>
<span class="normal">3949</span>
<span class="normal">3950</span>
<span class="normal">3951</span>
<span class="normal">3952</span>
<span class="normal">3953</span>
<span class="normal">3954</span>
<span class="normal">3955</span>
<span class="normal">3956</span>
<span class="normal">3957</span>
<span class="normal">3958</span>
<span class="normal">3959</span>
<span class="normal">3960</span>
<span class="normal">3961</span>
<span class="normal">3962</span>
<span class="normal">3963</span>
<span class="normal">3964</span>
<span class="normal">3965</span>
<span class="normal">3966</span>
<span class="normal">3967</span>
<span class="normal">3968</span>
<span class="normal">3969</span>
<span class="normal">3970</span>
<span class="normal">3971</span>
<span class="normal">3972</span>
<span class="normal">3973</span>
<span class="normal">3974</span>
<span class="normal">3975</span>
<span class="normal">3976</span>
<span class="normal">3977</span>
<span class="normal">3978</span>
<span class="normal">3979</span>
<span class="normal">3980</span>
<span class="normal">3981</span>
<span class="normal">3982</span>
<span class="normal">3983</span>
<span class="normal">3984</span>
<span class="normal">3985</span>
<span class="normal">3986</span>
<span class="normal">3987</span>
<span class="normal">3988</span>
<span class="normal">3989</span>
<span class="normal">3990</span>
<span class="normal">3991</span>
<span class="normal">3992</span>
<span class="normal">3993</span>
<span class="normal">3994</span>
<span class="normal">3995</span>
<span class="normal">3996</span>
<span class="normal">3997</span>
<span class="normal">3998</span>
<span class="normal">3999</span>
<span class="normal">4000</span>
<span class="normal">4001</span>
<span class="normal">4002</span>
<span class="normal">4003</span>
<span class="normal">4004</span>
<span class="normal">4005</span>
<span class="normal">4006</span>
<span class="normal">4007</span>
<span class="normal">4008</span>
<span class="normal">4009</span>
<span class="normal">4010</span>
<span class="normal">4011</span>
<span class="normal">4012</span>
<span class="normal">4013</span>
<span class="normal">4014</span>
<span class="normal">4015</span>
<span class="normal">4016</span>
<span class="normal">4017</span>
<span class="normal">4018</span>
<span class="normal">4019</span>
<span class="normal">4020</span>
<span class="normal">4021</span>
<span class="normal">4022</span>
<span class="normal">4023</span>
<span class="normal">4024</span>
<span class="normal">4025</span>
<span class="normal">4026</span>
<span class="normal">4027</span>
<span class="normal">4028</span>
<span class="normal">4029</span>
<span class="normal">4030</span>
<span class="normal">4031</span>
<span class="normal">4032</span>
<span class="normal">4033</span>
<span class="normal">4034</span>
<span class="normal">4035</span>
<span class="normal">4036</span>
<span class="normal">4037</span>
<span class="normal">4038</span>
<span class="normal">4039</span>
<span class="normal">4040</span>
<span class="normal">4041</span>
<span class="normal">4042</span>
<span class="normal">4043</span>
<span class="normal">4044</span>
<span class="normal">4045</span>
<span class="normal">4046</span>
<span class="normal">4047</span>
<span class="normal">4048</span>
<span class="normal">4049</span>
<span class="normal">4050</span>
<span class="normal">4051</span>
<span class="normal">4052</span>
<span class="normal">4053</span>
<span class="normal">4054</span>
<span class="normal">4055</span>
<span class="normal">4056</span>
<span class="normal">4057</span>
<span class="normal">4058</span>
<span class="normal">4059</span>
<span class="normal">4060</span>
<span class="normal">4061</span>
<span class="normal">4062</span>
<span class="normal">4063</span>
<span class="normal">4064</span>
<span class="normal">4065</span>
<span class="normal">4066</span>
<span class="normal">4067</span>
<span class="normal">4068</span>
<span class="normal">4069</span>
<span class="normal">4070</span>
<span class="normal">4071</span>
<span class="normal">4072</span>
<span class="normal">4073</span>
<span class="normal">4074</span>
<span class="normal">4075</span>
<span class="normal">4076</span>
<span class="normal">4077</span>
<span class="normal">4078</span>
<span class="normal">4079</span>
<span class="normal">4080</span>
<span class="normal">4081</span>
<span class="normal">4082</span>
<span class="normal">4083</span>
<span class="normal">4084</span>
<span class="normal">4085</span>
<span class="normal">4086</span>
<span class="normal">4087</span>
<span class="normal">4088</span>
<span class="normal">4089</span>
<span class="normal">4090</span>
<span class="normal">4091</span>
<span class="normal">4092</span>
<span class="normal">4093</span>
<span class="normal">4094</span>
<span class="normal">4095</span>
<span class="normal">4096</span>
<span class="normal">4097</span>
<span class="normal">4098</span>
<span class="normal">4099</span>
<span class="normal">4100</span>
<span class="normal">4101</span>
<span class="normal">4102</span>
<span class="normal">4103</span>
<span class="normal">4104</span>
<span class="normal">4105</span>
<span class="normal">4106</span>
<span class="normal">4107</span>
<span class="normal">4108</span>
<span class="normal">4109</span>
<span class="normal">4110</span>
<span class="normal">4111</span>
<span class="normal">4112</span>
<span class="normal">4113</span>
<span class="normal">4114</span>
<span class="normal">4115</span>
<span class="normal">4116</span>
<span class="normal">4117</span>
<span class="normal">4118</span>
<span class="normal">4119</span>
<span class="normal">4120</span>
<span class="normal">4121</span>
<span class="normal">4122</span>
<span class="normal">4123</span>
<span class="normal">4124</span>
<span class="normal">4125</span>
<span class="normal">4126</span>
<span class="normal">4127</span>
<span class="normal">4128</span>
<span class="normal">4129</span>
<span class="normal">4130</span>
<span class="normal">4131</span>
<span class="normal">4132</span>
<span class="normal">4133</span>
<span class="normal">4134</span>
<span class="normal">4135</span>
<span class="normal">4136</span>
<span class="normal">4137</span>
<span class="normal">4138</span>
<span class="normal">4139</span>
<span class="normal">4140</span>
<span class="normal">4141</span>
<span class="normal">4142</span>
<span class="normal">4143</span>
<span class="normal">4144</span>
<span class="normal">4145</span>
<span class="normal">4146</span>
<span class="normal">4147</span>
<span class="normal">4148</span>
<span class="normal">4149</span>
<span class="normal">4150</span>
<span class="normal">4151</span>
<span class="normal">4152</span>
<span class="normal">4153</span>
<span class="normal">4154</span>
<span class="normal">4155</span>
<span class="normal">4156</span>
<span class="normal">4157</span>
<span class="normal">4158</span>
<span class="normal">4159</span>
<span class="normal">4160</span>
<span class="normal">4161</span>
<span class="normal">4162</span>
<span class="normal">4163</span>
<span class="normal">4164</span>
<span class="normal">4165</span>
<span class="normal">4166</span>
<span class="normal">4167</span>
<span class="normal">4168</span>
<span class="normal">4169</span>
<span class="normal">4170</span>
<span class="normal">4171</span>
<span class="normal">4172</span>
<span class="normal">4173</span>
<span class="normal">4174</span>
<span class="normal">4175</span>
<span class="normal">4176</span>
<span class="normal">4177</span>
<span class="normal">4178</span>
<span class="normal">4179</span>
<span class="normal">4180</span>
<span class="normal">4181</span>
<span class="normal">4182</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">to_imaris</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">compression</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gzip&quot;</span><span class="p">,</span> <span class="n">compression_opts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save to Imaris (.ims) file format using HDF5.</span>

<span class="sd">    This method creates Imaris files compatible with Imaris software by</span>
<span class="sd">    following the exact HDF5 structure from correctly-formed reference files.</span>
<span class="sd">    All attributes use byte-array encoding as required by Imaris.</span>

<span class="sd">    Args:</span>
<span class="sd">        path: Output path for Imaris (.ims) file</span>
<span class="sd">        compression: HDF5 compression method (default: &quot;gzip&quot;)</span>
<span class="sd">        compression_opts: Compression level (default: 6)</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: Path to the saved file</span>

<span class="sd">    Raises:</span>
<span class="sd">        ImportError: If h5py is not available</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Imaris files are always saved in ZYX axis order</span>
<span class="sd">        - Automatic axis reordering from XYZ to ZYX if needed</span>
<span class="sd">        - Spatial transformations and metadata are preserved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
            <span class="s2">&quot;h5py is required for Imaris support. &quot;</span>
            <span class="s2">&quot;Install with: pip install zarrnii[imaris] or pip install h5py&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Determine the image to save</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;XYZ&quot;</span><span class="p">:</span>
        <span class="c1"># Need to reorder data from XYZ to ZYX for Imaris</span>
        <span class="n">ngff_image_to_save</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_zyx_ngff_image</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Already in ZYX order</span>
        <span class="n">ngff_image_to_save</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span>

    <span class="c1"># Ensure path has .ims extension</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.ims&quot;</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s2">&quot;.ims&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_string_to_byte_array</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert string to byte array as required by Imaris.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">])</span>

    <span class="c1"># Get data and metadata</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ngff_image_to_save</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;compute&quot;</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ngff_image_to_save</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
        <span class="p">)</span>  <span class="c1"># Convert Dask array to numpy array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ngff_image_to_save</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># Handle numpy arrays directly</span>

    <span class="c1"># Handle dimensions: expect ZYX or CZYX</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># CZYX format</span>
        <span class="n">n_channels</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># ZYX format - single channel</span>
        <span class="n">n_channels</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>  <span class="c1"># Add channel dimension</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unsupported data shape: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">. Expected 3D (ZYX) or 4D (CZYX)&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Create Imaris file structure exactly matching reference file</span>
    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Root attributes - use exact byte array format from reference</span>
        <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;DataSetDirectoryName&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;DataSet&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;DataSetInfoDirectoryName&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;DataSetInfo&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ImarisDataSet&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;ImarisDataSet&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ImarisVersion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;5.5.0&quot;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;NumberOfDataSets&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ThumbnailDirectoryName&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;Thumbnail&quot;</span><span class="p">)</span>

        <span class="c1"># Create main DataSet group structure</span>
        <span class="n">dataset_group</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;DataSet&quot;</span><span class="p">)</span>
        <span class="n">res_group</span> <span class="o">=</span> <span class="n">dataset_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;ResolutionLevel 0&quot;</span><span class="p">)</span>
        <span class="n">time_group</span> <span class="o">=</span> <span class="n">res_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;TimePoint 0&quot;</span><span class="p">)</span>

        <span class="c1"># Create channels with proper attributes</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_channels</span><span class="p">):</span>
            <span class="n">channel_group</span> <span class="o">=</span> <span class="n">time_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">channel_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>  <span class="c1"># (Z, Y, X)</span>

            <span class="c1"># Channel attributes - use byte array format exactly like reference</span>
            <span class="n">channel_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ImageSizeX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">channel_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ImageSizeY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">channel_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ImageSizeZ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
            <span class="n">channel_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ImageBlockSizeX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">channel_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ImageBlockSizeY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">channel_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ImageBlockSizeZ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
            <span class="p">)</span>

            <span class="c1"># Histogram range attributes</span>
            <span class="n">data_min</span><span class="p">,</span> <span class="n">data_max</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">channel_data</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span> <span class="nb">float</span><span class="p">(</span>
                <span class="n">channel_data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">channel_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;HistogramMin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">data_min</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">channel_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;HistogramMax&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">data_max</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Create data dataset with proper compression</span>
            <span class="c1"># Preserve original data type but ensure it&#39;s compatible with Imaris</span>
            <span class="k">if</span> <span class="n">channel_data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span> <span class="ow">or</span> <span class="n">channel_data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
                <span class="c1"># Keep float data as is for round-trip compatibility</span>
                <span class="n">data_for_storage</span> <span class="o">=</span> <span class="n">channel_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">channel_data</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">]:</span>
                <span class="c1"># Keep 16-bit data as is</span>
                <span class="n">data_for_storage</span> <span class="o">=</span> <span class="n">channel_data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Convert other types to uint8</span>
                <span class="n">data_for_storage</span> <span class="o">=</span> <span class="n">channel_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

            <span class="n">channel_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;Data&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data_for_storage</span><span class="p">,</span>
                <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
                <span class="n">compression_opts</span><span class="o">=</span><span class="n">compression_opts</span><span class="p">,</span>
                <span class="n">chunks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Create histogram</span>
            <span class="n">hist_data</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
                <span class="n">channel_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="n">data_min</span><span class="p">,</span> <span class="n">data_max</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">channel_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                <span class="s2">&quot;Histogram&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">hist_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Get spacing directly from scale dictionary with proper XYZ order</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Extract voxel sizes directly from ngff_image scale dictionary</span>
            <span class="c1"># This ensures we get X, Y, Z in the correct order regardless of axes_order</span>
            <span class="n">sx</span> <span class="o">=</span> <span class="n">ngff_image_to_save</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">sy</span> <span class="o">=</span> <span class="n">ngff_image_to_save</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">sz</span> <span class="o">=</span> <span class="n">ngff_image_to_save</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">sx</span> <span class="o">=</span> <span class="n">sy</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Calculate extents (physical coordinates)</span>
        <span class="n">ext_x</span> <span class="o">=</span> <span class="n">sx</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">ext_y</span> <span class="o">=</span> <span class="n">sy</span> <span class="o">*</span> <span class="n">y</span>
        <span class="n">ext_z</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">*</span> <span class="n">z</span>

        <span class="c1"># Create comprehensive DataSetInfo structure matching reference</span>
        <span class="n">info_group</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;DataSetInfo&quot;</span><span class="p">)</span>

        <span class="c1"># Create channel info groups</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_channels</span><span class="p">):</span>
            <span class="n">channel_info</span> <span class="o">=</span> <span class="n">info_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Essential channel attributes in byte array format</span>
            <span class="n">channel_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span>
                <span class="s2">&quot;1.000 0.000 0.000&quot;</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;0.000 </span><span class="si">{</span><span class="mf">1.0</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mf">0.0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="mf">1.0</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mf">0.0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">channel_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">channel_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ColorMode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;BaseColor&quot;</span><span class="p">)</span>
            <span class="n">channel_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ColorOpacity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;1.000&quot;</span><span class="p">)</span>
            <span class="n">channel_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ColorRange&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;0 255&quot;</span><span class="p">)</span>
            <span class="n">channel_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;GammaCorrection&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;1.000&quot;</span><span class="p">)</span>
            <span class="n">channel_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;LSMEmissionWavelength&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span>
                <span class="s2">&quot;500&quot;</span>
            <span class="p">)</span>
            <span class="n">channel_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;LSMExcitationWavelength&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span>
                <span class="s2">&quot;500&quot;</span>
            <span class="p">)</span>
            <span class="n">channel_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;LSMPhotons&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
            <span class="n">channel_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;LSMPinhole&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;0&quot;</span><span class="p">)</span>

            <span class="c1"># Add description</span>
            <span class="n">description</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Channel </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2"> created by ZarrNii&quot;</span>
            <span class="n">channel_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Description&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="n">description</span><span class="p">)</span>

        <span class="c1"># Create CRITICAL Image group with voxel size information (this was missing!)</span>
        <span class="n">image_info</span> <span class="o">=</span> <span class="n">info_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;Image&quot;</span><span class="p">)</span>

        <span class="c1"># Add essential image metadata with proper voxel size information</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Unit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;um&quot;</span><span class="p">)</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Noc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n_channels</span><span class="p">))</span>

        <span class="c1"># CRITICAL: Set proper physical extents that define voxel size</span>
        <span class="c1"># Imaris reads voxel size from these extent values</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ExtMin0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="o">-</span><span class="n">ext_x</span><span class="o">/</span><span class="mi">2</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ExtMax0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ext_x</span><span class="o">/</span><span class="mi">2</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ExtMin1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="o">-</span><span class="n">ext_y</span><span class="o">/</span><span class="mi">2</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ExtMax1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ext_y</span><span class="o">/</span><span class="mi">2</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ExtMin2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="o">-</span><span class="n">ext_z</span><span class="o">/</span><span class="mi">2</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ExtMax2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ext_z</span><span class="o">/</span><span class="mi">2</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Add device/acquisition metadata</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ManufactorString&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;ZarrNii&quot;</span><span class="p">)</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ManufactorType&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;Generic&quot;</span><span class="p">)</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;LensPower&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;NumericalAperture&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;RecordingDate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span>
            <span class="s2">&quot;2024-01-01 00:00:00.000&quot;</span>
        <span class="p">)</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Filename&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;ZarrNii Export&quot;</span><span class="p">)</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Compression&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;5794&quot;</span><span class="p">)</span>

        <span class="c1"># Add description</span>
        <span class="n">description</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Imaris file created by ZarrNii from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span><span class="si">}</span><span class="s2"> format data. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Original shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">darr</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">. Converted to Imaris format &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="n">n_channels</span><span class="si">}</span><span class="s2"> channel(s) and dimensions </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2">x</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">x</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Voxel size: </span><span class="si">{</span><span class="n">sx</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">sy</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">sz</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> um.&quot;</span>
        <span class="p">)</span>
        <span class="n">image_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Description&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="n">description</span><span class="p">)</span>

        <span class="c1"># Create Imaris metadata group</span>
        <span class="n">imaris_info</span> <span class="o">=</span> <span class="n">info_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;Imaris&quot;</span><span class="p">)</span>
        <span class="n">imaris_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;7.0&quot;</span><span class="p">)</span>
        <span class="n">imaris_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ThumbnailMode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;thumbnailMIP&quot;</span><span class="p">)</span>
        <span class="n">imaris_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;ThumbnailSize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;256&quot;</span><span class="p">)</span>

        <span class="c1"># Create ImarisDataSet metadata</span>
        <span class="n">dataset_info</span> <span class="o">=</span> <span class="n">info_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;ImarisDataSet&quot;</span><span class="p">)</span>
        <span class="n">dataset_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Creator&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;Imaris&quot;</span><span class="p">)</span>
        <span class="n">dataset_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;7.0&quot;</span><span class="p">)</span>
        <span class="n">dataset_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;NumberOfImages&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>

        <span class="c1"># Add version-specific groups as seen in reference</span>
        <span class="n">dataset_info_ver</span> <span class="o">=</span> <span class="n">info_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;ImarisDataSet       0.0.0&quot;</span><span class="p">)</span>
        <span class="n">dataset_info_ver</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;NumberOfImages&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
        <span class="n">dataset_info_ver2</span> <span class="o">=</span> <span class="n">info_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;ImarisDataSet      0.0.0&quot;</span><span class="p">)</span>
        <span class="n">dataset_info_ver2</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;NumberOfImages&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>

        <span class="c1"># Create TimeInfo group</span>
        <span class="n">time_info</span> <span class="o">=</span> <span class="n">info_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;TimeInfo&quot;</span><span class="p">)</span>
        <span class="n">time_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;DatasetTimePoints&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
        <span class="n">time_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;FileTimePoints&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
        <span class="n">time_info</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;TimePoint1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span>
            <span class="s2">&quot;2024-01-01 00:00:00.000&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Create Log group (basic processing log)</span>
        <span class="n">log_group</span> <span class="o">=</span> <span class="n">info_group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;Log&quot;</span><span class="p">)</span>
        <span class="n">log_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Entries&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
        <span class="n">log_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Entry0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_string_to_byte_array</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&lt;ZarrNiiExport channels=</span><span class="se">\&quot;</span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;on&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_channels</span><span class="p">)</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2">/&gt;&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Create thumbnail group with proper multi-channel thumbnail</span>
        <span class="n">thumbnail_group</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;Thumbnail&quot;</span><span class="p">)</span>

        <span class="c1"># Create a combined thumbnail (256x1024 for multi-channel as in reference)</span>
        <span class="k">if</span> <span class="n">n_channels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Multi-channel thumbnail: concatenate channels horizontally</span>
            <span class="n">thumb_width</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">*</span> <span class="n">n_channels</span>
            <span class="n">thumbnail_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">256</span><span class="p">,</span> <span class="n">thumb_width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_channels</span><span class="p">):</span>
                <span class="c1"># Downsample each channel to 256x256</span>
                <span class="n">channel_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                <span class="c1"># Take MIP (Maximum Intensity Projection) along Z</span>
                <span class="n">mip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">channel_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># Resize to 256x256 (simple decimation)</span>
                <span class="n">step_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mip</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">256</span><span class="p">)</span>
                <span class="n">step_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mip</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">256</span><span class="p">)</span>
                <span class="n">thumb_channel</span> <span class="o">=</span> <span class="n">mip</span><span class="p">[::</span><span class="n">step_y</span><span class="p">,</span> <span class="p">::</span><span class="n">step_x</span><span class="p">]</span>

                <span class="c1"># Pad or crop to exactly 256x256</span>
                <span class="k">if</span> <span class="n">thumb_channel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">256</span> <span class="ow">or</span> <span class="n">thumb_channel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">:</span>
                    <span class="n">padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">thumb_channel</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">thumb_channel</span><span class="o">.</span><span class="n">shape</span>
                    <span class="n">padded</span><span class="p">[:</span><span class="n">h</span><span class="p">,</span> <span class="p">:</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">thumb_channel</span>
                    <span class="n">thumb_channel</span> <span class="o">=</span> <span class="n">padded</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">thumb_channel</span> <span class="o">=</span> <span class="n">thumb_channel</span><span class="p">[:</span><span class="mi">256</span><span class="p">,</span> <span class="p">:</span><span class="mi">256</span><span class="p">]</span>

                <span class="c1"># Place in thumbnail</span>
                <span class="n">thumbnail_data</span><span class="p">[:,</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">256</span> <span class="p">:</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="n">thumb_channel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Single channel: 256x256 thumbnail</span>
            <span class="n">channel_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">channel_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">step_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mip</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">256</span><span class="p">)</span>
            <span class="n">step_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mip</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">256</span><span class="p">)</span>
            <span class="n">thumbnail_data</span> <span class="o">=</span> <span class="n">mip</span><span class="p">[::</span><span class="n">step_y</span><span class="p">,</span> <span class="p">::</span><span class="n">step_x</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">thumbnail_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">256</span> <span class="ow">or</span> <span class="n">thumbnail_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">:</span>
                <span class="n">padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">thumbnail_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">thumbnail_data</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">padded</span><span class="p">[:</span><span class="n">h</span><span class="p">,</span> <span class="p">:</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">thumbnail_data</span>
                <span class="n">thumbnail_data</span> <span class="o">=</span> <span class="n">padded</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thumbnail_data</span> <span class="o">=</span> <span class="n">thumbnail_data</span><span class="p">[:</span><span class="mi">256</span><span class="p">,</span> <span class="p">:</span><span class="mi">256</span><span class="p">]</span>

        <span class="n">thumbnail_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;Data&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">thumbnail_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">path</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.copy" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Create a copy of this ZarrNii.</p>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>New ZarrNii with copied data</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4265</span>
<span class="normal">4266</span>
<span class="normal">4267</span>
<span class="normal">4268</span>
<span class="normal">4269</span>
<span class="normal">4270</span>
<span class="normal">4271</span>
<span class="normal">4272</span>
<span class="normal">4273</span>
<span class="normal">4274</span>
<span class="normal">4275</span>
<span class="normal">4276</span>
<span class="normal">4277</span>
<span class="normal">4278</span>
<span class="normal">4279</span>
<span class="normal">4280</span>
<span class="normal">4281</span>
<span class="normal">4282</span>
<span class="normal">4283</span>
<span class="normal">4284</span>
<span class="normal">4285</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a copy of this ZarrNii.</span>

<span class="sd">    Returns:</span>
<span class="sd">        New ZarrNii with copied data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a new NgffImage with the same properties</span>
    <span class="n">copied_image</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>  <span class="c1"># Dask arrays are lazy so this is efficient</span>
        <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">translation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">ZarrNii</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">copied_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">_omero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_omero</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.compute" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute the dask array and return the underlying NgffImage.</p>
<p>This triggers computation of any lazy operations and returns
the NgffImage with computed data.</p>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ngff_zarr.NgffImage">NgffImage</span></code>
          
          <div class="doc-md-description">
            <p>NgffImage with computed data</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4287</span>
<span class="normal">4288</span>
<span class="normal">4289</span>
<span class="normal">4290</span>
<span class="normal">4291</span>
<span class="normal">4292</span>
<span class="normal">4293</span>
<span class="normal">4294</span>
<span class="normal">4295</span>
<span class="normal">4296</span>
<span class="normal">4297</span>
<span class="normal">4298</span>
<span class="normal">4299</span>
<span class="normal">4300</span>
<span class="normal">4301</span>
<span class="normal">4302</span>
<span class="normal">4303</span>
<span class="normal">4304</span>
<span class="normal">4305</span>
<span class="normal">4306</span>
<span class="normal">4307</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the dask array and return the underlying NgffImage.</span>

<span class="sd">    This triggers computation of any lazy operations and returns</span>
<span class="sd">    the NgffImage with computed data.</span>

<span class="sd">    Returns:</span>
<span class="sd">        NgffImage with computed data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">computed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

    <span class="c1"># Create new NgffImage with computed data</span>
    <span class="n">computed_image</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">computed_data</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">translation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">translation</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">computed_image</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.get_orientation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">get_orientation</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Get the anatomical orientation of the dataset.</p>
<p>This function returns the orientation string (e.g., 'RAS', 'LPI') of the dataset.</p>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>str</code></b> (              <code><span title="str">str</span></code>
)          
          <div class="doc-md-description">
            <p>The orientation string corresponding to the dataset's anatomical orientation.</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4309</span>
<span class="normal">4310</span>
<span class="normal">4311</span>
<span class="normal">4312</span>
<span class="normal">4313</span>
<span class="normal">4314</span>
<span class="normal">4315</span>
<span class="normal">4316</span>
<span class="normal">4317</span>
<span class="normal">4318</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the anatomical orientation of the dataset.</span>

<span class="sd">    This function returns the orientation string (e.g., &#39;RAS&#39;, &#39;LPI&#39;) of the dataset.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The orientation string corresponding to the dataset&#39;s anatomical orientation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.get_zooms" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">get_zooms</span><span class="p">(</span><span class="n">axes_order</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Get voxel spacing (zooms) from NgffImage scale.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>axes_order</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Spatial axes order, defaults to self.axes_order</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="numpy.ndarray">ndarray</span></code>
          
          <div class="doc-md-description">
            <p>Array of voxel spacings</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4320</span>
<span class="normal">4321</span>
<span class="normal">4322</span>
<span class="normal">4323</span>
<span class="normal">4324</span>
<span class="normal">4325</span>
<span class="normal">4326</span>
<span class="normal">4327</span>
<span class="normal">4328</span>
<span class="normal">4329</span>
<span class="normal">4330</span>
<span class="normal">4331</span>
<span class="normal">4332</span>
<span class="normal">4333</span>
<span class="normal">4334</span>
<span class="normal">4335</span>
<span class="normal">4336</span>
<span class="normal">4337</span>
<span class="normal">4338</span>
<span class="normal">4339</span>
<span class="normal">4340</span>
<span class="normal">4341</span>
<span class="normal">4342</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_zooms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes_order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get voxel spacing (zooms) from NgffImage scale.</span>

<span class="sd">    Args:</span>
<span class="sd">        axes_order: Spatial axes order, defaults to self.axes_order</span>

<span class="sd">    Returns:</span>
<span class="sd">        Array of voxel spacings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axes_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axes_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span>

    <span class="n">spatial_dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>
    <span class="n">zooms</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">spatial_dims</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">scale</span><span class="p">:</span>
            <span class="n">zooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zooms</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.get_origin" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">get_origin</span><span class="p">(</span><span class="n">axes_order</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Get origin (translation) from NgffImage.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>axes_order</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Spatial axes order, defaults to self.axes_order</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="numpy.ndarray">ndarray</span></code>
          
          <div class="doc-md-description">
            <p>Array of origin coordinates</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4344</span>
<span class="normal">4345</span>
<span class="normal">4346</span>
<span class="normal">4347</span>
<span class="normal">4348</span>
<span class="normal">4349</span>
<span class="normal">4350</span>
<span class="normal">4351</span>
<span class="normal">4352</span>
<span class="normal">4353</span>
<span class="normal">4354</span>
<span class="normal">4355</span>
<span class="normal">4356</span>
<span class="normal">4357</span>
<span class="normal">4358</span>
<span class="normal">4359</span>
<span class="normal">4360</span>
<span class="normal">4361</span>
<span class="normal">4362</span>
<span class="normal">4363</span>
<span class="normal">4364</span>
<span class="normal">4365</span>
<span class="normal">4366</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes_order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get origin (translation) from NgffImage.</span>

<span class="sd">    Args:</span>
<span class="sd">        axes_order: Spatial axes order, defaults to self.axes_order</span>

<span class="sd">    Returns:</span>
<span class="sd">        Array of origin coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axes_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axes_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span>

    <span class="n">spatial_dims</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">spatial_dims</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">translation</span><span class="p">:</span>
            <span class="n">origin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">translation</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">origin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.get_affine_matrix" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">get_affine_matrix</span><span class="p">(</span><span class="n">axes_order</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Construct a 4x4 affine matrix from NGFF metadata (scale/translation),
and align it to self.orientation (if provided) using nibabel.orientations.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>axes_order</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Spatial axes order, e.g. 'ZYX' or 'XYZ'. Defaults to 'XYZ'.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="numpy.ndarray">ndarray</span></code>
          
          <div class="doc-md-description">
            <p>np.ndarray: 4x4 affine matrix.</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4368</span>
<span class="normal">4369</span>
<span class="normal">4370</span>
<span class="normal">4371</span>
<span class="normal">4372</span>
<span class="normal">4373</span>
<span class="normal">4374</span>
<span class="normal">4375</span>
<span class="normal">4376</span>
<span class="normal">4377</span>
<span class="normal">4378</span>
<span class="normal">4379</span>
<span class="normal">4380</span>
<span class="normal">4381</span>
<span class="normal">4382</span>
<span class="normal">4383</span>
<span class="normal">4384</span>
<span class="normal">4385</span>
<span class="normal">4386</span>
<span class="normal">4387</span>
<span class="normal">4388</span>
<span class="normal">4389</span>
<span class="normal">4390</span>
<span class="normal">4391</span>
<span class="normal">4392</span>
<span class="normal">4393</span>
<span class="normal">4394</span>
<span class="normal">4395</span>
<span class="normal">4396</span>
<span class="normal">4397</span>
<span class="normal">4398</span>
<span class="normal">4399</span>
<span class="normal">4400</span>
<span class="normal">4401</span>
<span class="normal">4402</span>
<span class="normal">4403</span>
<span class="normal">4404</span>
<span class="normal">4405</span>
<span class="normal">4406</span>
<span class="normal">4407</span>
<span class="normal">4408</span>
<span class="normal">4409</span>
<span class="normal">4410</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_affine_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes_order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a 4x4 affine matrix from NGFF metadata (scale/translation),</span>
<span class="sd">    and align it to self.orientation (if provided) using nibabel.orientations.</span>

<span class="sd">    Args:</span>
<span class="sd">        axes_order: Spatial axes order, e.g. &#39;ZYX&#39; or &#39;XYZ&#39;. Defaults to &#39;XYZ&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: 4x4 affine matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axes_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axes_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span>

    <span class="k">if</span> <span class="n">axes_order</span> <span class="o">==</span> <span class="s2">&quot;ZYX&quot;</span><span class="p">:</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="n">reverse_orientation_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span>

    <span class="c1"># Safely pull scale/translation from metadata (dict-like expected)</span>
    <span class="n">scale_meta</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="p">{})</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">trans_meta</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ngff_image</span><span class="p">,</span> <span class="s2">&quot;translation&quot;</span><span class="p">,</span> <span class="p">{})</span> <span class="ow">or</span> <span class="p">{}</span>

    <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
        <span class="mi">3</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="mi">3</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes_order</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">scale_meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes_order</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">trans_meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="n">affine</span> <span class="o">=</span> <span class="n">_axcodes2aff</span><span class="p">(</span><span class="n">orientation</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">translate</span><span class="o">=</span><span class="n">trans</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">affine</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.apply_transform_ref_to_flo_indices" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">apply_transform_ref_to_flo_indices</span><span class="p">(</span><span class="o">*</span><span class="n">transforms</span><span class="p">,</span> <span class="n">ref_znimg</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Transform indices from reference to floating space.</p>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4412</span>
<span class="normal">4413</span>
<span class="normal">4414</span>
<span class="normal">4415</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apply_transform_ref_to_flo_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">transforms</span><span class="p">,</span> <span class="n">ref_znimg</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform indices from reference to floating space.&quot;&quot;&quot;</span>
    <span class="c1"># Placeholder implementation - would need full transform logic</span>
    <span class="k">return</span> <span class="n">indices</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.apply_transform_flo_to_ref_indices" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">apply_transform_flo_to_ref_indices</span><span class="p">(</span><span class="o">*</span><span class="n">transforms</span><span class="p">,</span> <span class="n">ref_znimg</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Transform indices from floating to reference space.</p>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4417</span>
<span class="normal">4418</span>
<span class="normal">4419</span>
<span class="normal">4420</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apply_transform_flo_to_ref_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">transforms</span><span class="p">,</span> <span class="n">ref_znimg</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform indices from floating to reference space.&quot;&quot;&quot;</span>
    <span class="c1"># Placeholder implementation - would need full transform logic</span>
    <span class="k">return</span> <span class="n">indices</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.list_channels" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">list_channels</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Get list of available channel labels from OMERO metadata.</p>
<p>Extracts channel labels from OMERO metadata if available, providing
human-readable names for multi-channel datasets.</p>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="typing.List">List</span>[<span title="str">str</span>]</code>
          
          <div class="doc-md-description">
            <p>List of channel label strings. Empty list if no OMERO metadata</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.List">List</span>[<span title="str">str</span>]</code>
          
          <div class="doc-md-description">
            <p>is available or no channels are defined.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check available channels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">list_channels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Available channels: </span><span class="si">{</span><span class="n">labels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># [&#39;DAPI&#39;, &#39;GFP&#39;, &#39;RFP&#39;, &#39;Cy5&#39;]</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Select specific channels by label</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">selected</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">select_channels</span><span class="p">(</span><span class="n">channel_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;DAPI&#39;</span><span class="p">,</span> <span class="s1">&#39;GFP&#39;</span><span class="p">])</span>
</code></pre></div>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Requires OMERO metadata to be present in the dataset</li>
<li>Returns empty list for datasets without channel metadata</li>
<li>Labels are extracted from the 'label' field of each channel</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4422</span>
<span class="normal">4423</span>
<span class="normal">4424</span>
<span class="normal">4425</span>
<span class="normal">4426</span>
<span class="normal">4427</span>
<span class="normal">4428</span>
<span class="normal">4429</span>
<span class="normal">4430</span>
<span class="normal">4431</span>
<span class="normal">4432</span>
<span class="normal">4433</span>
<span class="normal">4434</span>
<span class="normal">4435</span>
<span class="normal">4436</span>
<span class="normal">4437</span>
<span class="normal">4438</span>
<span class="normal">4439</span>
<span class="normal">4440</span>
<span class="normal">4441</span>
<span class="normal">4442</span>
<span class="normal">4443</span>
<span class="normal">4444</span>
<span class="normal">4445</span>
<span class="normal">4446</span>
<span class="normal">4447</span>
<span class="normal">4448</span>
<span class="normal">4449</span>
<span class="normal">4450</span>
<span class="normal">4451</span>
<span class="normal">4452</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">list_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get list of available channel labels from OMERO metadata.</span>

<span class="sd">    Extracts channel labels from OMERO metadata if available, providing</span>
<span class="sd">    human-readable names for multi-channel datasets.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of channel label strings. Empty list if no OMERO metadata</span>
<span class="sd">        is available or no channels are defined.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Check available channels</span>
<span class="sd">        &gt;&gt;&gt; labels = znii.list_channels()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Available channels: {labels}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # [&#39;DAPI&#39;, &#39;GFP&#39;, &#39;RFP&#39;, &#39;Cy5&#39;]</span>

<span class="sd">        &gt;&gt;&gt; # Select specific channels by label</span>
<span class="sd">        &gt;&gt;&gt; selected = znii.select_channels(channel_labels=[&#39;DAPI&#39;, &#39;GFP&#39;])</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Requires OMERO metadata to be present in the dataset</span>
<span class="sd">        - Returns empty list for datasets without channel metadata</span>
<span class="sd">        - Labels are extracted from the &#39;label&#39; field of each channel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omero</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omero</span><span class="p">,</span> <span class="s2">&quot;channels&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="p">[</span>
        <span class="n">ch</span><span class="o">.</span><span class="n">label</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">ch</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">omero</span><span class="o">.</span><span class="n">channels</span>
    <span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.select_channels" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">select_channels</span><span class="p">(</span><span class="n">channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Select specific channels from multi-channel image data.</p>
<p>Creates a new ZarrNii instance containing only the specified channels,
reducing memory usage and focusing analysis on channels of interest.
Supports selection by both numeric indices and human-readable labels.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>channels</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="int">int</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>List of 0-based channel indices to select.
Mutually exclusive with channel_labels</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>channel_labels</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="str">str</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>List of channel names to select by label.
Requires OMERO metadata. Mutually exclusive with channels</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>New ZarrNii instance with selected channels and updated metadata</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If both channels and channel_labels specified, or if
channel_labels used without OMERO metadata, or if labels not found</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="IndexError">IndexError</span></code>
            
          <div class="doc-md-description">
            <p>If channel indices are out of range</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Select channels by index</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">selected</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">select_channels</span><span class="p">(</span><span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Select channels by label (requires OMERO metadata)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">selected</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">select_channels</span><span class="p">(</span><span class="n">channel_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;DAPI&#39;</span><span class="p">,</span> <span class="s1">&#39;GFP&#39;</span><span class="p">])</span>
</code></pre></div>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check available labels first</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">available</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">list_channels</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Available: </span><span class="si">{</span><span class="n">available</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">selected</span> <span class="o">=</span> <span class="n">znii</span><span class="o">.</span><span class="n">select_channels</span><span class="p">(</span><span class="n">channel_labels</span><span class="o">=</span><span class="n">available</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
</code></pre></div>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Preserves all spatial dimensions and timepoints</li>
<li>Updates OMERO metadata to reflect selected channels</li>
<li>Maintains spatial transformations and other metadata</li>
<li>Channel order in output matches selection order</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4454</span>
<span class="normal">4455</span>
<span class="normal">4456</span>
<span class="normal">4457</span>
<span class="normal">4458</span>
<span class="normal">4459</span>
<span class="normal">4460</span>
<span class="normal">4461</span>
<span class="normal">4462</span>
<span class="normal">4463</span>
<span class="normal">4464</span>
<span class="normal">4465</span>
<span class="normal">4466</span>
<span class="normal">4467</span>
<span class="normal">4468</span>
<span class="normal">4469</span>
<span class="normal">4470</span>
<span class="normal">4471</span>
<span class="normal">4472</span>
<span class="normal">4473</span>
<span class="normal">4474</span>
<span class="normal">4475</span>
<span class="normal">4476</span>
<span class="normal">4477</span>
<span class="normal">4478</span>
<span class="normal">4479</span>
<span class="normal">4480</span>
<span class="normal">4481</span>
<span class="normal">4482</span>
<span class="normal">4483</span>
<span class="normal">4484</span>
<span class="normal">4485</span>
<span class="normal">4486</span>
<span class="normal">4487</span>
<span class="normal">4488</span>
<span class="normal">4489</span>
<span class="normal">4490</span>
<span class="normal">4491</span>
<span class="normal">4492</span>
<span class="normal">4493</span>
<span class="normal">4494</span>
<span class="normal">4495</span>
<span class="normal">4496</span>
<span class="normal">4497</span>
<span class="normal">4498</span>
<span class="normal">4499</span>
<span class="normal">4500</span>
<span class="normal">4501</span>
<span class="normal">4502</span>
<span class="normal">4503</span>
<span class="normal">4504</span>
<span class="normal">4505</span>
<span class="normal">4506</span>
<span class="normal">4507</span>
<span class="normal">4508</span>
<span class="normal">4509</span>
<span class="normal">4510</span>
<span class="normal">4511</span>
<span class="normal">4512</span>
<span class="normal">4513</span>
<span class="normal">4514</span>
<span class="normal">4515</span>
<span class="normal">4516</span>
<span class="normal">4517</span>
<span class="normal">4518</span>
<span class="normal">4519</span>
<span class="normal">4520</span>
<span class="normal">4521</span>
<span class="normal">4522</span>
<span class="normal">4523</span>
<span class="normal">4524</span>
<span class="normal">4525</span>
<span class="normal">4526</span>
<span class="normal">4527</span>
<span class="normal">4528</span>
<span class="normal">4529</span>
<span class="normal">4530</span>
<span class="normal">4531</span>
<span class="normal">4532</span>
<span class="normal">4533</span>
<span class="normal">4534</span>
<span class="normal">4535</span>
<span class="normal">4536</span>
<span class="normal">4537</span>
<span class="normal">4538</span>
<span class="normal">4539</span>
<span class="normal">4540</span>
<span class="normal">4541</span>
<span class="normal">4542</span>
<span class="normal">4543</span>
<span class="normal">4544</span>
<span class="normal">4545</span>
<span class="normal">4546</span>
<span class="normal">4547</span>
<span class="normal">4548</span>
<span class="normal">4549</span>
<span class="normal">4550</span>
<span class="normal">4551</span>
<span class="normal">4552</span>
<span class="normal">4553</span>
<span class="normal">4554</span>
<span class="normal">4555</span>
<span class="normal">4556</span>
<span class="normal">4557</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">select_channels</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">channels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">channel_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Select specific channels from multi-channel image data.</span>

<span class="sd">    Creates a new ZarrNii instance containing only the specified channels,</span>
<span class="sd">    reducing memory usage and focusing analysis on channels of interest.</span>
<span class="sd">    Supports selection by both numeric indices and human-readable labels.</span>

<span class="sd">    Args:</span>
<span class="sd">        channels: List of 0-based channel indices to select.</span>
<span class="sd">            Mutually exclusive with channel_labels</span>
<span class="sd">        channel_labels: List of channel names to select by label.</span>
<span class="sd">            Requires OMERO metadata. Mutually exclusive with channels</span>

<span class="sd">    Returns:</span>
<span class="sd">        New ZarrNii instance with selected channels and updated metadata</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If both channels and channel_labels specified, or if</span>
<span class="sd">            channel_labels used without OMERO metadata, or if labels not found</span>
<span class="sd">        IndexError: If channel indices are out of range</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Select channels by index</span>
<span class="sd">        &gt;&gt;&gt; selected = znii.select_channels(channels=[0, 2])</span>

<span class="sd">        &gt;&gt;&gt; # Select channels by label (requires OMERO metadata)</span>
<span class="sd">        &gt;&gt;&gt; selected = znii.select_channels(channel_labels=[&#39;DAPI&#39;, &#39;GFP&#39;])</span>

<span class="sd">        &gt;&gt;&gt; # Check available labels first</span>
<span class="sd">        &gt;&gt;&gt; available = znii.list_channels()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Available: {available}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; selected = znii.select_channels(channel_labels=available[:2])</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Preserves all spatial dimensions and timepoints</span>
<span class="sd">        - Updates OMERO metadata to reflect selected channels</span>
<span class="sd">        - Maintains spatial transformations and other metadata</span>
<span class="sd">        - Channel order in output matches selection order</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">channel_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both &#39;channels&#39; and &#39;channel_labels&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">channel_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omero</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Channel labels were specified but no omero metadata found&quot;</span>
            <span class="p">)</span>

        <span class="n">available_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_channels</span><span class="p">()</span>
        <span class="n">channel_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">channel_labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">available_labels</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Channel label &#39;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&#39; not found&quot;</span><span class="p">)</span>
            <span class="n">channel_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">available_labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="n">channel_indices</span>

    <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Return a copy with all channels</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Check if channel dimension exists</span>
    <span class="k">if</span> <span class="s2">&quot;c&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No channel dimension found in the data&quot;</span><span class="p">)</span>

    <span class="c1"># Get channel dimension index</span>
    <span class="n">c_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>

    <span class="c1"># Create slice objects for proper dimension indexing</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">slices</span><span class="p">[</span><span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">channels</span>

    <span class="c1"># Select channels from data using proper dimension indexing</span>
    <span class="n">selected_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span>

    <span class="c1"># Create new NgffImage with selected data</span>
    <span class="n">new_ngff_image</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">selected_data</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">translation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Filter omero metadata to match selected channels</span>
    <span class="n">filtered_omero</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omero</span><span class="p">,</span> <span class="s2">&quot;channels&quot;</span><span class="p">):</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">FilteredOmero</span><span class="p">:</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>

        <span class="n">filtered_channels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">omero</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">]</span>
        <span class="n">filtered_omero</span> <span class="o">=</span> <span class="n">FilteredOmero</span><span class="p">(</span><span class="n">filtered_channels</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ZarrNii</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">new_ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">_omero</span><span class="o">=</span><span class="n">filtered_omero</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.select_timepoints" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">select_timepoints</span><span class="p">(</span><span class="n">timepoints</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Select timepoints from the image data and return a new ZarrNii instance.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>timepoints</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="int">int</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Timepoint indices to select</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>New ZarrNii instance with selected timepoints</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4559</span>
<span class="normal">4560</span>
<span class="normal">4561</span>
<span class="normal">4562</span>
<span class="normal">4563</span>
<span class="normal">4564</span>
<span class="normal">4565</span>
<span class="normal">4566</span>
<span class="normal">4567</span>
<span class="normal">4568</span>
<span class="normal">4569</span>
<span class="normal">4570</span>
<span class="normal">4571</span>
<span class="normal">4572</span>
<span class="normal">4573</span>
<span class="normal">4574</span>
<span class="normal">4575</span>
<span class="normal">4576</span>
<span class="normal">4577</span>
<span class="normal">4578</span>
<span class="normal">4579</span>
<span class="normal">4580</span>
<span class="normal">4581</span>
<span class="normal">4582</span>
<span class="normal">4583</span>
<span class="normal">4584</span>
<span class="normal">4585</span>
<span class="normal">4586</span>
<span class="normal">4587</span>
<span class="normal">4588</span>
<span class="normal">4589</span>
<span class="normal">4590</span>
<span class="normal">4591</span>
<span class="normal">4592</span>
<span class="normal">4593</span>
<span class="normal">4594</span>
<span class="normal">4595</span>
<span class="normal">4596</span>
<span class="normal">4597</span>
<span class="normal">4598</span>
<span class="normal">4599</span>
<span class="normal">4600</span>
<span class="normal">4601</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">select_timepoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timepoints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select timepoints from the image data and return a new ZarrNii instance.</span>

<span class="sd">    Args:</span>
<span class="sd">        timepoints: Timepoint indices to select</span>

<span class="sd">    Returns:</span>
<span class="sd">        New ZarrNii instance with selected timepoints</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">timepoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Return a copy with all timepoints</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Check if time dimension exists</span>
    <span class="k">if</span> <span class="s2">&quot;t&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No time dimension found in the data&quot;</span><span class="p">)</span>

    <span class="c1"># Get time dimension index</span>
    <span class="n">t_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>

    <span class="c1"># Create slice objects</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">slices</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">timepoints</span>

    <span class="c1"># Select timepoints from data</span>
    <span class="n">selected_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span>

    <span class="c1"># Create new NgffImage with selected data</span>
    <span class="n">new_ngff_image</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">selected_data</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">translation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ZarrNii</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">new_ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">_omero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_omero</span><span class="p">,</span>  <span class="c1"># Timepoint selection doesn&#39;t affect omero metadata</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.to_ngff_image" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">to_ngff_image</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Convert to NgffImage object.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>name</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional name for the image</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ngff_zarr.NgffImage">NgffImage</span></code>
          
          <div class="doc-md-description">
            <p>NgffImage representation</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4603</span>
<span class="normal">4604</span>
<span class="normal">4605</span>
<span class="normal">4606</span>
<span class="normal">4607</span>
<span class="normal">4608</span>
<span class="normal">4609</span>
<span class="normal">4610</span>
<span class="normal">4611</span>
<span class="normal">4612</span>
<span class="normal">4613</span>
<span class="normal">4614</span>
<span class="normal">4615</span>
<span class="normal">4616</span>
<span class="normal">4617</span>
<span class="normal">4618</span>
<span class="normal">4619</span>
<span class="normal">4620</span>
<span class="normal">4621</span>
<span class="normal">4622</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">to_ngff_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert to NgffImage object.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: Optional name for the image</span>

<span class="sd">    Returns:</span>
<span class="sd">        NgffImage representation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">return</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">translation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.segment" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">plugin</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Apply segmentation plugin to the image using blockwise processing.</p>
<p>This method applies a segmentation plugin to the image data using dask's
blockwise processing for efficient computation on large datasets.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>plugin</code></b>
          
          <div class="doc-md-description">
            <p>Segmentation plugin instance or class to apply</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>chunk_size</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.Tuple">Tuple</span>[<span title="int">int</span>, ...]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional chunk size for dask processing. If None, uses current chunks.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>**kwargs</code></b>
          
          <div class="doc-md-description">
            <p>Additional arguments passed to the plugin</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>New ZarrNii instance with segmented data as labels</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4624</span>
<span class="normal">4625</span>
<span class="normal">4626</span>
<span class="normal">4627</span>
<span class="normal">4628</span>
<span class="normal">4629</span>
<span class="normal">4630</span>
<span class="normal">4631</span>
<span class="normal">4632</span>
<span class="normal">4633</span>
<span class="normal">4634</span>
<span class="normal">4635</span>
<span class="normal">4636</span>
<span class="normal">4637</span>
<span class="normal">4638</span>
<span class="normal">4639</span>
<span class="normal">4640</span>
<span class="normal">4641</span>
<span class="normal">4642</span>
<span class="normal">4643</span>
<span class="normal">4644</span>
<span class="normal">4645</span>
<span class="normal">4646</span>
<span class="normal">4647</span>
<span class="normal">4648</span>
<span class="normal">4649</span>
<span class="normal">4650</span>
<span class="normal">4651</span>
<span class="normal">4652</span>
<span class="normal">4653</span>
<span class="normal">4654</span>
<span class="normal">4655</span>
<span class="normal">4656</span>
<span class="normal">4657</span>
<span class="normal">4658</span>
<span class="normal">4659</span>
<span class="normal">4660</span>
<span class="normal">4661</span>
<span class="normal">4662</span>
<span class="normal">4663</span>
<span class="normal">4664</span>
<span class="normal">4665</span>
<span class="normal">4666</span>
<span class="normal">4667</span>
<span class="normal">4668</span>
<span class="normal">4669</span>
<span class="normal">4670</span>
<span class="normal">4671</span>
<span class="normal">4672</span>
<span class="normal">4673</span>
<span class="normal">4674</span>
<span class="normal">4675</span>
<span class="normal">4676</span>
<span class="normal">4677</span>
<span class="normal">4678</span>
<span class="normal">4679</span>
<span class="normal">4680</span>
<span class="normal">4681</span>
<span class="normal">4682</span>
<span class="normal">4683</span>
<span class="normal">4684</span>
<span class="normal">4685</span>
<span class="normal">4686</span>
<span class="normal">4687</span>
<span class="normal">4688</span>
<span class="normal">4689</span>
<span class="normal">4690</span>
<span class="normal">4691</span>
<span class="normal">4692</span>
<span class="normal">4693</span>
<span class="normal">4694</span>
<span class="normal">4695</span>
<span class="normal">4696</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">segment</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">plugin</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply segmentation plugin to the image using blockwise processing.</span>

<span class="sd">    This method applies a segmentation plugin to the image data using dask&#39;s</span>
<span class="sd">    blockwise processing for efficient computation on large datasets.</span>

<span class="sd">    Args:</span>
<span class="sd">        plugin: Segmentation plugin instance or class to apply</span>
<span class="sd">        chunk_size: Optional chunk size for dask processing. If None, uses current chunks.</span>
<span class="sd">        **kwargs: Additional arguments passed to the plugin</span>

<span class="sd">    Returns:</span>
<span class="sd">        New ZarrNii instance with segmented data as labels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.plugins.segmentation</span><span class="w"> </span><span class="kn">import</span> <span class="n">SegmentationPlugin</span>

    <span class="c1"># Handle plugin instance or class</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">plugin</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">plugin</span><span class="p">,</span> <span class="n">SegmentationPlugin</span><span class="p">):</span>
        <span class="n">plugin</span> <span class="o">=</span> <span class="n">plugin</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">plugin</span><span class="p">,</span> <span class="n">SegmentationPlugin</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Plugin must be an instance or subclass of SegmentationPlugin&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Prepare chunk size</span>
    <span class="k">if</span> <span class="n">chunk_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Rechunk the data if different chunk size requested</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rechunk</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

    <span class="c1"># Create metadata dict to pass to plugin</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;axes_order&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="s2">&quot;orientation&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="s2">&quot;dims&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
        <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
        <span class="s2">&quot;translation&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Create a wrapper function for map_blocks</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">segment_block</span><span class="p">(</span><span class="n">block</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrapper function to apply segmentation to a single block.&quot;&quot;&quot;</span>
        <span class="c1"># Handle single blocks</span>
        <span class="k">return</span> <span class="n">plugin</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>

    <span class="c1"># Apply segmentation using dask map_blocks</span>
    <span class="n">segmented_data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span>
        <span class="n">segment_block</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>  <span class="c1"># Segmentation results are typically uint8</span>
        <span class="n">meta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span>  <span class="c1"># Provide meta information</span>
    <span class="p">)</span>

    <span class="c1"># Create new NgffImage with segmented data</span>
    <span class="n">new_ngff_image</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">segmented_data</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">translation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_segmented_</span><span class="si">{</span><span class="n">plugin</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Return new ZarrNii instance</span>
    <span class="k">return</span> <span class="n">ZarrNii</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">new_ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.segment_otsu" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">segment_otsu</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Apply local Otsu thresholding segmentation to the image.</p>
<p>Convenience method for local Otsu thresholding segmentation.
This computes the threshold locally for each processing block.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>nbins</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>256</code>
)
          
          <div class="doc-md-description">
            <p>Number of bins for histogram computation (default: 256)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>chunk_size</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.Tuple">Tuple</span>[<span title="int">int</span>, ...]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional chunk size for dask processing</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>New ZarrNii instance with binary segmentation</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4698</span>
<span class="normal">4699</span>
<span class="normal">4700</span>
<span class="normal">4701</span>
<span class="normal">4702</span>
<span class="normal">4703</span>
<span class="normal">4704</span>
<span class="normal">4705</span>
<span class="normal">4706</span>
<span class="normal">4707</span>
<span class="normal">4708</span>
<span class="normal">4709</span>
<span class="normal">4710</span>
<span class="normal">4711</span>
<span class="normal">4712</span>
<span class="normal">4713</span>
<span class="normal">4714</span>
<span class="normal">4715</span>
<span class="normal">4716</span>
<span class="normal">4717</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">segment_otsu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">nbins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply local Otsu thresholding segmentation to the image.</span>

<span class="sd">    Convenience method for local Otsu thresholding segmentation.</span>
<span class="sd">    This computes the threshold locally for each processing block.</span>

<span class="sd">    Args:</span>
<span class="sd">        nbins: Number of bins for histogram computation (default: 256)</span>
<span class="sd">        chunk_size: Optional chunk size for dask processing</span>

<span class="sd">    Returns:</span>
<span class="sd">        New ZarrNii instance with binary segmentation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.plugins.segmentation</span><span class="w"> </span><span class="kn">import</span> <span class="n">LocalOtsuSegmentation</span>

    <span class="n">plugin</span> <span class="o">=</span> <span class="n">LocalOtsuSegmentation</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="n">nbins</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">plugin</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.segment_threshold" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">segment_threshold</span><span class="p">(</span><span class="n">thresholds</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Apply threshold-based segmentation to the image.</p>
<p>Convenience method for threshold-based segmentation using either
manual threshold values or computed thresholds.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>thresholds</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="float">float</span>, <span title="typing.List">List</span>[<span title="float">float</span>]]</code>)
          
          <div class="doc-md-description">
            <p>Single threshold value or list of threshold values.
For single threshold, creates binary segmentation (0/1).
For multiple thresholds, creates multi-class segmentation (0/1/2/...).</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>inclusive</code></b>
              (<code><span title="bool">bool</span></code>, default:
                  <code>True</code>
)
          
          <div class="doc-md-description">
            <p>Whether thresholds are inclusive (default: True).
If True, pixels &gt;= threshold are labeled as foreground.
If False, pixels &gt; threshold are labeled as foreground.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>chunk_size</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.Tuple">Tuple</span>[<span title="int">int</span>, ...]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional chunk size for dask processing</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>New ZarrNii instance with labeled segmentation</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Binary threshold segmentation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmented</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">segment_threshold</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Multi-level threshold segmentation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresholds</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">compute_otsu_thresholds</span><span class="p">(</span><span class="n">classes</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segmented</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">segment_threshold</span><span class="p">(</span><span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Exclude min/max values</span>
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4719</span>
<span class="normal">4720</span>
<span class="normal">4721</span>
<span class="normal">4722</span>
<span class="normal">4723</span>
<span class="normal">4724</span>
<span class="normal">4725</span>
<span class="normal">4726</span>
<span class="normal">4727</span>
<span class="normal">4728</span>
<span class="normal">4729</span>
<span class="normal">4730</span>
<span class="normal">4731</span>
<span class="normal">4732</span>
<span class="normal">4733</span>
<span class="normal">4734</span>
<span class="normal">4735</span>
<span class="normal">4736</span>
<span class="normal">4737</span>
<span class="normal">4738</span>
<span class="normal">4739</span>
<span class="normal">4740</span>
<span class="normal">4741</span>
<span class="normal">4742</span>
<span class="normal">4743</span>
<span class="normal">4744</span>
<span class="normal">4745</span>
<span class="normal">4746</span>
<span class="normal">4747</span>
<span class="normal">4748</span>
<span class="normal">4749</span>
<span class="normal">4750</span>
<span class="normal">4751</span>
<span class="normal">4752</span>
<span class="normal">4753</span>
<span class="normal">4754</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">segment_threshold</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">thresholds</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
    <span class="n">inclusive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">chunk_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply threshold-based segmentation to the image.</span>

<span class="sd">    Convenience method for threshold-based segmentation using either</span>
<span class="sd">    manual threshold values or computed thresholds.</span>

<span class="sd">    Args:</span>
<span class="sd">        thresholds: Single threshold value or list of threshold values.</span>
<span class="sd">            For single threshold, creates binary segmentation (0/1).</span>
<span class="sd">            For multiple thresholds, creates multi-class segmentation (0/1/2/...).</span>
<span class="sd">        inclusive: Whether thresholds are inclusive (default: True).</span>
<span class="sd">            If True, pixels &gt;= threshold are labeled as foreground.</span>
<span class="sd">            If False, pixels &gt; threshold are labeled as foreground.</span>
<span class="sd">        chunk_size: Optional chunk size for dask processing</span>

<span class="sd">    Returns:</span>
<span class="sd">        New ZarrNii instance with labeled segmentation</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Binary threshold segmentation</span>
<span class="sd">        &gt;&gt;&gt; segmented = znimg.segment_threshold(0.5)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Multi-level threshold segmentation</span>
<span class="sd">        &gt;&gt;&gt; thresholds = znimg.compute_otsu_thresholds(classes=3)</span>
<span class="sd">        &gt;&gt;&gt; segmented = znimg.segment_threshold(thresholds[1:-1])  # Exclude min/max values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.plugins.segmentation</span><span class="w"> </span><span class="kn">import</span> <span class="n">ThresholdSegmentation</span>

    <span class="n">plugin</span> <span class="o">=</span> <span class="n">ThresholdSegmentation</span><span class="p">(</span><span class="n">thresholds</span><span class="o">=</span><span class="n">thresholds</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="n">inclusive</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">plugin</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.compute_histogram" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">compute_histogram</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute histogram of the image.</p>
<p>This method computes the histogram of image intensities, optionally using
a mask to weight the computation. The histogram is computed using dask for
efficient processing of large datasets.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>bins</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>256</code>
)
          
          <div class="doc-md-description">
            <p>Number of histogram bins (default: 256)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>range</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional tuple (min, max) defining histogram range. If None,
uses the full range of the data</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>mask</code></b>
              (<code><span title="typing.Optional">Optional</span>[&#39;ZarrNii&#39;]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional ZarrNii mask of same shape as image. Only pixels
where mask &gt; 0 are included in histogram computation</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>**kwargs</code></b>
              (<code><span title="typing.Any">Any</span></code>, default:
                  <code>{}</code>
)
          
          <div class="doc-md-description">
            <p>Additional arguments passed to dask.array.histogram</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="dask.array.Array">Array</span></code>
          
          <div class="doc-md-description">
            <p>Tuple of (histogram_counts, bin_edges) where:</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="dask.array.Array">Array</span></code>
          
          <div class="doc-md-description">
            <ul>
<li>histogram_counts: dask array of histogram bin counts</li>
</ul>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.Tuple">Tuple</span>[<span title="dask.array.Array">Array</span>, <span title="dask.array.Array">Array</span>]</code>
          
          <div class="doc-md-description">
            <ul>
<li>bin_edges: dask array of bin edge values (length = bins + 1)</li>
</ul>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute histogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">compute_histogram</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute histogram with mask</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">znimg</span> <span class="o">&gt;</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hist_masked</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">compute_histogram</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4756</span>
<span class="normal">4757</span>
<span class="normal">4758</span>
<span class="normal">4759</span>
<span class="normal">4760</span>
<span class="normal">4761</span>
<span class="normal">4762</span>
<span class="normal">4763</span>
<span class="normal">4764</span>
<span class="normal">4765</span>
<span class="normal">4766</span>
<span class="normal">4767</span>
<span class="normal">4768</span>
<span class="normal">4769</span>
<span class="normal">4770</span>
<span class="normal">4771</span>
<span class="normal">4772</span>
<span class="normal">4773</span>
<span class="normal">4774</span>
<span class="normal">4775</span>
<span class="normal">4776</span>
<span class="normal">4777</span>
<span class="normal">4778</span>
<span class="normal">4779</span>
<span class="normal">4780</span>
<span class="normal">4781</span>
<span class="normal">4782</span>
<span class="normal">4783</span>
<span class="normal">4784</span>
<span class="normal">4785</span>
<span class="normal">4786</span>
<span class="normal">4787</span>
<span class="normal">4788</span>
<span class="normal">4789</span>
<span class="normal">4790</span>
<span class="normal">4791</span>
<span class="normal">4792</span>
<span class="normal">4793</span>
<span class="normal">4794</span>
<span class="normal">4795</span>
<span class="normal">4796</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compute_histogram</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
    <span class="nb">range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;ZarrNii&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute histogram of the image.</span>

<span class="sd">    This method computes the histogram of image intensities, optionally using</span>
<span class="sd">    a mask to weight the computation. The histogram is computed using dask for</span>
<span class="sd">    efficient processing of large datasets.</span>

<span class="sd">    Args:</span>
<span class="sd">        bins: Number of histogram bins (default: 256)</span>
<span class="sd">        range: Optional tuple (min, max) defining histogram range. If None,</span>
<span class="sd">            uses the full range of the data</span>
<span class="sd">        mask: Optional ZarrNii mask of same shape as image. Only pixels</span>
<span class="sd">            where mask &gt; 0 are included in histogram computation</span>
<span class="sd">        **kwargs: Additional arguments passed to dask.array.histogram</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (histogram_counts, bin_edges) where:</span>
<span class="sd">        - histogram_counts: dask array of histogram bin counts</span>
<span class="sd">        - bin_edges: dask array of bin edge values (length = bins + 1)</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Compute histogram</span>
<span class="sd">        &gt;&gt;&gt; hist, bin_edges = znimg.compute_histogram(bins=128)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Compute histogram with mask</span>
<span class="sd">        &gt;&gt;&gt; mask = znimg &gt; 0.5</span>
<span class="sd">        &gt;&gt;&gt; hist_masked, _ = znimg.compute_histogram(mask=mask)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute_histogram</span>

    <span class="n">mask_data</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">darr</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">compute_histogram</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">darr</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.compute_otsu_thresholds" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">compute_otsu_thresholds</span><span class="p">(</span><span class="n">classes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_figure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute Otsu multi-level thresholds for the image.</p>
<p>This method first computes the histogram of the image, then uses
scikit-image's threshold_multiotsu to compute optimal threshold values.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>classes</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>2</code>
)
          
          <div class="doc-md-description">
            <p>Number of classes to separate data into (default: 2).
Must be &gt;= 2. For classes=2, returns 1 threshold. For classes=k,
returns k-1 thresholds.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>bins</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>256</code>
)
          
          <div class="doc-md-description">
            <p>Number of histogram bins (default: 256)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>range</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional tuple (min, max) defining histogram range. If None,
uses the full range of the data</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>mask</code></b>
              (<code><span title="typing.Optional">Optional</span>[&#39;ZarrNii&#39;]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional ZarrNii mask of same shape as image. Only pixels
where mask &gt; 0 are included in histogram computation</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>return_figure</code></b>
              (<code><span title="bool">bool</span></code>, default:
                  <code>False</code>
)
          
          <div class="doc-md-description">
            <p>If True, returns a tuple containing thresholds and a
matplotlib figure with the histogram and annotated threshold lines
(default: False).</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="typing.Union">Union</span>[<span title="typing.List">List</span>[<span title="float">float</span>], <span title="typing.Tuple">Tuple</span>[<span title="typing.List">List</span>[<span title="float">float</span>], <span title="typing.Any">Any</span>]]</code>
          
          <div class="doc-md-description">
            <p>If return_figure is False (default):
List of threshold values. For classes=k, returns k+1 values:
[0, threshold1, threshold2, ..., threshold_k-1, max_intensity]
where 0 represents the minimum and max_intensity represents the maximum.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.Union">Union</span>[<span title="typing.List">List</span>[<span title="float">float</span>], <span title="typing.Tuple">Tuple</span>[<span title="typing.List">List</span>[<span title="float">float</span>], <span title="typing.Any">Any</span>]]</code>
          
          <div class="doc-md-description">
            <p>If return_figure is True:
Tuple of (thresholds, figure) where figure is a matplotlib Figure
object showing the histogram with annotated threshold lines.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute binary threshold (2 classes)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresholds</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">compute_otsu_thresholds</span><span class="p">(</span><span class="n">classes</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Binary thresholds: </span><span class="si">{</span><span class="n">thresholds</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute multi-level thresholds (3 classes)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresholds</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">compute_otsu_thresholds</span><span class="p">(</span><span class="n">classes</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Multi-level thresholds: </span><span class="si">{</span><span class="n">thresholds</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get histogram data along with thresholds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresholds</span><span class="p">,</span> <span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">)</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">compute_otsu_thresholds</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">classes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">return_histogram</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a figure with annotated thresholds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresholds</span><span class="p">,</span> <span class="n">fig</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">compute_otsu_thresholds</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">classes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">return_figure</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;otsu_thresholds.png&#39;</span><span class="p">)</span>
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4798</span>
<span class="normal">4799</span>
<span class="normal">4800</span>
<span class="normal">4801</span>
<span class="normal">4802</span>
<span class="normal">4803</span>
<span class="normal">4804</span>
<span class="normal">4805</span>
<span class="normal">4806</span>
<span class="normal">4807</span>
<span class="normal">4808</span>
<span class="normal">4809</span>
<span class="normal">4810</span>
<span class="normal">4811</span>
<span class="normal">4812</span>
<span class="normal">4813</span>
<span class="normal">4814</span>
<span class="normal">4815</span>
<span class="normal">4816</span>
<span class="normal">4817</span>
<span class="normal">4818</span>
<span class="normal">4819</span>
<span class="normal">4820</span>
<span class="normal">4821</span>
<span class="normal">4822</span>
<span class="normal">4823</span>
<span class="normal">4824</span>
<span class="normal">4825</span>
<span class="normal">4826</span>
<span class="normal">4827</span>
<span class="normal">4828</span>
<span class="normal">4829</span>
<span class="normal">4830</span>
<span class="normal">4831</span>
<span class="normal">4832</span>
<span class="normal">4833</span>
<span class="normal">4834</span>
<span class="normal">4835</span>
<span class="normal">4836</span>
<span class="normal">4837</span>
<span class="normal">4838</span>
<span class="normal">4839</span>
<span class="normal">4840</span>
<span class="normal">4841</span>
<span class="normal">4842</span>
<span class="normal">4843</span>
<span class="normal">4844</span>
<span class="normal">4845</span>
<span class="normal">4846</span>
<span class="normal">4847</span>
<span class="normal">4848</span>
<span class="normal">4849</span>
<span class="normal">4850</span>
<span class="normal">4851</span>
<span class="normal">4852</span>
<span class="normal">4853</span>
<span class="normal">4854</span>
<span class="normal">4855</span>
<span class="normal">4856</span>
<span class="normal">4857</span>
<span class="normal">4858</span>
<span class="normal">4859</span>
<span class="normal">4860</span>
<span class="normal">4861</span>
<span class="normal">4862</span>
<span class="normal">4863</span>
<span class="normal">4864</span>
<span class="normal">4865</span>
<span class="normal">4866</span>
<span class="normal">4867</span>
<span class="normal">4868</span>
<span class="normal">4869</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compute_otsu_thresholds</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">classes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
    <span class="nb">range</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;ZarrNii&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_figure</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Otsu multi-level thresholds for the image.</span>

<span class="sd">    This method first computes the histogram of the image, then uses</span>
<span class="sd">    scikit-image&#39;s threshold_multiotsu to compute optimal threshold values.</span>

<span class="sd">    Args:</span>
<span class="sd">        classes: Number of classes to separate data into (default: 2).</span>
<span class="sd">            Must be &gt;= 2. For classes=2, returns 1 threshold. For classes=k,</span>
<span class="sd">            returns k-1 thresholds.</span>
<span class="sd">        bins: Number of histogram bins (default: 256)</span>
<span class="sd">        range: Optional tuple (min, max) defining histogram range. If None,</span>
<span class="sd">            uses the full range of the data</span>
<span class="sd">        mask: Optional ZarrNii mask of same shape as image. Only pixels</span>
<span class="sd">            where mask &gt; 0 are included in histogram computation</span>
<span class="sd">        return_figure: If True, returns a tuple containing thresholds and a</span>
<span class="sd">            matplotlib figure with the histogram and annotated threshold lines</span>
<span class="sd">            (default: False).</span>

<span class="sd">    Returns:</span>
<span class="sd">        If return_figure is False (default):</span>
<span class="sd">            List of threshold values. For classes=k, returns k+1 values:</span>
<span class="sd">            [0, threshold1, threshold2, ..., threshold_k-1, max_intensity]</span>
<span class="sd">            where 0 represents the minimum and max_intensity represents the maximum.</span>

<span class="sd">        If return_figure is True:</span>
<span class="sd">            Tuple of (thresholds, figure) where figure is a matplotlib Figure</span>
<span class="sd">            object showing the histogram with annotated threshold lines.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Compute binary threshold (2 classes)</span>
<span class="sd">        &gt;&gt;&gt; thresholds = znimg.compute_otsu_thresholds(classes=2)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Binary thresholds: {thresholds}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Compute multi-level thresholds (3 classes)</span>
<span class="sd">        &gt;&gt;&gt; thresholds = znimg.compute_otsu_thresholds(classes=3)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Multi-level thresholds: {thresholds}&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Get histogram data along with thresholds</span>
<span class="sd">        &gt;&gt;&gt; thresholds, (hist, bin_edges) = znimg.compute_otsu_thresholds(</span>
<span class="sd">        ...     classes=2, return_histogram=True</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Generate a figure with annotated thresholds</span>
<span class="sd">        &gt;&gt;&gt; thresholds, fig = znimg.compute_otsu_thresholds(</span>
<span class="sd">        ...     classes=2, return_figure=True</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; fig.savefig(&#39;otsu_thresholds.png&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute_otsu_thresholds</span>

    <span class="c1"># First compute histogram</span>
    <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_histogram</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

    <span class="c1"># Then compute thresholds with optional returns</span>
    <span class="k">return</span> <span class="n">compute_otsu_thresholds</span><span class="p">(</span>
        <span class="n">hist</span><span class="p">,</span>
        <span class="n">classes</span><span class="o">=</span><span class="n">classes</span><span class="p">,</span>
        <span class="n">bin_edges</span><span class="o">=</span><span class="n">bin_edges</span><span class="p">,</span>
        <span class="n">return_figure</span><span class="o">=</span><span class="n">return_figure</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.create_mip" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">create_mip</span><span class="p">(</span><span class="n">plane</span><span class="o">=</span><span class="s1">&#39;axial&#39;</span><span class="p">,</span> <span class="n">slab_thickness_um</span><span class="o">=</span><span class="mf">100.0</span><span class="p">,</span> <span class="n">slab_spacing_um</span><span class="o">=</span><span class="mf">100.0</span><span class="p">,</span> <span class="n">channel_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel_ranges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channel_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_slabs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;mm&#39;</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Create Maximum Intensity Projection (MIP) visualizations across slabs.</p>
<p>This method generates MIP visualizations by dividing the volume into slabs
along the specified plane, computing the maximum intensity projection within
each slab, then rendering with channel-specific colors. Returns lazy dask
arrays that are computed only when explicitly requested.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>plane</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;axial&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Projection plane - one of 'axial', 'coronal', 'sagittal'.
- 'axial': projects along z-axis (creates xy slices)
- 'coronal': projects along y-axis (creates xz slices)
- 'sagittal': projects along x-axis (creates yz slices)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>slab_thickness_um</code></b>
              (<code><span title="float">float</span></code>, default:
                  <code>100.0</code>
)
          
          <div class="doc-md-description">
            <p>Thickness of each slab in microns (default: 100.0)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>slab_spacing_um</code></b>
              (<code><span title="float">float</span></code>, default:
                  <code>100.0</code>
)
          
          <div class="doc-md-description">
            <p>Spacing between slab centers in microns (default: 100.0)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>channel_colors</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>], <span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>]]]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional list of colors for each channel. Each color can be:
- Color name string (e.g., 'red', 'green', 'blue')
- RGB tuple with values 0-1 (e.g., (1.0, 0.0, 0.0) for red)
- RGBA tuple with values 0-1 (e.g., (1.0, 0.0, 0.0, 0.5) for semi-transparent red)
If None and OMERO metadata is available, uses OMERO channel colors.
Otherwise uses default colors: ['red', 'green', 'blue', 'cyan', 'magenta', 'yellow']</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>channel_ranges</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>]]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional list of (min, max) tuples specifying intensity range
for each channel. If None and OMERO metadata is available, uses OMERO window
settings. Otherwise uses auto-scaling based on data min/max.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>channel_labels</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="str">str</span>]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional list of channel label names to use for selecting
channels from OMERO metadata. If provided, channels are filtered and
reordered to match these labels. Requires OMERO metadata to be available.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>return_slabs</code></b>
              (<code><span title="bool">bool</span></code>, default:
                  <code>False</code>
)
          
          <div class="doc-md-description">
            <p>If True, returns tuple of (mip_list, slab_info_list) where
slab_info_list contains metadata about each slab. If False (default),
returns only the mip_list.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>scale_units</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;mm&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Units for scale values. Either "mm" (millimeters, default) or
"um" (microns). The ZarrNii scale values from NGFF/NIfTI are in millimeters
by default, so this should typically be left as "mm".</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="typing.Union">Union</span>[<span title="typing.List">List</span>[<span title="dask.array.Array">Array</span>], <span title="typing.Tuple">Tuple</span>[<span title="typing.List">List</span>[<span title="dask.array.Array">Array</span>], <span title="typing.List">List</span>[<span title="dict">dict</span>]]]</code>
          
          <div class="doc-md-description">
            <p>If return_slabs is False (default):
List of 2D dask arrays, each containing an RGB MIP visualization for one slab.
Each array has shape (height, width, 3) with RGB values in range [0, 1].
Arrays are lazy and will only be computed when explicitly requested.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.Union">Union</span>[<span title="typing.List">List</span>[<span title="dask.array.Array">Array</span>], <span title="typing.Tuple">Tuple</span>[<span title="typing.List">List</span>[<span title="dask.array.Array">Array</span>], <span title="typing.List">List</span>[<span title="dict">dict</span>]]]</code>
          
          <div class="doc-md-description">
            <p>If return_slabs is True:
Tuple of (mip_list, slab_info_list) where:
- mip_list: List of 2D RGB dask arrays as described above
- slab_info_list: List of dictionaries with slab metadata including:
    - 'start_um': Start position of slab in microns
    - 'end_um': End position of slab in microns
    - 'center_um': Center position of slab in microns
    - 'start_idx': Start index in array coordinates
    - 'end_idx': End index in array coordinates</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create axial MIPs with custom intensity ranges</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mips</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">create_mip</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">plane</span><span class="o">=</span><span class="s1">&#39;axial&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">slab_thickness_um</span><span class="o">=</span><span class="mf">100.0</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">slab_spacing_um</span><span class="o">=</span><span class="mf">100.0</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">channel_colors</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">channel_ranges</span><span class="o">=</span><span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1000.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">5000.0</span><span class="p">)]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use OMERO metadata for colors and ranges</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mips</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">create_mip</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">plane</span><span class="o">=</span><span class="s1">&#39;axial&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">channel_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;DAPI&#39;</span><span class="p">,</span> <span class="s1">&#39;GFP&#39;</span><span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use alpha transparency</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mips</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">create_mip</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">plane</span><span class="o">=</span><span class="s1">&#39;axial&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">channel_colors</span><span class="o">=</span><span class="p">[(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)]</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4871</span>
<span class="normal">4872</span>
<span class="normal">4873</span>
<span class="normal">4874</span>
<span class="normal">4875</span>
<span class="normal">4876</span>
<span class="normal">4877</span>
<span class="normal">4878</span>
<span class="normal">4879</span>
<span class="normal">4880</span>
<span class="normal">4881</span>
<span class="normal">4882</span>
<span class="normal">4883</span>
<span class="normal">4884</span>
<span class="normal">4885</span>
<span class="normal">4886</span>
<span class="normal">4887</span>
<span class="normal">4888</span>
<span class="normal">4889</span>
<span class="normal">4890</span>
<span class="normal">4891</span>
<span class="normal">4892</span>
<span class="normal">4893</span>
<span class="normal">4894</span>
<span class="normal">4895</span>
<span class="normal">4896</span>
<span class="normal">4897</span>
<span class="normal">4898</span>
<span class="normal">4899</span>
<span class="normal">4900</span>
<span class="normal">4901</span>
<span class="normal">4902</span>
<span class="normal">4903</span>
<span class="normal">4904</span>
<span class="normal">4905</span>
<span class="normal">4906</span>
<span class="normal">4907</span>
<span class="normal">4908</span>
<span class="normal">4909</span>
<span class="normal">4910</span>
<span class="normal">4911</span>
<span class="normal">4912</span>
<span class="normal">4913</span>
<span class="normal">4914</span>
<span class="normal">4915</span>
<span class="normal">4916</span>
<span class="normal">4917</span>
<span class="normal">4918</span>
<span class="normal">4919</span>
<span class="normal">4920</span>
<span class="normal">4921</span>
<span class="normal">4922</span>
<span class="normal">4923</span>
<span class="normal">4924</span>
<span class="normal">4925</span>
<span class="normal">4926</span>
<span class="normal">4927</span>
<span class="normal">4928</span>
<span class="normal">4929</span>
<span class="normal">4930</span>
<span class="normal">4931</span>
<span class="normal">4932</span>
<span class="normal">4933</span>
<span class="normal">4934</span>
<span class="normal">4935</span>
<span class="normal">4936</span>
<span class="normal">4937</span>
<span class="normal">4938</span>
<span class="normal">4939</span>
<span class="normal">4940</span>
<span class="normal">4941</span>
<span class="normal">4942</span>
<span class="normal">4943</span>
<span class="normal">4944</span>
<span class="normal">4945</span>
<span class="normal">4946</span>
<span class="normal">4947</span>
<span class="normal">4948</span>
<span class="normal">4949</span>
<span class="normal">4950</span>
<span class="normal">4951</span>
<span class="normal">4952</span>
<span class="normal">4953</span>
<span class="normal">4954</span>
<span class="normal">4955</span>
<span class="normal">4956</span>
<span class="normal">4957</span>
<span class="normal">4958</span>
<span class="normal">4959</span>
<span class="normal">4960</span>
<span class="normal">4961</span>
<span class="normal">4962</span>
<span class="normal">4963</span>
<span class="normal">4964</span>
<span class="normal">4965</span>
<span class="normal">4966</span>
<span class="normal">4967</span>
<span class="normal">4968</span>
<span class="normal">4969</span>
<span class="normal">4970</span>
<span class="normal">4971</span>
<span class="normal">4972</span>
<span class="normal">4973</span>
<span class="normal">4974</span>
<span class="normal">4975</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">create_mip</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">plane</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;axial&quot;</span><span class="p">,</span>
    <span class="n">slab_thickness_um</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">100.0</span><span class="p">,</span>
    <span class="n">slab_spacing_um</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">100.0</span><span class="p">,</span>
    <span class="n">channel_colors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span>
                <span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">channel_ranges</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">channel_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_slabs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">scale_units</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mm&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create Maximum Intensity Projection (MIP) visualizations across slabs.</span>

<span class="sd">    This method generates MIP visualizations by dividing the volume into slabs</span>
<span class="sd">    along the specified plane, computing the maximum intensity projection within</span>
<span class="sd">    each slab, then rendering with channel-specific colors. Returns lazy dask</span>
<span class="sd">    arrays that are computed only when explicitly requested.</span>

<span class="sd">    Args:</span>
<span class="sd">        plane: Projection plane - one of &#39;axial&#39;, &#39;coronal&#39;, &#39;sagittal&#39;.</span>
<span class="sd">            - &#39;axial&#39;: projects along z-axis (creates xy slices)</span>
<span class="sd">            - &#39;coronal&#39;: projects along y-axis (creates xz slices)</span>
<span class="sd">            - &#39;sagittal&#39;: projects along x-axis (creates yz slices)</span>
<span class="sd">        slab_thickness_um: Thickness of each slab in microns (default: 100.0)</span>
<span class="sd">        slab_spacing_um: Spacing between slab centers in microns (default: 100.0)</span>
<span class="sd">        channel_colors: Optional list of colors for each channel. Each color can be:</span>
<span class="sd">            - Color name string (e.g., &#39;red&#39;, &#39;green&#39;, &#39;blue&#39;)</span>
<span class="sd">            - RGB tuple with values 0-1 (e.g., (1.0, 0.0, 0.0) for red)</span>
<span class="sd">            - RGBA tuple with values 0-1 (e.g., (1.0, 0.0, 0.0, 0.5) for semi-transparent red)</span>
<span class="sd">            If None and OMERO metadata is available, uses OMERO channel colors.</span>
<span class="sd">            Otherwise uses default colors: [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;cyan&#39;, &#39;magenta&#39;, &#39;yellow&#39;]</span>
<span class="sd">        channel_ranges: Optional list of (min, max) tuples specifying intensity range</span>
<span class="sd">            for each channel. If None and OMERO metadata is available, uses OMERO window</span>
<span class="sd">            settings. Otherwise uses auto-scaling based on data min/max.</span>
<span class="sd">        channel_labels: Optional list of channel label names to use for selecting</span>
<span class="sd">            channels from OMERO metadata. If provided, channels are filtered and</span>
<span class="sd">            reordered to match these labels. Requires OMERO metadata to be available.</span>
<span class="sd">        return_slabs: If True, returns tuple of (mip_list, slab_info_list) where</span>
<span class="sd">            slab_info_list contains metadata about each slab. If False (default),</span>
<span class="sd">            returns only the mip_list.</span>
<span class="sd">        scale_units: Units for scale values. Either &quot;mm&quot; (millimeters, default) or</span>
<span class="sd">            &quot;um&quot; (microns). The ZarrNii scale values from NGFF/NIfTI are in millimeters</span>
<span class="sd">            by default, so this should typically be left as &quot;mm&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        If return_slabs is False (default):</span>
<span class="sd">            List of 2D dask arrays, each containing an RGB MIP visualization for one slab.</span>
<span class="sd">            Each array has shape (height, width, 3) with RGB values in range [0, 1].</span>
<span class="sd">            Arrays are lazy and will only be computed when explicitly requested.</span>

<span class="sd">        If return_slabs is True:</span>
<span class="sd">            Tuple of (mip_list, slab_info_list) where:</span>
<span class="sd">            - mip_list: List of 2D RGB dask arrays as described above</span>
<span class="sd">            - slab_info_list: List of dictionaries with slab metadata including:</span>
<span class="sd">                - &#39;start_um&#39;: Start position of slab in microns</span>
<span class="sd">                - &#39;end_um&#39;: End position of slab in microns</span>
<span class="sd">                - &#39;center_um&#39;: Center position of slab in microns</span>
<span class="sd">                - &#39;start_idx&#39;: Start index in array coordinates</span>
<span class="sd">                - &#39;end_idx&#39;: End index in array coordinates</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Create axial MIPs with custom intensity ranges</span>
<span class="sd">        &gt;&gt;&gt; mips = znimg.create_mip(</span>
<span class="sd">        ...     plane=&#39;axial&#39;,</span>
<span class="sd">        ...     slab_thickness_um=100.0,</span>
<span class="sd">        ...     slab_spacing_um=100.0,</span>
<span class="sd">        ...     channel_colors=[&#39;red&#39;, &#39;green&#39;],</span>
<span class="sd">        ...     channel_ranges=[(0.0, 1000.0), (0.0, 5000.0)]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Use OMERO metadata for colors and ranges</span>
<span class="sd">        &gt;&gt;&gt; mips = znimg.create_mip(</span>
<span class="sd">        ...     plane=&#39;axial&#39;,</span>
<span class="sd">        ...     channel_labels=[&#39;DAPI&#39;, &#39;GFP&#39;]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Use alpha transparency</span>
<span class="sd">        &gt;&gt;&gt; mips = znimg.create_mip(</span>
<span class="sd">        ...     plane=&#39;axial&#39;,</span>
<span class="sd">        ...     channel_colors=[(1.0, 0.0, 0.0, 0.7), (0.0, 1.0, 0.0, 0.5)]</span>
<span class="sd">        ... )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">create_mip_visualization</span>

    <span class="k">return</span> <span class="n">create_mip_visualization</span><span class="p">(</span>
        <span class="n">image</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">darr</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">plane</span><span class="o">=</span><span class="n">plane</span><span class="p">,</span>
        <span class="n">slab_thickness_um</span><span class="o">=</span><span class="n">slab_thickness_um</span><span class="p">,</span>
        <span class="n">slab_spacing_um</span><span class="o">=</span><span class="n">slab_spacing_um</span><span class="p">,</span>
        <span class="n">channel_colors</span><span class="o">=</span><span class="n">channel_colors</span><span class="p">,</span>
        <span class="n">channel_ranges</span><span class="o">=</span><span class="n">channel_ranges</span><span class="p">,</span>
        <span class="n">omero_metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">omero</span><span class="p">,</span>
        <span class="n">channel_labels</span><span class="o">=</span><span class="n">channel_labels</span><span class="p">,</span>
        <span class="n">return_slabs</span><span class="o">=</span><span class="n">return_slabs</span><span class="p">,</span>
        <span class="n">scale_units</span><span class="o">=</span><span class="n">scale_units</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.compute_centroids" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">compute_centroids</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">rechunk</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute centroids of binary segmentation objects in physical coordinates.</p>
<p>This method processes the binary image (typically output from a segmentation
plugin) to identify connected components and compute their centroids in
physical coordinates. It uses dask's map_overlap to efficiently process
large images in chunks with overlap to handle objects that span chunk
boundaries.</p>
<p>The input image should be binary (0/1 values) at the highest resolution.
The function will:
1. Optionally rechunk the data for better processing efficiency
2. Add overlap padding to chunks (customizable via depth parameter)
3. Within each chunk:
   - Label connected components using scikit-image
   - Compute centroids using regionprops
   - Convert to global voxel coordinates using block offsets
   - Filter out centroids in overlap regions to avoid duplicates
   - Convert to physical coordinates using the affine transform</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>depth</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="typing.Tuple">Tuple</span>[<span title="int">int</span>, ...], <span title="typing.Dict">Dict</span>[<span title="int">int</span>, <span title="int">int</span>]]</code>, default:
                  <code>10</code>
)
          
          <div class="doc-md-description">
            <p>Number of elements of overlap between chunks. Can be:
- int: same depth for all dimensions (default: 10)
- tuple: different depth per dimension
- dict: mapping dimension index to depth</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>boundary</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;none&#39;</code>
)
          
          <div class="doc-md-description">
            <p>How to handle boundaries when adding overlap. Options include
'none', 'reflect', 'periodic', 'nearest', or constant values.
Default is 'none' (no padding at array boundaries).</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>rechunk</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="typing.Tuple">Tuple</span>[<span title="int">int</span>, ...]]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional rechunking specification before processing. Can be:
- int: target chunk size for all dimensions
- tuple: target chunk size per dimension
- None: use existing chunks (default)</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="numpy.ndarray">ndarray</span></code>
          
          <div class="doc-md-description">
            <p>numpy.ndarray: Nx3 array of physical coordinates for N detected objects,
where each row contains [x, y, z] coordinates in physical space.
The array has dtype float64.</p>
          </div>
        </li>
    </ul>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>This method expects a binary image (e.g., from segment_threshold).</li>
<li>Objects with centroids in overlap regions are filtered to avoid duplicates.</li>
<li>Uses 26-connectivity (connectivity=3) for 3D connected component labeling.</li>
<li>Empty chunks contribute no coordinates to the result.</li>
<li>The result is computed immediately (not lazy).</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Apply threshold segmentation and compute centroids</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">znimg</span><span class="o">.</span><span class="n">segment_threshold</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroids</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">compute_centroids</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># With custom chunking</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroids</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="n">compute_centroids</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">depth</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">rechunk</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save centroids to file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s1">&#39;centroids.txt&#39;</span><span class="p">,</span> <span class="n">centroids</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%.6f</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">4977</span>
<span class="normal">4978</span>
<span class="normal">4979</span>
<span class="normal">4980</span>
<span class="normal">4981</span>
<span class="normal">4982</span>
<span class="normal">4983</span>
<span class="normal">4984</span>
<span class="normal">4985</span>
<span class="normal">4986</span>
<span class="normal">4987</span>
<span class="normal">4988</span>
<span class="normal">4989</span>
<span class="normal">4990</span>
<span class="normal">4991</span>
<span class="normal">4992</span>
<span class="normal">4993</span>
<span class="normal">4994</span>
<span class="normal">4995</span>
<span class="normal">4996</span>
<span class="normal">4997</span>
<span class="normal">4998</span>
<span class="normal">4999</span>
<span class="normal">5000</span>
<span class="normal">5001</span>
<span class="normal">5002</span>
<span class="normal">5003</span>
<span class="normal">5004</span>
<span class="normal">5005</span>
<span class="normal">5006</span>
<span class="normal">5007</span>
<span class="normal">5008</span>
<span class="normal">5009</span>
<span class="normal">5010</span>
<span class="normal">5011</span>
<span class="normal">5012</span>
<span class="normal">5013</span>
<span class="normal">5014</span>
<span class="normal">5015</span>
<span class="normal">5016</span>
<span class="normal">5017</span>
<span class="normal">5018</span>
<span class="normal">5019</span>
<span class="normal">5020</span>
<span class="normal">5021</span>
<span class="normal">5022</span>
<span class="normal">5023</span>
<span class="normal">5024</span>
<span class="normal">5025</span>
<span class="normal">5026</span>
<span class="normal">5027</span>
<span class="normal">5028</span>
<span class="normal">5029</span>
<span class="normal">5030</span>
<span class="normal">5031</span>
<span class="normal">5032</span>
<span class="normal">5033</span>
<span class="normal">5034</span>
<span class="normal">5035</span>
<span class="normal">5036</span>
<span class="normal">5037</span>
<span class="normal">5038</span>
<span class="normal">5039</span>
<span class="normal">5040</span>
<span class="normal">5041</span>
<span class="normal">5042</span>
<span class="normal">5043</span>
<span class="normal">5044</span>
<span class="normal">5045</span>
<span class="normal">5046</span>
<span class="normal">5047</span>
<span class="normal">5048</span>
<span class="normal">5049</span>
<span class="normal">5050</span>
<span class="normal">5051</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compute_centroids</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">boundary</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
    <span class="n">rechunk</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute centroids of binary segmentation objects in physical coordinates.</span>

<span class="sd">    This method processes the binary image (typically output from a segmentation</span>
<span class="sd">    plugin) to identify connected components and compute their centroids in</span>
<span class="sd">    physical coordinates. It uses dask&#39;s map_overlap to efficiently process</span>
<span class="sd">    large images in chunks with overlap to handle objects that span chunk</span>
<span class="sd">    boundaries.</span>

<span class="sd">    The input image should be binary (0/1 values) at the highest resolution.</span>
<span class="sd">    The function will:</span>
<span class="sd">    1. Optionally rechunk the data for better processing efficiency</span>
<span class="sd">    2. Add overlap padding to chunks (customizable via depth parameter)</span>
<span class="sd">    3. Within each chunk:</span>
<span class="sd">       - Label connected components using scikit-image</span>
<span class="sd">       - Compute centroids using regionprops</span>
<span class="sd">       - Convert to global voxel coordinates using block offsets</span>
<span class="sd">       - Filter out centroids in overlap regions to avoid duplicates</span>
<span class="sd">       - Convert to physical coordinates using the affine transform</span>

<span class="sd">    Args:</span>
<span class="sd">        depth: Number of elements of overlap between chunks. Can be:</span>
<span class="sd">            - int: same depth for all dimensions (default: 10)</span>
<span class="sd">            - tuple: different depth per dimension</span>
<span class="sd">            - dict: mapping dimension index to depth</span>
<span class="sd">        boundary: How to handle boundaries when adding overlap. Options include</span>
<span class="sd">            &#39;none&#39;, &#39;reflect&#39;, &#39;periodic&#39;, &#39;nearest&#39;, or constant values.</span>
<span class="sd">            Default is &#39;none&#39; (no padding at array boundaries).</span>
<span class="sd">        rechunk: Optional rechunking specification before processing. Can be:</span>
<span class="sd">            - int: target chunk size for all dimensions</span>
<span class="sd">            - tuple: target chunk size per dimension</span>
<span class="sd">            - None: use existing chunks (default)</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: Nx3 array of physical coordinates for N detected objects,</span>
<span class="sd">            where each row contains [x, y, z] coordinates in physical space.</span>
<span class="sd">            The array has dtype float64.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - This method expects a binary image (e.g., from segment_threshold).</span>
<span class="sd">        - Objects with centroids in overlap regions are filtered to avoid duplicates.</span>
<span class="sd">        - Uses 26-connectivity (connectivity=3) for 3D connected component labeling.</span>
<span class="sd">        - Empty chunks contribute no coordinates to the result.</span>
<span class="sd">        - The result is computed immediately (not lazy).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Apply threshold segmentation and compute centroids</span>
<span class="sd">        &gt;&gt;&gt; binary = znimg.segment_threshold(0.5)</span>
<span class="sd">        &gt;&gt;&gt; centroids = binary.compute_centroids(depth=5)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Found {len(centroids)} objects&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # With custom chunking</span>
<span class="sd">        &gt;&gt;&gt; centroids = binary.compute_centroids(</span>
<span class="sd">        ...     depth=15,</span>
<span class="sd">        ...     rechunk=(64, 64, 64)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Save centroids to file</span>
<span class="sd">        &gt;&gt;&gt; np.savetxt(&#39;centroids.txt&#39;, centroids, fmt=&#39;%.6f&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute_centroids</span>

    <span class="k">return</span> <span class="n">compute_centroids</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">darr</span><span class="p">,</span>
        <span class="n">affine</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span>
        <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span>
        <span class="n">boundary</span><span class="o">=</span><span class="n">boundary</span><span class="p">,</span>
        <span class="n">rechunk</span><span class="o">=</span><span class="n">rechunk</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNii.apply_scaled_processing" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNii</span><span class="o">.</span><span class="n">apply_scaled_processing</span><span class="p">(</span><span class="n">plugin</span><span class="p">,</span> <span class="n">downsample_factor</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upsampled_ome_zarr_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Apply scaled processing plugin using multi-resolution approach.</p>
<p>This method implements a multi-resolution processing pipeline where:
1. The image is downsampled for efficient computation
2. The plugin's lowres_func is applied to the downsampled data
3. The result is upsampled using dask-based upsampling
4. The plugin's highres_func applies the result to full-resolution data</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>plugin</code></b>
          
          <div class="doc-md-description">
            <p>ScaledProcessingPlugin instance or class to apply</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>downsample_factor</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>4</code>
)
          
          <div class="doc-md-description">
            <p>Factor for downsampling (default: 4)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>chunk_size</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="typing.Tuple">Tuple</span>[<span title="int">int</span>, ...]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Optional chunk size for low-res processing. If None, uses (1, 10, 10, 10).</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>upsampled_ome_zarr_path</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Path to save intermediate OME-Zarr, default saved in system temp directory.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>**kwargs</code></b>
          
          <div class="doc-md-description">
            <p>Additional arguments passed to the plugin</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;ZarrNii&#39;</code>
          
          <div class="doc-md-description">
            <p>New ZarrNii instance with processed data</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/core.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">5053</span>
<span class="normal">5054</span>
<span class="normal">5055</span>
<span class="normal">5056</span>
<span class="normal">5057</span>
<span class="normal">5058</span>
<span class="normal">5059</span>
<span class="normal">5060</span>
<span class="normal">5061</span>
<span class="normal">5062</span>
<span class="normal">5063</span>
<span class="normal">5064</span>
<span class="normal">5065</span>
<span class="normal">5066</span>
<span class="normal">5067</span>
<span class="normal">5068</span>
<span class="normal">5069</span>
<span class="normal">5070</span>
<span class="normal">5071</span>
<span class="normal">5072</span>
<span class="normal">5073</span>
<span class="normal">5074</span>
<span class="normal">5075</span>
<span class="normal">5076</span>
<span class="normal">5077</span>
<span class="normal">5078</span>
<span class="normal">5079</span>
<span class="normal">5080</span>
<span class="normal">5081</span>
<span class="normal">5082</span>
<span class="normal">5083</span>
<span class="normal">5084</span>
<span class="normal">5085</span>
<span class="normal">5086</span>
<span class="normal">5087</span>
<span class="normal">5088</span>
<span class="normal">5089</span>
<span class="normal">5090</span>
<span class="normal">5091</span>
<span class="normal">5092</span>
<span class="normal">5093</span>
<span class="normal">5094</span>
<span class="normal">5095</span>
<span class="normal">5096</span>
<span class="normal">5097</span>
<span class="normal">5098</span>
<span class="normal">5099</span>
<span class="normal">5100</span>
<span class="normal">5101</span>
<span class="normal">5102</span>
<span class="normal">5103</span>
<span class="normal">5104</span>
<span class="normal">5105</span>
<span class="normal">5106</span>
<span class="normal">5107</span>
<span class="normal">5108</span>
<span class="normal">5109</span>
<span class="normal">5110</span>
<span class="normal">5111</span>
<span class="normal">5112</span>
<span class="normal">5113</span>
<span class="normal">5114</span>
<span class="normal">5115</span>
<span class="normal">5116</span>
<span class="normal">5117</span>
<span class="normal">5118</span>
<span class="normal">5119</span>
<span class="normal">5120</span>
<span class="normal">5121</span>
<span class="normal">5122</span>
<span class="normal">5123</span>
<span class="normal">5124</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apply_scaled_processing</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">plugin</span><span class="p">,</span>
    <span class="n">downsample_factor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">chunk_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">upsampled_ome_zarr_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZarrNii&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply scaled processing plugin using multi-resolution approach.</span>

<span class="sd">    This method implements a multi-resolution processing pipeline where:</span>
<span class="sd">    1. The image is downsampled for efficient computation</span>
<span class="sd">    2. The plugin&#39;s lowres_func is applied to the downsampled data</span>
<span class="sd">    3. The result is upsampled using dask-based upsampling</span>
<span class="sd">    4. The plugin&#39;s highres_func applies the result to full-resolution data</span>

<span class="sd">    Args:</span>
<span class="sd">        plugin: ScaledProcessingPlugin instance or class to apply</span>
<span class="sd">        downsample_factor: Factor for downsampling (default: 4)</span>
<span class="sd">        chunk_size: Optional chunk size for low-res processing. If None, uses (1, 10, 10, 10).</span>
<span class="sd">        upsampled_ome_zarr_path: Path to save intermediate OME-Zarr, default saved in system temp directory.</span>
<span class="sd">        **kwargs: Additional arguments passed to the plugin</span>

<span class="sd">    Returns:</span>
<span class="sd">        New ZarrNii instance with processed data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.plugins.scaled_processing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ScaledProcessingPlugin</span>

    <span class="c1"># Handle plugin instance or class</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">plugin</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">plugin</span><span class="p">,</span> <span class="n">ScaledProcessingPlugin</span><span class="p">):</span>
        <span class="n">plugin</span> <span class="o">=</span> <span class="n">plugin</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">plugin</span><span class="p">,</span> <span class="n">ScaledProcessingPlugin</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Plugin must be an instance or subclass of ScaledProcessingPlugin&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Step 1: Downsample the data for low-resolution processing</span>
    <span class="n">lowres_znimg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">downsample_factor</span><span class="p">)))</span>

    <span class="c1"># Convert to numpy array for lowres processing</span>
    <span class="n">lowres_array</span> <span class="o">=</span> <span class="n">lowres_znimg</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

    <span class="c1"># Step 2: Apply low-resolution function and prepare for upsampling</span>
    <span class="c1"># Use chunk_size parameter for the low-res processing chunks</span>
    <span class="n">lowres_chunks</span> <span class="o">=</span> <span class="n">chunk_size</span> <span class="k">if</span> <span class="n">chunk_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">lowres_znimg</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span>
        <span class="n">plugin</span><span class="o">.</span><span class="n">lowres_func</span><span class="p">(</span><span class="n">lowres_array</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="n">lowres_chunks</span>
    <span class="p">)</span>

    <span class="c1"># Use temporary OME-Zarr to break up dask graph for performance</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">tempfile</span>

    <span class="k">if</span> <span class="n">upsampled_ome_zarr_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upsampled_ome_zarr_path</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;_SPIM.ome.zarr&quot;</span><span class="p">)</span>

    <span class="c1"># Step 3: Upsample using dask-based upsampling, save to ome zarr</span>
    <span class="n">lowres_znimg</span><span class="o">.</span><span class="n">upsample</span><span class="p">(</span><span class="n">to_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">to_ome_zarr</span><span class="p">(</span>
        <span class="n">upsampled_ome_zarr_path</span><span class="p">,</span> <span class="n">max_layer</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="n">upsampled_znimg</span> <span class="o">=</span> <span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_ome_zarr</span><span class="p">(</span><span class="n">upsampled_ome_zarr_path</span><span class="p">)</span>

    <span class="n">corrected_znimg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Step 4: Apply high-resolution function</span>
    <span class="c1"># rechunk original data to use same chunksize as upsampled_data, before multiplying</span>
    <span class="n">corrected_znimg</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">plugin</span><span class="o">.</span><span class="n">highres_func</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rechunk</span><span class="p">(</span><span class="n">upsampled_znimg</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">chunks</span><span class="p">),</span> <span class="n">upsampled_znimg</span><span class="o">.</span><span class="n">data</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">corrected_znimg</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<a id="zarrnii.ZarrNiiAtlas"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="zarrnii.core.ZarrNii" href="#zarrnii.ZarrNii">ZarrNii</a></code></p>


        <p>Brain atlas with segmentation image and region lookup table.</p>
<p>Represents a brain atlas consisting of a segmentation image (dseg) that
assigns integer labels to brain regions, and a lookup table (tsv) that
maps these labels to region names and other metadata.</p>
<p>Extension of ZarrNii to support atlas label tables.</p>
<p>Inherits all functionality from ZarrNii and adds support for
storing region/label metadata in a pandas DataFrame.</p>
<h3 id="zarrnii.ZarrNiiAtlas--attributes">Attributes</h3>
<p>labels_df : pandas.DataFrame
    DataFrame containing label information for the atlas.
label_column : str
    Name of the column in labels_df containing label indices.
name_column : str
    Name of the column in labels_df containing region names.
abbrev_column : str
    Name of the column in labels_df containing region abbreviations.</p>








                  <details class="quote">
                    <summary>Source code in <code>zarrnii/core.py</code></summary>
                    <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1655</span>
<span class="normal">1656</span>
<span class="normal">1657</span>
<span class="normal">1658</span>
<span class="normal">1659</span>
<span class="normal">1660</span>
<span class="normal">1661</span>
<span class="normal">1662</span>
<span class="normal">1663</span>
<span class="normal">1664</span>
<span class="normal">1665</span>
<span class="normal">1666</span>
<span class="normal">1667</span>
<span class="normal">1668</span>
<span class="normal">1669</span>
<span class="normal">1670</span>
<span class="normal">1671</span>
<span class="normal">1672</span>
<span class="normal">1673</span>
<span class="normal">1674</span>
<span class="normal">1675</span>
<span class="normal">1676</span>
<span class="normal">1677</span>
<span class="normal">1678</span>
<span class="normal">1679</span>
<span class="normal">1680</span>
<span class="normal">1681</span>
<span class="normal">1682</span>
<span class="normal">1683</span>
<span class="normal">1684</span>
<span class="normal">1685</span>
<span class="normal">1686</span>
<span class="normal">1687</span>
<span class="normal">1688</span>
<span class="normal">1689</span>
<span class="normal">1690</span>
<span class="normal">1691</span>
<span class="normal">1692</span>
<span class="normal">1693</span>
<span class="normal">1694</span>
<span class="normal">1695</span>
<span class="normal">1696</span>
<span class="normal">1697</span>
<span class="normal">1698</span>
<span class="normal">1699</span>
<span class="normal">1700</span>
<span class="normal">1701</span>
<span class="normal">1702</span>
<span class="normal">1703</span>
<span class="normal">1704</span>
<span class="normal">1705</span>
<span class="normal">1706</span>
<span class="normal">1707</span>
<span class="normal">1708</span>
<span class="normal">1709</span>
<span class="normal">1710</span>
<span class="normal">1711</span>
<span class="normal">1712</span>
<span class="normal">1713</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">darr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">axes_order</span><span class="o">=</span><span class="s2">&quot;ZYX&quot;</span><span class="p">,</span>
    <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;RAS&quot;</span><span class="p">,</span>
    <span class="n">xyz_orientation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ngff_image</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">spacing</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
    <span class="n">origin</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span><span class="p">,</span>
    <span class="n">_omero</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">affine</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AffineTransform</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructor with backward compatibility for old signature.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If affine parameter is provided</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check for deprecated affine parameter</span>
    <span class="k">if</span> <span class="n">affine</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The &#39;affine&#39; parameter is no longer supported in ZarrNii(). &quot;</span>
            <span class="s2">&quot;Please use &#39;spacing&#39; and &#39;origin&#39; parameters instead. &quot;</span>
            <span class="s2">&quot;If you need to specify a full affine transformation, use from_nifti() &quot;</span>
            <span class="s2">&quot;or construct the NgffImage directly.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Handle backwards compatibility: if xyz_orientation is provided, use it</span>
    <span class="c1"># Otherwise, use orientation for backwards compatibility</span>
    <span class="n">final_orientation</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">xyz_orientation</span> <span class="k">if</span> <span class="n">xyz_orientation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">orientation</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">ngff_image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># New signature</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ngff_image&quot;</span><span class="p">,</span> <span class="n">ngff_image</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;axes_order&quot;</span><span class="p">,</span> <span class="n">axes_order</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;xyz_orientation&quot;</span><span class="p">,</span> <span class="n">final_orientation</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_omero&quot;</span><span class="p">,</span> <span class="n">_omero</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">darr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Legacy signature - delegate to from_darr</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_darr</span><span class="p">(</span>
            <span class="n">darr</span><span class="o">=</span><span class="n">darr</span><span class="p">,</span>
            <span class="n">axes_order</span><span class="o">=</span><span class="n">axes_order</span><span class="p">,</span>
            <span class="n">orientation</span><span class="o">=</span><span class="n">final_orientation</span><span class="p">,</span>
            <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">omero</span><span class="o">=</span><span class="n">_omero</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ngff_image&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">ngff_image</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;axes_order&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">axes_order</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;xyz_orientation&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_omero&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">_omero</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide either ngff_image or darr&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
                  </details>



  <div class="doc doc-children">





<h2 id="zarrnii.ZarrNiiAtlas-attributes">Attributes</h2>

<div class="doc doc-object doc-attribute">



<h3 id="zarrnii.ZarrNiiAtlas.dseg" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">dseg</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return self as the segmentation image (for compatibility with API).</p>

    </div>

</div>


<h2 id="zarrnii.ZarrNiiAtlas-functions">Functions</h2>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.create_from_dseg" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">create_from_dseg</span><span class="p">(</span><span class="n">dseg</span><span class="p">,</span> <span class="n">labels_df</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create ZarrNiiAtlas from a dseg ZarrNii and labels DataFrame.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>dseg</code></b>
              (<code><a class="autorefs autorefs-internal" title="zarrnii.core.ZarrNii" href="#zarrnii.ZarrNii">ZarrNii</a></code>)
          
          <div class="doc-md-description">
            <p>ZarrNii segmentation image</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>labels_df</code></b>
              (<code><span title="pandas.DataFrame">DataFrame</span></code>)
          
          <div class="doc-md-description">
            <p>DataFrame containing label information</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>**kwargs</code></b>
          
          <div class="doc-md-description">
            <p>Additional keyword arguments for label/name/abbrev columns</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
          
          <div class="doc-md-description">
            <p>ZarrNiiAtlas instance</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">create_from_dseg</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dseg</span><span class="p">:</span> <span class="n">ZarrNii</span><span class="p">,</span> <span class="n">labels_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create ZarrNiiAtlas from a dseg ZarrNii and labels DataFrame.</span>

<span class="sd">    Args:</span>
<span class="sd">        dseg: ZarrNii segmentation image</span>
<span class="sd">        labels_df: DataFrame containing label information</span>
<span class="sd">        **kwargs: Additional keyword arguments for label/name/abbrev columns</span>

<span class="sd">    Returns:</span>
<span class="sd">        ZarrNiiAtlas instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dseg</span><span class="p">,</span> <span class="n">ZarrNii</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dseg must be a ZarrNii instance, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dseg</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Note: attrs strips leading underscore from _omero in __init__ signature</span>
    <span class="c1"># so we pass it as &#39;omero&#39; instead of &#39;_omero&#39;</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">dseg</span><span class="o">.</span><span class="n">ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="n">dseg</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="n">dseg</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">omero</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">dseg</span><span class="p">,</span> <span class="s2">&quot;_omero&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">labels_df</span><span class="o">=</span><span class="n">labels_df</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.from_files" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">from_files</span><span class="p">(</span><span class="n">dseg_path</span><span class="p">,</span> <span class="n">labels_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Load ZarrNiiAtlas from dseg image and labels TSV files.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>dseg_path</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="pathlib.Path">Path</span>]</code>)
          
          <div class="doc-md-description">
            <p>Path to segmentation image (NIfTI or OME-Zarr)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>labels_path</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="pathlib.Path">Path</span>]</code>)
          
          <div class="doc-md-description">
            <p>Path to labels TSV file</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>**kwargs</code></b>
          
          <div class="doc-md-description">
            <p>Additional arguments passed to ZarrNii.from_file()</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
          
          <div class="doc-md-description">
            <p>ZarrNiiAtlas instance</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_files</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span> <span class="n">dseg_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span> <span class="n">labels_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load ZarrNiiAtlas from dseg image and labels TSV files.</span>

<span class="sd">    Args:</span>
<span class="sd">        dseg_path: Path to segmentation image (NIfTI or OME-Zarr)</span>
<span class="sd">        labels_path: Path to labels TSV file</span>
<span class="sd">        **kwargs: Additional arguments passed to ZarrNii.from_file()</span>

<span class="sd">    Returns:</span>
<span class="sd">        ZarrNiiAtlas instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load segmentation image</span>
    <span class="n">dseg</span> <span class="o">=</span> <span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">dseg_path</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Load labels dataframe</span>
    <span class="n">labels_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">labels_path</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Create atlas instance using create_from_dseg</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">create_from_dseg</span><span class="p">(</span><span class="n">dseg</span><span class="p">,</span> <span class="n">labels_df</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.from_itksnap_lut" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">from_itksnap_lut</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">lut_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Construct from itksnap lut file.</p>


            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_itksnap_lut</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">lut_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct from itksnap lut file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">znii</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">labels_df</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_import_itksnap_lut</span><span class="p">(</span><span class="n">lut_path</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">znii</span><span class="o">.</span><span class="n">ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="n">znii</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="n">znii</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">labels_df</span><span class="o">=</span><span class="n">labels_df</span><span class="p">,</span>
        <span class="n">omero</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">znii</span><span class="p">,</span> <span class="s2">&quot;_omero&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.from_csv_lut" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">from_csv_lut</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">lut_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Construct from csv lut file.</p>


            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_csv_lut</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">lut_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct from csv lut file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">znii</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">labels_df</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_import_csv_lut</span><span class="p">(</span><span class="n">lut_path</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">znii</span><span class="o">.</span><span class="n">ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="n">znii</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="n">znii</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">labels_df</span><span class="o">=</span><span class="n">labels_df</span><span class="p">,</span>
        <span class="n">omero</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">znii</span><span class="p">,</span> <span class="s2">&quot;_omero&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.from_tsv_lut" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">from_tsv_lut</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">lut_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Construct from tsv lut file.</p>


            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_tsv_lut</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">lut_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct from tsv lut file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">znii</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">labels_df</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_import_tsv_lut</span><span class="p">(</span><span class="n">lut_path</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">znii</span><span class="o">.</span><span class="n">ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="n">znii</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="n">znii</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">labels_df</span><span class="o">=</span><span class="n">labels_df</span><span class="p">,</span>
        <span class="n">omero</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">znii</span><span class="p">,</span> <span class="s2">&quot;_omero&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.from_labelmapper_lut" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">from_labelmapper_lut</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">lut_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Construct from labelmapper lut file.</p>


            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_labelmapper_lut</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">lut_path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct from labelmapper lut file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">znii</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">labels_df</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_import_labelmapper_lut</span><span class="p">(</span><span class="n">lut_path</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">ngff_image</span><span class="o">=</span><span class="n">znii</span><span class="o">.</span><span class="n">ngff_image</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="n">znii</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="n">znii</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">labels_df</span><span class="o">=</span><span class="n">labels_df</span><span class="p">,</span>
        <span class="n">omero</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">znii</span><span class="p">,</span> <span class="s2">&quot;_omero&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.get_region_info" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">get_region_info</span><span class="p">(</span><span class="n">region_id</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Get information about a specific region.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>region_id</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="str">str</span>]</code>)
          
          <div class="doc-md-description">
            <p>Region identifier (int label, name, or abbreviation)</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]</code>
          
          <div class="doc-md-description">
            <p>Dictionary containing region information</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If region not found in atlas</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_region_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get information about a specific region.</span>

<span class="sd">    Args:</span>
<span class="sd">        region_id: Region identifier (int label, name, or abbreviation)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dictionary containing region information</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If region not found in atlas</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_region_identifier</span><span class="p">(</span><span class="n">region_id</span><span class="p">)</span>

    <span class="c1"># Find the region in labels DataFrame</span>
    <span class="n">region_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">region_row</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Region with label </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> not found in atlas&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">region_row</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.get_region_mask" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">get_region_mask</span><span class="p">(</span><span class="n">region_id</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Create binary mask for a specific region.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>region_id</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="str">str</span>]</code>)
          
          <div class="doc-md-description">
            <p>Region identifier (int label, name, or abbreviation)</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><a class="autorefs autorefs-internal" title="zarrnii.core.ZarrNii" href="#zarrnii.ZarrNii">ZarrNii</a></code>
          
          <div class="doc-md-description">
            <p>ZarrNii instance containing binary mask (1 for region, 0 elsewhere)</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If region not found in atlas</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_region_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">ZarrNii</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create binary mask for a specific region.</span>

<span class="sd">    Args:</span>
<span class="sd">        region_id: Region identifier (int label, name, or abbreviation)</span>

<span class="sd">    Returns:</span>
<span class="sd">        ZarrNii instance containing binary mask (1 for region, 0 elsewhere)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If region not found in atlas</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_region_identifier</span><span class="p">(</span><span class="n">region_id</span><span class="p">)</span>

    <span class="c1"># Validate that the region exists in our labels_df</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Region with label </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> not found in atlas&quot;</span><span class="p">)</span>

    <span class="c1"># Create binary mask</span>
    <span class="n">mask_data</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="n">mask_ngff</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">mask_data</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">translation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_masked&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_ngff_image</span><span class="p">(</span>
        <span class="n">mask_ngff</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">omero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">omero</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.get_region_volume" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">get_region_volume</span><span class="p">(</span><span class="n">region_id</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculate volume of a specific region in mm.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>region_id</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="str">str</span>]</code>)
          
          <div class="doc-md-description">
            <p>Region identifier (int label, name, or abbreviation)</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="float">float</span></code>
          
          <div class="doc-md-description">
            <p>Volume in cubic millimeters</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If region not found in atlas</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_region_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate volume of a specific region in mm.</span>

<span class="sd">    Args:</span>
<span class="sd">        region_id: Region identifier (int label, name, or abbreviation)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Volume in cubic millimeters</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If region not found in atlas</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_region_identifier</span><span class="p">(</span><span class="n">region_id</span><span class="p">)</span>

    <span class="c1"># Count voxels with this label</span>
    <span class="n">dseg_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">data</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dseg_data</span><span class="p">,</span> <span class="s2">&quot;compute&quot;</span><span class="p">):</span>
        <span class="n">voxel_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">dseg_data</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">voxel_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">dseg_data</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

    <span class="c1"># Calculate volume using voxel size from affine</span>
    <span class="c1"># Volume per voxel = abs(det(affine[:3, :3]))</span>
    <span class="n">voxel_volume</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">affine</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]))</span>

    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">voxel_count</span> <span class="o">*</span> <span class="n">voxel_volume</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.aggregate_image_by_regions" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">aggregate_image_by_regions</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">aggregation_func</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">background_label</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">column_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">column_suffix</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Aggregate image values by atlas regions.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>image</code></b>
              (<code><a class="autorefs autorefs-internal" title="zarrnii.core.ZarrNii" href="#zarrnii.ZarrNii">ZarrNii</a></code>)
          
          <div class="doc-md-description">
            <p>Image to aggregate (must be compatible with atlas)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>aggregation_func</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;mean&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Aggregation function ('mean', 'sum', 'std', 'median', 'min', 'max')</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>background_label</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>0</code>
)
          
          <div class="doc-md-description">
            <p>Label value to treat as background (excluded from results)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>column_name</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>String to use for column name. If None, uses f"{aggregation_func}_value"</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>column_suffix</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>(Deprecated) String suffix to append to column name.
Use column_name instead. If provided, column_name will be set to
f"{aggregation_func}_{column_suffix}".</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="pandas.DataFrame">DataFrame</span></code>
          
          <div class="doc-md-description">
            <p>DataFrame with columns: index, name, {column_name}, volume_mm3</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="pandas.DataFrame">DataFrame</span></code>
          
          <div class="doc-md-description">
            <p>(e.g., with defaults: index, name, mean_value, volume_mm3)</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If image and atlas are incompatible</p>
          </div>
        </li>
    </ul>
        <p>.. deprecated:: 0.2.0
    The <code>column_suffix</code> parameter is deprecated. Use <code>column_name</code> instead.</p>


            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">aggregate_image_by_regions</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">image</span><span class="p">:</span> <span class="n">ZarrNii</span><span class="p">,</span>
    <span class="n">aggregation_func</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">background_label</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">column_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Aggregate image values by atlas regions.</span>

<span class="sd">    Args:</span>
<span class="sd">        image: Image to aggregate (must be compatible with atlas)</span>
<span class="sd">        aggregation_func: Aggregation function (&#39;mean&#39;, &#39;sum&#39;, &#39;std&#39;, &#39;median&#39;, &#39;min&#39;, &#39;max&#39;)</span>
<span class="sd">        background_label: Label value to treat as background (excluded from results)</span>
<span class="sd">        column_name: String to use for column name. If None, uses f&quot;{aggregation_func}_value&quot;</span>
<span class="sd">        column_suffix: (Deprecated) String suffix to append to column name.</span>
<span class="sd">            Use column_name instead. If provided, column_name will be set to</span>
<span class="sd">            f&quot;{aggregation_func}_{column_suffix}&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with columns: index, name, {column_name}, volume_mm3</span>
<span class="sd">        (e.g., with defaults: index, name, mean_value, volume_mm3)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If image and atlas are incompatible</span>

<span class="sd">    .. deprecated:: 0.2.0</span>
<span class="sd">        The `column_suffix` parameter is deprecated. Use `column_name` instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Handle deprecated column_suffix parameter</span>
    <span class="k">if</span> <span class="n">column_suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The &#39;column_suffix&#39; parameter is deprecated and will be removed in a &quot;</span>
            <span class="s2">&quot;future version. Use &#39;column_name&#39; instead.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">column_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">column_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">aggregation_func</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">column_suffix</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># Set default column name if not provided</span>
    <span class="k">if</span> <span class="n">column_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">column_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">aggregation_func</span><span class="si">}</span><span class="s2">_value&quot;</span>

    <span class="c1"># Validate image compatibility</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Image shape </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> doesn&#39;t match atlas shape </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">affine</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">affine</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Image and atlas affines don&#39;t match exactly. &quot;</span>
            <span class="s2">&quot;Results may be spatially inconsistent.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Get all unique labels (excluding background)</span>
    <span class="n">dseg_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">data</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dseg_data</span><span class="p">,</span> <span class="s2">&quot;compute&quot;</span><span class="p">):</span>
        <span class="n">dseg_data</span> <span class="o">=</span> <span class="n">dseg_data</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dseg_data</span><span class="p">)</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">unique_labels</span><span class="p">[</span><span class="n">unique_labels</span> <span class="o">!=</span> <span class="n">background_label</span><span class="p">]</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">unique_labels</span><span class="p">:</span>
        <span class="c1"># Create mask for this region</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">label</span>

        <span class="c1"># Extract image values for this region</span>
        <span class="n">region_values</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="c1"># Skip if no voxels (shouldn&#39;t happen with unique labels)</span>
        <span class="k">if</span> <span class="n">region_values</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Compute aggregation</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">region_values</span><span class="p">,</span> <span class="s2">&quot;compute&quot;</span><span class="p">):</span>
            <span class="c1"># Dask array - need to compute</span>
            <span class="k">if</span> <span class="n">aggregation_func</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
                <span class="n">agg_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">region_values</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">aggregation_func</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
                <span class="n">agg_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">region_values</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">aggregation_func</span> <span class="o">==</span> <span class="s2">&quot;std&quot;</span><span class="p">:</span>
                <span class="n">agg_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">region_values</span><span class="o">.</span><span class="n">std</span><span class="p">()</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">aggregation_func</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
                <span class="n">agg_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">region_values</span><span class="o">.</span><span class="n">compute</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="n">aggregation_func</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
                <span class="n">agg_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">region_values</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">aggregation_func</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
                <span class="n">agg_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">region_values</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">compute</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unknown aggregation function: </span><span class="si">{</span><span class="n">aggregation_func</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;Supported: mean, sum, std, median, min, max&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># NumPy array - direct computation</span>
            <span class="k">if</span> <span class="n">aggregation_func</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
                <span class="n">agg_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">region_values</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">aggregation_func</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
                <span class="n">agg_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">region_values</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">aggregation_func</span> <span class="o">==</span> <span class="s2">&quot;std&quot;</span><span class="p">:</span>
                <span class="n">agg_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">region_values</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">aggregation_func</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
                <span class="n">agg_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">region_values</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">aggregation_func</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
                <span class="n">agg_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">region_values</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">aggregation_func</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
                <span class="n">agg_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">region_values</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unknown aggregation function: </span><span class="si">{</span><span class="n">aggregation_func</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;Supported: mean, sum, std, median, min, max&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Get region info</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">region_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_region_info</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
            <span class="n">region_name</span> <span class="o">=</span> <span class="n">region_info</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name_column</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">region_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Unknown_Region_</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Calculate volume</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_region_volume</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>

        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_column</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name_column</span><span class="p">:</span> <span class="n">region_name</span><span class="p">,</span>
                <span class="n">column_name</span><span class="p">:</span> <span class="n">agg_value</span><span class="p">,</span>
                <span class="s2">&quot;volume_mm3&quot;</span><span class="p">:</span> <span class="n">volume</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.create_feature_map" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">create_feature_map</span><span class="p">(</span><span class="n">feature_data</span><span class="p">,</span> <span class="n">feature_column</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Create feature map by assigning values to atlas regions.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>feature_data</code></b>
              (<code><span title="pandas.DataFrame">DataFrame</span></code>)
          
          <div class="doc-md-description">
            <p>DataFrame with region labels and feature values</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>feature_column</code></b>
              (<code><span title="str">str</span></code>)
          
          <div class="doc-md-description">
            <p>Column name containing feature values to map</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>label_column</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;index&#39;</code>
)
          
          <div class="doc-md-description">
            <p>Column name containing region labels</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><a class="autorefs autorefs-internal" title="zarrnii.core.ZarrNii" href="#zarrnii.ZarrNii">ZarrNii</a></code>
          
          <div class="doc-md-description">
            <p>ZarrNii instance with feature values mapped to regions</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If required columns are missing</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">create_feature_map</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">feature_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">feature_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">label_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;index&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ZarrNii</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create feature map by assigning values to atlas regions.</span>

<span class="sd">    Args:</span>
<span class="sd">        feature_data: DataFrame with region labels and feature values</span>
<span class="sd">        feature_column: Column name containing feature values to map</span>
<span class="sd">        label_column: Column name containing region labels</span>

<span class="sd">    Returns:</span>
<span class="sd">        ZarrNii instance with feature values mapped to regions</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If required columns are missing</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate input</span>
    <span class="n">required_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">label_column</span><span class="p">,</span> <span class="n">feature_column</span><span class="p">]</span>
    <span class="n">missing_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">required_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">feature_data</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">missing_cols</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing columns in feature_data: </span><span class="si">{</span><span class="n">missing_cols</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">dseg_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>  <span class="c1"># dask array of labels</span>

    <span class="c1"># make a dense lookup array</span>
    <span class="n">max_label</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">feature_data</span><span class="p">[</span><span class="n">label_column</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="n">lut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_label</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">lut</span><span class="p">[</span><span class="n">feature_data</span><span class="p">[</span><span class="n">label_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span> <span class="o">=</span> <span class="n">feature_data</span><span class="p">[</span>
        <span class="n">feature_column</span>
    <span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># broadcast the mapping in one go</span>
    <span class="n">feature_map</span> <span class="o">=</span> <span class="n">dseg_data</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="k">lambda</span> <span class="n">block</span><span class="p">:</span> <span class="n">lut</span><span class="p">[</span><span class="n">block</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">feature_map_ngff</span> <span class="o">=</span> <span class="n">nz</span><span class="o">.</span><span class="n">NgffImage</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">feature_map</span><span class="p">,</span>
        <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">translation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">ngff_image</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_feature_map&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ZarrNii</span><span class="o">.</span><span class="n">from_ngff_image</span><span class="p">(</span>
        <span class="n">feature_map_ngff</span><span class="p">,</span>
        <span class="n">xyz_orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">xyz_orientation</span><span class="p">,</span>
        <span class="n">axes_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">axes_order</span><span class="p">,</span>
        <span class="n">omero</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">omero</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.get_region_bounding_box" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">get_region_bounding_box</span><span class="p">(</span><span class="n">region_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Get bounding box in physical coordinates for selected regions.</p>
<p>This method computes the spatial extents (bounding box) of one or more
atlas regions in physical/world coordinates. The returned bounding box
can be used directly with the crop method to extract a subvolume
containing the selected regions.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>region_ids</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="str">str</span>, <span title="typing.List">List</span>[<span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="str">str</span>]]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Region identifier(s) to include in bounding box. Can be:
- Single int: label index
- Single str: region name or abbreviation
- List[int/str]: multiple regions by index, name, or abbreviation
- None: use regex parameter instead</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>regex</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Regular expression to match region names. If provided,
region_ids must be None. Case-insensitive matching.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>]</code>
          
          <div class="doc-md-description">
            <p>Tuple of (bbox_min, bbox_max) where each is a tuple of (x, y, z)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>]</code>
          
          <div class="doc-md-description">
            <p>coordinates in physical/world space (mm). These can be passed</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.Tuple">Tuple</span>[<span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>], <span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>]]</code>
          
          <div class="doc-md-description">
            <p>directly to ZarrNii.crop() method with physical_coords=True.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If no regions match the selection criteria, or if both
region_ids and regex are provided/omitted</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="TypeError">TypeError</span></code>
            
          <div class="doc-md-description">
            <p>If region_ids contains invalid types</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get bounding box for single region</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bbox_min</span><span class="p">,</span> <span class="n">bbox_max</span> <span class="o">=</span> <span class="n">atlas</span><span class="o">.</span><span class="n">get_region_bounding_box</span><span class="p">(</span><span class="s2">&quot;Hippocampus&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cropped</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">bbox_min</span><span class="p">,</span> <span class="n">bbox_max</span><span class="p">,</span> <span class="n">physical_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get bounding box for multiple regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bbox_min</span><span class="p">,</span> <span class="n">bbox_max</span> <span class="o">=</span> <span class="n">atlas</span><span class="o">.</span><span class="n">get_region_bounding_box</span><span class="p">([</span><span class="s2">&quot;Hippocampus&quot;</span><span class="p">,</span> <span class="s2">&quot;Amygdala&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use regex to select regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bbox_min</span><span class="p">,</span> <span class="n">bbox_max</span> <span class="o">=</span> <span class="n">atlas</span><span class="o">.</span><span class="n">get_region_bounding_box</span><span class="p">(</span><span class="n">regex</span><span class="o">=</span><span class="s2">&quot;Hip.*&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Crop atlas itself to region</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cropped_atlas</span> <span class="o">=</span> <span class="n">atlas</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">bbox_min</span><span class="p">,</span> <span class="n">bbox_max</span><span class="p">,</span> <span class="n">physical_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Bounding box is in physical coordinates (mm), not voxel indices</li>
<li>Axes ordering is relative to self.axes_order (e.g. ZYX for ome zarr)</li>
<li>The bounding box is the union of all selected regions</li>
<li>Use the returned values with crop(physical_coords=True)</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_region_bounding_box</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">region_ids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">regex</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get bounding box in physical coordinates for selected regions.</span>

<span class="sd">    This method computes the spatial extents (bounding box) of one or more</span>
<span class="sd">    atlas regions in physical/world coordinates. The returned bounding box</span>
<span class="sd">    can be used directly with the crop method to extract a subvolume</span>
<span class="sd">    containing the selected regions.</span>

<span class="sd">    Args:</span>
<span class="sd">        region_ids: Region identifier(s) to include in bounding box. Can be:</span>
<span class="sd">            - Single int: label index</span>
<span class="sd">            - Single str: region name or abbreviation</span>
<span class="sd">            - List[int/str]: multiple regions by index, name, or abbreviation</span>
<span class="sd">            - None: use regex parameter instead</span>
<span class="sd">        regex: Regular expression to match region names. If provided,</span>
<span class="sd">            region_ids must be None. Case-insensitive matching.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (bbox_min, bbox_max) where each is a tuple of (x, y, z)</span>
<span class="sd">        coordinates in physical/world space (mm). These can be passed</span>
<span class="sd">        directly to ZarrNii.crop() method with physical_coords=True.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If no regions match the selection criteria, or if both</span>
<span class="sd">            region_ids and regex are provided/omitted</span>
<span class="sd">        TypeError: If region_ids contains invalid types</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Get bounding box for single region</span>
<span class="sd">        &gt;&gt;&gt; bbox_min, bbox_max = atlas.get_region_bounding_box(&quot;Hippocampus&quot;)</span>
<span class="sd">        &gt;&gt;&gt; cropped = image.crop(bbox_min, bbox_max, physical_coords=True)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Get bounding box for multiple regions</span>
<span class="sd">        &gt;&gt;&gt; bbox_min, bbox_max = atlas.get_region_bounding_box([&quot;Hippocampus&quot;, &quot;Amygdala&quot;])</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Use regex to select regions</span>
<span class="sd">        &gt;&gt;&gt; bbox_min, bbox_max = atlas.get_region_bounding_box(regex=&quot;Hip.*&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Crop atlas itself to region</span>
<span class="sd">        &gt;&gt;&gt; cropped_atlas = atlas.crop(bbox_min, bbox_max, physical_coords=True)</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Bounding box is in physical coordinates (mm), not voxel indices</span>
<span class="sd">        - Axes ordering is relative to self.axes_order (e.g. ZYX for ome zarr)</span>
<span class="sd">        - The bounding box is the union of all selected regions</span>
<span class="sd">        - Use the returned values with crop(physical_coords=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

    <span class="kn">import</span><span class="w"> </span><span class="nn">dask.array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">da</span>

    <span class="c1"># Validate input parameters</span>
    <span class="k">if</span> <span class="n">region_ids</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">regex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide either region_ids or regex parameter&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">region_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">regex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot provide both region_ids and regex parameters&quot;</span><span class="p">)</span>

    <span class="c1"># Determine which labels to include</span>
    <span class="n">selected_labels</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">regex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Match regions using regex</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">region_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name_column</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">region_name</span><span class="p">):</span>
                <span class="n">selected_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label_column</span><span class="p">]))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">selected_labels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No regions matched regex pattern: </span><span class="si">{</span><span class="n">regex</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Convert region_ids to list if single value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region_ids</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">region_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">region_ids</span><span class="p">]</span>

        <span class="c1"># Resolve each region identifier to label</span>
        <span class="k">for</span> <span class="n">region_id</span> <span class="ow">in</span> <span class="n">region_ids</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_region_identifier</span><span class="p">(</span><span class="n">region_id</span><span class="p">)</span>
            <span class="n">selected_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

    <span class="c1"># Create union mask of all selected regions</span>
    <span class="n">dseg_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">data</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">selected_labels</span><span class="p">:</span>
        <span class="n">region_mask</span> <span class="o">=</span> <span class="n">dseg_data</span> <span class="o">==</span> <span class="n">label</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">region_mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">|</span> <span class="n">region_mask</span>

    <span class="c1"># Find voxel coordinates where mask is True</span>
    <span class="c1"># da.where returns tuple of arrays (one per dimension in data array)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="c1"># Compute the indices to get actual coordinates</span>
    <span class="n">indices_computed</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

    <span class="c1"># Check if any voxels were found</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices_computed</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No voxels found for selected regions: </span><span class="si">{</span><span class="n">selected_labels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Get the spatial dimensions from dims (skip non-spatial like &#39;c&#39;, &#39;t&#39;)</span>
    <span class="n">spatial_dims_lower</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]]</span>
    <span class="n">spatial_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">spatial_dims_lower</span><span class="p">:</span>
            <span class="n">spatial_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># Extract spatial coordinates from indices</span>
    <span class="c1"># indices_computed has one array per dimension in data</span>
    <span class="n">voxel_coords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">spatial_idx</span> <span class="ow">in</span> <span class="n">spatial_indices</span><span class="p">:</span>
        <span class="n">voxel_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices_computed</span><span class="p">[</span><span class="n">spatial_idx</span><span class="p">])</span>

    <span class="c1"># Get min and max for each spatial dimension</span>
    <span class="n">voxel_mins</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">voxel_coords</span><span class="p">]</span>
    <span class="n">voxel_maxs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">voxel_coords</span>
    <span class="p">]</span>  <span class="c1"># +1 for inclusive max</span>

    <span class="c1"># Now we have voxel coordinates in the order they appear in dims</span>
    <span class="c1"># We don&#39;t need to convert to (x, y, z) order for physical coordinates</span>
    <span class="c1">#  since the affine should do this already..</span>

    <span class="c1"># make homog coords so we can matrix mult</span>
    <span class="n">voxel_min_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">voxel_mins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">voxel_mins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">voxel_mins</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="mf">1.0</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">voxel_max_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">voxel_maxs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">voxel_maxs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">voxel_maxs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="mf">1.0</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Transform to physical coordinates using affine</span>
    <span class="n">affine_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">affine</span><span class="o">.</span><span class="n">matrix</span>
    <span class="n">physical_min</span> <span class="o">=</span> <span class="n">affine_matrix</span> <span class="o">@</span> <span class="n">voxel_min_xyz</span>
    <span class="n">physical_max</span> <span class="o">=</span> <span class="n">affine_matrix</span> <span class="o">@</span> <span class="n">voxel_max_xyz</span>

    <span class="c1"># Return as tuples of (x, y, z) in physical space</span>
    <span class="n">bbox_min</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">physical_min</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="n">bbox_max</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">physical_max</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">bbox_min</span><span class="p">,</span> <span class="n">bbox_max</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.sample_region_patches" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">sample_region_patches</span><span class="p">(</span><span class="n">n_patches</span><span class="p">,</span> <span class="n">region_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Sample random coordinates (centers) within atlas regions.</p>
<p>This method generates a list of center coordinates by randomly sampling
voxels within the selected atlas regions. The returned coordinates are
in physical/world space (mm) and can be used with crop_centered() to
extract fixed-size patches for machine learning training or other workflows.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>n_patches</code></b>
              (<code><span title="int">int</span></code>)
          
          <div class="doc-md-description">
            <p>Number of patch centers to sample</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>region_ids</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="str">str</span>, <span title="typing.List">List</span>[<span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="str">str</span>]]]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Region identifier(s) to sample from. Can be:
- Single int: label index
- Single str: region name or abbreviation
- List[int/str]: multiple regions by index, name, or abbreviation
- None: use regex parameter instead</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>regex</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Regular expression to match region names. If provided,
region_ids must be None. Case-insensitive matching.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>seed</code></b>
              (<code><span title="typing.Optional">Optional</span>[<span title="int">int</span>]</code>, default:
                  <code>None</code>
)
          
          <div class="doc-md-description">
            <p>Random seed for reproducibility. If None, patches are sampled
randomly each time.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="typing.List">List</span>[<span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>]]</code>
          
          <div class="doc-md-description">
            <p>List of (x, y, z) coordinates in physical/world space (mm).</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.List">List</span>[<span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>]]</code>
          
          <div class="doc-md-description">
            <p>Each coordinate represents the center of a potential patch and</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="typing.List">List</span>[<span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>, <span title="float">float</span>]]</code>
          
          <div class="doc-md-description">
            <p>can be used with crop_centered() to extract fixed-size regions.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If no regions match the selection criteria, if both
region_ids and regex are provided/omitted, or if n_patches is
less than 1</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="TypeError">TypeError</span></code>
            
          <div class="doc-md-description">
            <p>If region_ids contains invalid types</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Sample 10 patch centers from hippocampus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centers</span> <span class="o">=</span> <span class="n">atlas</span><span class="o">.</span><span class="n">sample_region_patches</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">n_patches</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">region_ids</span><span class="o">=</span><span class="s2">&quot;Hippocampus&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">seed</span><span class="o">=</span><span class="mi">42</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Extract 256x256x256 voxel patches at each center</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patches</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">crop_centered</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">patch_size</span><span class="o">=</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Sample from multiple regions using list</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centers</span> <span class="o">=</span> <span class="n">atlas</span><span class="o">.</span><span class="n">sample_region_patches</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">n_patches</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">region_ids</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">seed</span><span class="o">=</span><span class="mi">42</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Sample using regex pattern</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centers</span> <span class="o">=</span> <span class="n">atlas</span><span class="o">.</span><span class="n">sample_region_patches</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">n_patches</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">regex</span><span class="o">=</span><span class="s2">&quot;.*cortex.*&quot;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
</code></pre></div>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Coordinates are in physical space (mm), not voxel indices</li>
<li>Centers are sampled uniformly from voxels within selected regions</li>
<li>Use crop_centered() to extract fixed-size patches around these centers</li>
<li>For ML training with fixed patch sizes (e.g., 256x256x256 voxels),
  use a lower-resolution atlas to define masks, then crop at higher
  resolution using physical coordinates</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sample_region_patches</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n_patches</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">region_ids</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">regex</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample random coordinates (centers) within atlas regions.</span>

<span class="sd">    This method generates a list of center coordinates by randomly sampling</span>
<span class="sd">    voxels within the selected atlas regions. The returned coordinates are</span>
<span class="sd">    in physical/world space (mm) and can be used with crop_centered() to</span>
<span class="sd">    extract fixed-size patches for machine learning training or other workflows.</span>

<span class="sd">    Args:</span>
<span class="sd">        n_patches: Number of patch centers to sample</span>
<span class="sd">        region_ids: Region identifier(s) to sample from. Can be:</span>
<span class="sd">            - Single int: label index</span>
<span class="sd">            - Single str: region name or abbreviation</span>
<span class="sd">            - List[int/str]: multiple regions by index, name, or abbreviation</span>
<span class="sd">            - None: use regex parameter instead</span>
<span class="sd">        regex: Regular expression to match region names. If provided,</span>
<span class="sd">            region_ids must be None. Case-insensitive matching.</span>
<span class="sd">        seed: Random seed for reproducibility. If None, patches are sampled</span>
<span class="sd">            randomly each time.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of (x, y, z) coordinates in physical/world space (mm).</span>
<span class="sd">        Each coordinate represents the center of a potential patch and</span>
<span class="sd">        can be used with crop_centered() to extract fixed-size regions.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If no regions match the selection criteria, if both</span>
<span class="sd">            region_ids and regex are provided/omitted, or if n_patches is</span>
<span class="sd">            less than 1</span>
<span class="sd">        TypeError: If region_ids contains invalid types</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Sample 10 patch centers from hippocampus</span>
<span class="sd">        &gt;&gt;&gt; centers = atlas.sample_region_patches(</span>
<span class="sd">        ...     n_patches=10,</span>
<span class="sd">        ...     region_ids=&quot;Hippocampus&quot;,</span>
<span class="sd">        ...     seed=42</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; # Extract 256x256x256 voxel patches at each center</span>
<span class="sd">        &gt;&gt;&gt; patches = image.crop_centered(centers, patch_size=(256, 256, 256))</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Sample from multiple regions using list</span>
<span class="sd">        &gt;&gt;&gt; centers = atlas.sample_region_patches(</span>
<span class="sd">        ...     n_patches=20,</span>
<span class="sd">        ...     region_ids=[1, 2, 3],</span>
<span class="sd">        ...     seed=42</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Sample using regex pattern</span>
<span class="sd">        &gt;&gt;&gt; centers = atlas.sample_region_patches(</span>
<span class="sd">        ...     n_patches=5,</span>
<span class="sd">        ...     regex=&quot;.*cortex.*&quot;,</span>
<span class="sd">        ... )</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Coordinates are in physical space (mm), not voxel indices</span>
<span class="sd">        - Centers are sampled uniformly from voxels within selected regions</span>
<span class="sd">        - Use crop_centered() to extract fixed-size patches around these centers</span>
<span class="sd">        - For ML training with fixed patch sizes (e.g., 256x256x256 voxels),</span>
<span class="sd">          use a lower-resolution atlas to define masks, then crop at higher</span>
<span class="sd">          resolution using physical coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

    <span class="kn">import</span><span class="w"> </span><span class="nn">dask.array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">da</span>

    <span class="c1"># Validate input</span>
    <span class="k">if</span> <span class="n">n_patches</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_patches must be at least 1, got </span><span class="si">{</span><span class="n">n_patches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">region_ids</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">regex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide either region_ids or regex parameter&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">region_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">regex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot provide both region_ids and regex parameters&quot;</span><span class="p">)</span>

    <span class="c1"># Set random seed if provided</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="c1"># Determine which labels to include (reuse logic from get_region_bounding_box)</span>
    <span class="n">selected_labels</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">regex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Match regions using regex</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">region_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name_column</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">region_name</span><span class="p">):</span>
                <span class="n">selected_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label_column</span><span class="p">]))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">selected_labels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No regions matched regex pattern: </span><span class="si">{</span><span class="n">regex</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Convert region_ids to list if single value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region_ids</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">region_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">region_ids</span><span class="p">]</span>

        <span class="c1"># Resolve each region identifier to label</span>
        <span class="k">for</span> <span class="n">region_id</span> <span class="ow">in</span> <span class="n">region_ids</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_region_identifier</span><span class="p">(</span><span class="n">region_id</span><span class="p">)</span>
            <span class="n">selected_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

    <span class="c1"># Create union mask of all selected regions</span>
    <span class="n">dseg_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">data</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">selected_labels</span><span class="p">:</span>
        <span class="n">region_mask</span> <span class="o">=</span> <span class="n">dseg_data</span> <span class="o">==</span> <span class="n">label</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">region_mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">|</span> <span class="n">region_mask</span>

    <span class="c1"># Find voxel coordinates where mask is True</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="c1"># Compute the indices to get actual coordinates</span>
    <span class="n">indices_computed</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

    <span class="c1"># Check if any voxels were found</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices_computed</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No voxels found for selected regions: </span><span class="si">{</span><span class="n">selected_labels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Get number of valid voxels</span>
    <span class="n">n_voxels</span> <span class="o">=</span> <span class="n">indices_computed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>

    <span class="c1"># Sample random voxels</span>
    <span class="c1"># If n_patches &gt; n_voxels, sample with replacement</span>
    <span class="n">replace</span> <span class="o">=</span> <span class="n">n_patches</span> <span class="o">&gt;</span> <span class="n">n_voxels</span>
    <span class="n">sampled_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n_voxels</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_patches</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>

    <span class="c1"># Get spatial dimensions (skip non-spatial like &#39;c&#39;, &#39;t&#39;)</span>
    <span class="n">spatial_dims_lower</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]]</span>
    <span class="n">spatial_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">spatial_dims_lower</span><span class="p">:</span>
            <span class="n">spatial_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># Build voxel coordinates for sampled centers</span>
    <span class="n">sampled_coords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">spatial_idx</span> <span class="ow">in</span> <span class="n">spatial_indices</span><span class="p">:</span>
        <span class="n">sampled_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices_computed</span><span class="p">[</span><span class="n">spatial_idx</span><span class="p">][</span><span class="n">sampled_indices</span><span class="p">])</span>

    <span class="c1"># Map to x, y, z order</span>
    <span class="n">dim_to_coords</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">spatial_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spatial_indices</span><span class="p">):</span>
        <span class="n">dim_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">spatial_idx</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">dim_to_coords</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampled_coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Get affine matrix</span>
    <span class="n">affine_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">affine</span><span class="o">.</span><span class="n">matrix</span>

    <span class="c1"># Generate center coordinates in physical space</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_patches</span><span class="p">):</span>
        <span class="c1"># Get center voxel coordinates in (x, y, z) order</span>
        <span class="n">center_voxel_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">dim_to_coords</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                <span class="n">dim_to_coords</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                <span class="n">dim_to_coords</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                <span class="mf">1.0</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Transform to physical coordinates</span>
        <span class="n">center_physical</span> <span class="o">=</span> <span class="n">affine_matrix</span> <span class="o">@</span> <span class="n">center_voxel_xyz</span>
        <span class="n">center_xyz</span> <span class="o">=</span> <span class="n">center_physical</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># Convert to tuple</span>
        <span class="n">center</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">center_xyz</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">centers</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.ZarrNiiAtlas.label_centroids" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">ZarrNiiAtlas</span><span class="o">.</span><span class="n">label_centroids</span><span class="p">(</span><span class="n">centroids</span><span class="p">,</span> <span class="n">include_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Map centroids to atlas labels using nearest neighbor interpolation.</p>
<p>This method takes a set of centroids (typically from compute_centroids)
and determines which atlas region each centroid falls into. It uses
nearest neighbor interpolation to assign labels, making it robust to
small coordinate mismatches.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>centroids</code></b>
              (<code><span title="numpy.ndarray">ndarray</span></code>)
          
          <div class="doc-md-description">
            <p>Nx3 numpy array of centroid coordinates in physical space
(typically output from compute_centroids). Each row is [x, y, z]
in physical/world coordinates (mm). Can also be an empty array (0, 3).</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>include_names</code></b>
              (<code><span title="bool">bool</span></code>, default:
                  <code>True</code>
)
          
          <div class="doc-md-description">
            <p>If True, includes region names from the labels dataframe
in the output (default: True).</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="tuple">tuple</span>[<span title="pandas.DataFrame">DataFrame</span>, <span title="pandas.DataFrame">DataFrame</span>]</code>
          
          <div class="doc-md-description">
            <p>tuple of two pandas DataFrames:
1. centroids DataFrame with columns:
    - x, y, z: Physical coordinates (in mm) of each centroid
    - index: Integer label index from the atlas
    - name (optional): Region name if include_names=True
2. counts DataFrame with columns:
    - index: Integer label index from the atlas
    - name (optional): Region name if include_names=True
    - count: Number of centroids in each region</p>
          </div>
        </li>
    </ul>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Input centroids must be in the same physical space as the atlas</li>
<li>Points outside the atlas bounds receive index=0 (background)</li>
<li>Uses scipy.interpolate.interpn with method='nearest' for label lookup</li>
</ul>
</details>

<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute centroids from a segmentation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroids</span> <span class="o">=</span> <span class="n">binary_seg</span><span class="o">.</span><span class="n">compute_centroids</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Map centroids to atlas labels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_centroids</span><span class="p">,</span> <span class="n">df_counts</span> <span class="o">=</span> <span class="n">atlas</span><span class="o">.</span><span class="n">label_centroids</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df_centroids</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df_counts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Filter to specific regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hippocampus_points</span> <span class="o">=</span> <span class="n">df_centroids</span><span class="p">[</span>
<span class="gp">... </span>    <span class="n">df_centroids</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Hippocampus&#39;</span>
<span class="gp">... </span><span class="p">]</span>
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>zarrnii/atlas.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">label_centroids</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">centroids</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">include_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Map centroids to atlas labels using nearest neighbor interpolation.</span>

<span class="sd">    This method takes a set of centroids (typically from compute_centroids)</span>
<span class="sd">    and determines which atlas region each centroid falls into. It uses</span>
<span class="sd">    nearest neighbor interpolation to assign labels, making it robust to</span>
<span class="sd">    small coordinate mismatches.</span>

<span class="sd">    Args:</span>
<span class="sd">        centroids: Nx3 numpy array of centroid coordinates in physical space</span>
<span class="sd">            (typically output from compute_centroids). Each row is [x, y, z]</span>
<span class="sd">            in physical/world coordinates (mm). Can also be an empty array (0, 3).</span>
<span class="sd">        include_names: If True, includes region names from the labels dataframe</span>
<span class="sd">            in the output (default: True).</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple of two pandas DataFrames:</span>
<span class="sd">            1. centroids DataFrame with columns:</span>
<span class="sd">                - x, y, z: Physical coordinates (in mm) of each centroid</span>
<span class="sd">                - index: Integer label index from the atlas</span>
<span class="sd">                - name (optional): Region name if include_names=True</span>
<span class="sd">            2. counts DataFrame with columns:</span>
<span class="sd">                - index: Integer label index from the atlas</span>
<span class="sd">                - name (optional): Region name if include_names=True</span>
<span class="sd">                - count: Number of centroids in each region</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Input centroids must be in the same physical space as the atlas</span>
<span class="sd">        - Points outside the atlas bounds receive index=0 (background)</span>
<span class="sd">        - Uses scipy.interpolate.interpn with method=&#39;nearest&#39; for label lookup</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # Compute centroids from a segmentation</span>
<span class="sd">        &gt;&gt;&gt; centroids = binary_seg.compute_centroids()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Map centroids to atlas labels</span>
<span class="sd">        &gt;&gt;&gt; df_centroids, df_counts = atlas.label_centroids(centroids)</span>
<span class="sd">        &gt;&gt;&gt; print(df_centroids)</span>
<span class="sd">        &gt;&gt;&gt; print(df_counts)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Filter to specific regions</span>
<span class="sd">        &gt;&gt;&gt; hippocampus_points = df_centroids[</span>
<span class="sd">        ...     df_centroids[&#39;name&#39;] == &#39;Hippocampus&#39;</span>
<span class="sd">        ... ]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Handle empty centroids array</span>
    <span class="k">if</span> <span class="n">centroids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">columns_centroids</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">]</span>
        <span class="n">columns_counts</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">include_names</span><span class="p">:</span>
            <span class="n">columns_centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
            <span class="n">columns_counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
        <span class="n">columns_counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns_centroids</span><span class="p">),</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns_counts</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="c1"># Validate input shape</span>
    <span class="k">if</span> <span class="n">centroids</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">centroids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;centroids must be Nx3 array, got shape </span><span class="si">{</span><span class="n">centroids</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Get atlas data and affine</span>
    <span class="n">dseg_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">data</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dseg_data</span><span class="p">,</span> <span class="s2">&quot;compute&quot;</span><span class="p">):</span>
        <span class="n">dseg_data</span> <span class="o">=</span> <span class="n">dseg_data</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

    <span class="n">affine_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dseg</span><span class="o">.</span><span class="n">affine</span><span class="o">.</span><span class="n">matrix</span>

    <span class="c1"># Convert physical coordinates to voxel coordinates</span>
    <span class="c1"># centroids are in (x, y, z) order</span>
    <span class="c1"># Create homogeneous coordinates</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="n">centroids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">centroids_homogeneous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">centroids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span>
    <span class="p">)</span>

    <span class="c1"># Apply inverse affine transform</span>
    <span class="n">affine_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">affine_matrix</span><span class="p">)</span>
    <span class="n">voxel_coords_homogeneous</span> <span class="o">=</span> <span class="n">centroids_homogeneous</span> <span class="o">@</span> <span class="n">affine_inv</span><span class="o">.</span><span class="n">T</span>
    <span class="n">voxel_coords</span> <span class="o">=</span> <span class="n">voxel_coords_homogeneous</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1"># Create grid for interpn</span>
    <span class="c1"># Grid should be in the order of the data array dimensions</span>
    <span class="c1"># For ZarrNii, this is typically (z, y, x) or (c, z, y, x)</span>
    <span class="c1"># Remove channel dimension if present</span>
    <span class="k">if</span> <span class="n">dseg_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">dseg_data</span> <span class="o">=</span> <span class="n">dseg_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Remove channel dimension</span>

    <span class="c1"># Create coordinate grids for each dimension</span>
    <span class="c1"># interpn expects a tuple of 1D arrays representing the grid coordinates</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">dseg_data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>

    <span class="c1"># The inverse affine transform already converted physical (x, y, z) coordinates</span>
    <span class="c1"># to voxel coordinates in the order matching the data array axes_order.</span>
    <span class="c1"># So voxel_coords is already in the correct order for interpn!</span>

    <span class="c1"># Use interpn to get labels at the centroid locations</span>
    <span class="n">label_at_points</span> <span class="o">=</span> <span class="n">interpn</span><span class="p">(</span>
        <span class="n">grid</span><span class="p">,</span>
        <span class="n">dseg_data</span><span class="p">,</span>
        <span class="n">voxel_coords</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Convert to integer labels</span>
    <span class="n">label_at_points</span> <span class="o">=</span> <span class="n">label_at_points</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Create DataFrame with x, y, z columns</span>
    <span class="c1"># centroids are in (x, y, z) order, so we use that order for output</span>
    <span class="n">df_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">centroids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># x from centroids</span>
        <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">centroids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># y from centroids</span>
        <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">centroids</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>  <span class="c1"># z from centroids</span>
        <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">label_at_points</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Add region names if requested</span>
    <span class="k">if</span> <span class="n">include_names</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Create a lookup from index to name</span>
        <span class="n">label_to_name</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labels_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label_column</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labels_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name_column</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Map labels to names, use &#39;Unknown&#39; for labels not in lookup table</span>
        <span class="n">df_data</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">label_to_name</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unknown_Label_</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">label_at_points</span>
        <span class="p">]</span>

    <span class="n">df_centroids</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">df_data</span><span class="p">)</span>

    <span class="c1"># Create counts DataFrame - group by index and optionally name</span>
    <span class="k">if</span> <span class="n">include_names</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df_counts</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df_centroids</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;count&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df_counts</span> <span class="o">=</span> <span class="n">df_centroids</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;index&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;count&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">df_centroids</span><span class="p">,</span> <span class="n">df_counts</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<a id="zarrnii.transform.AffineTransform"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="zarrnii.transform.Transform">Transform</span></code></p>


        <p>Affine transformation for spatial coordinate mapping.</p>
<p>Represents a 4x4 affine transformation matrix that can be used to transform
3D coordinates between different coordinate systems. Supports various
operations including matrix multiplication, inversion, and point transformation.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <ul>
        <li class="doc-section-item field-body">
          <b><code><span title="zarrnii.transform.AffineTransform.matrix">matrix</span></code></b>
              (<code><span title="numpy.ndarray">ndarray</span></code>)
          
          <div class="doc-md-description">
            <p>4x4 affine transformation matrix</p>
          </div>
        </li>
    </ul>











  <div class="doc doc-children">








<h2 id="zarrnii.transform.AffineTransform-functions">Functions</h2>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.transform.AffineTransform.from_txt" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">AffineTransform</span><span class="o">.</span><span class="n">from_txt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create AffineTransform from text file containing matrix.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>path</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="bytes">bytes</span>]</code>)
          
          <div class="doc-md-description">
            <p>Path to text file containing 4x4 affine matrix</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>invert</code></b>
              (<code><span title="bool">bool</span></code>, default:
                  <code>False</code>
)
          
          <div class="doc-md-description">
            <p>Whether to invert the matrix after loading</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;AffineTransform&#39;</code>
          
          <div class="doc-md-description">
            <p>AffineTransform instance with loaded matrix</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="OSError">OSError</span></code>
            
          <div class="doc-md-description">
            <p>If file cannot be read</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If file does not contain valid 4x4 matrix</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/transform.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_txt</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">],</span> <span class="n">invert</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AffineTransform&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create AffineTransform from text file containing matrix.</span>

<span class="sd">    Args:</span>
<span class="sd">        path: Path to text file containing 4x4 affine matrix</span>
<span class="sd">        invert: Whether to invert the matrix after loading</span>

<span class="sd">    Returns:</span>
<span class="sd">        AffineTransform instance with loaded matrix</span>

<span class="sd">    Raises:</span>
<span class="sd">        OSError: If file cannot be read</span>
<span class="sd">        ValueError: If file does not contain valid 4x4 matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.transform.AffineTransform.from_array" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">AffineTransform</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create AffineTransform from numpy array.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>matrix</code></b>
              (<code><span title="numpy.ndarray">ndarray</span></code>)
          
          <div class="doc-md-description">
            <p>4x4 numpy array representing affine transformation</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>invert</code></b>
              (<code><span title="bool">bool</span></code>, default:
                  <code>False</code>
)
          
          <div class="doc-md-description">
            <p>Whether to invert the matrix</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;AffineTransform&#39;</code>
          
          <div class="doc-md-description">
            <p>AffineTransform instance with the matrix</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If matrix is not 4x4</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/transform.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span>
<span class="normal">97</span>
<span class="normal">98</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_array</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">invert</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AffineTransform&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create AffineTransform from numpy array.</span>

<span class="sd">    Args:</span>
<span class="sd">        matrix: 4x4 numpy array representing affine transformation</span>
<span class="sd">        invert: Whether to invert the matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        AffineTransform instance with the matrix</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If matrix is not 4x4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matrix must be 4x4, got shape </span><span class="si">{</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.transform.AffineTransform.identity" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">AffineTransform</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create identity transformation.</p>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;AffineTransform&#39;</code>
          
          <div class="doc-md-description">
            <p>AffineTransform representing identity transformation (no change)</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/transform.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">identity</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AffineTransform&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create identity transformation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        AffineTransform representing identity transformation (no change)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.transform.AffineTransform.apply_transform" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">AffineTransform</span><span class="o">.</span><span class="n">apply_transform</span><span class="p">(</span><span class="n">vecs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Apply transformation to coordinate vectors.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>vecs</code></b>
              (<code><span title="numpy.ndarray">ndarray</span></code>)
          
          <div class="doc-md-description">
            <p>Input coordinates to transform</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="numpy.ndarray">ndarray</span></code>
          
          <div class="doc-md-description">
            <p>Transformed coordinates</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/transform.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apply_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vecs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply transformation to coordinate vectors.</span>

<span class="sd">    Args:</span>
<span class="sd">        vecs: Input coordinates to transform</span>

<span class="sd">    Returns:</span>
<span class="sd">        Transformed coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span> <span class="o">@</span> <span class="n">vecs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.transform.AffineTransform.invert" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">AffineTransform</span><span class="o">.</span><span class="n">invert</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Return the inverse of the matrix transformation.</p>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;AffineTransform&#39;</code>
          
          <div class="doc-md-description">
            <p>New AffineTransform with inverted matrix</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="numpy.linalg.LinAlgError">LinAlgError</span></code>
            
          <div class="doc-md-description">
            <p>If matrix is singular and cannot be inverted</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/transform.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AffineTransform&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the inverse of the matrix transformation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        New AffineTransform with inverted matrix</span>

<span class="sd">    Raises:</span>
<span class="sd">        np.linalg.LinAlgError: If matrix is singular and cannot be inverted</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">AffineTransform</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.transform.AffineTransform.update_for_orientation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">AffineTransform</span><span class="o">.</span><span class="n">update_for_orientation</span><span class="p">(</span><span class="n">input_orientation</span><span class="p">,</span> <span class="n">output_orientation</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Update the matrix to map from input orientation to output orientation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>input_orientation</code></b>
              (<code><span title="str">str</span></code>)
          
          <div class="doc-md-description">
            <p>Current anatomical orientation (e.g., 'RPI')</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>output_orientation</code></b>
              (<code><span title="str">str</span></code>)
          
          <div class="doc-md-description">
            <p>Target anatomical orientation (e.g., 'RAS')</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;AffineTransform&#39;</code>
          
          <div class="doc-md-description">
            <p>New AffineTransform updated for orientation mapping</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If orientations are invalid or cannot be matched</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/transform.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">update_for_orientation</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">input_orientation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_orientation</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;AffineTransform&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the matrix to map from input orientation to output orientation.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_orientation: Current anatomical orientation (e.g., &#39;RPI&#39;)</span>
<span class="sd">        output_orientation: Target anatomical orientation (e.g., &#39;RAS&#39;)</span>

<span class="sd">    Returns:</span>
<span class="sd">        New AffineTransform updated for orientation mapping</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If orientations are invalid or cannot be matched</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define a mapping of anatomical directions to axis indices and flips</span>
    <span class="n">axis_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;R&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="s2">&quot;L&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
        <span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
        <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="s2">&quot;I&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="c1"># Parse the input and output orientations</span>
    <span class="n">input_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis_map</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">input_orientation</span><span class="p">]</span>
    <span class="n">output_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis_map</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">output_orientation</span><span class="p">]</span>

    <span class="c1"># Create a mapping from input to output</span>
    <span class="n">reorder_indices</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
    <span class="n">flip_signs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>

    <span class="k">for</span> <span class="n">out_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">out_axis</span><span class="p">,</span> <span class="n">out_sign</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_axes</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">in_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">in_axis</span><span class="p">,</span> <span class="n">in_sign</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_axes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">out_axis</span> <span class="o">==</span> <span class="n">in_axis</span><span class="p">:</span>  <span class="c1"># Match axis</span>
                <span class="n">reorder_indices</span><span class="p">[</span><span class="n">out_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_idx</span>
                <span class="n">flip_signs</span><span class="p">[</span><span class="n">out_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_sign</span> <span class="o">*</span> <span class="n">in_sign</span>
                <span class="k">break</span>

    <span class="c1"># Reorder and flip the affine matrix</span>
    <span class="n">reordered_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">reorder_idx</span><span class="p">,</span> <span class="n">flip_sign</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">reorder_indices</span><span class="p">,</span> <span class="n">flip_signs</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">reorder_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot match all axes from </span><span class="si">{</span><span class="n">input_orientation</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">output_orientation</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="n">reordered_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">flip_sign</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">reorder_idx</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">reordered_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">flip_sign</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">reorder_idx</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">reordered_matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># Preserve the homogeneous row</span>

    <span class="k">return</span> <span class="n">AffineTransform</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">reordered_matrix</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<a id="zarrnii.transform.DisplacementTransform"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="zarrnii.transform.Transform">Transform</span></code></p>


        <p>Non-linear displacement field transformation.</p>
<p>Represents a displacement field transformation where each point in space
has an associated displacement vector. Uses interpolation to compute
displacements for arbitrary coordinates.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <ul>
        <li class="doc-section-item field-body">
          <b><code><span title="zarrnii.transform.DisplacementTransform.disp_xyz">disp_xyz</span></code></b>
              (<code><span title="numpy.ndarray">ndarray</span></code>)
          
          <div class="doc-md-description">
            <p>Displacement vectors at grid points (4D array: x, y, z, vector_component)</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
          <b><code><span title="zarrnii.transform.DisplacementTransform.disp_grid">disp_grid</span></code></b>
              (<code><span title="typing.Tuple">Tuple</span>[<span title="numpy.ndarray">ndarray</span>, ...]</code>)
          
          <div class="doc-md-description">
            <p>Grid coordinates for displacement field</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
          <b><code><span title="zarrnii.transform.DisplacementTransform.disp_affine">disp_affine</span></code></b>
              (<code><a class="autorefs autorefs-internal" title="zarrnii.transform.AffineTransform" href="#zarrnii.transform.AffineTransform">AffineTransform</a></code>)
          
          <div class="doc-md-description">
            <p>Affine transformation from world to displacement field coordinates</p>
          </div>
        </li>
    </ul>











  <div class="doc doc-children">








<h2 id="zarrnii.transform.DisplacementTransform-functions">Functions</h2>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.transform.DisplacementTransform.from_nifti" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">DisplacementTransform</span><span class="o">.</span><span class="n">from_nifti</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create DisplacementTransform from NIfTI file.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>path</code></b>
              (<code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="bytes">bytes</span>]</code>)
          
          <div class="doc-md-description">
            <p>Path to NIfTI displacement field file</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>&#39;DisplacementTransform&#39;</code>
          
          <div class="doc-md-description">
            <p>DisplacementTransform instance loaded from file</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="OSError">OSError</span></code>
            
          <div class="doc-md-description">
            <p>If file cannot be read</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="ValueError">ValueError</span></code>
            
          <div class="doc-md-description">
            <p>If file format is invalid</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>zarrnii/transform.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_nifti</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;DisplacementTransform&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create DisplacementTransform from NIfTI file.</span>

<span class="sd">    Args:</span>
<span class="sd">        path: Path to NIfTI displacement field file</span>

<span class="sd">    Returns:</span>
<span class="sd">        DisplacementTransform instance loaded from file</span>

<span class="sd">    Raises:</span>
<span class="sd">        OSError: If file cannot be read</span>
<span class="sd">        ValueError: If file format is invalid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">disp_nib</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">disp_xyz</span> <span class="o">=</span> <span class="n">disp_nib</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">disp_affine</span> <span class="o">=</span> <span class="n">AffineTransform</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">disp_nib</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span>

    <span class="c1"># Convert from ITK transform convention</span>
    <span class="c1"># ITK uses opposite sign convention for x and y displacements</span>
    <span class="n">disp_xyz</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">disp_xyz</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">disp_xyz</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">disp_xyz</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Create grid coordinates</span>
    <span class="n">disp_grid</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">disp_xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">disp_xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">disp_xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
        <span class="n">disp_xyz</span><span class="o">=</span><span class="n">disp_xyz</span><span class="p">,</span>
        <span class="n">disp_grid</span><span class="o">=</span><span class="n">disp_grid</span><span class="p">,</span>
        <span class="n">disp_affine</span><span class="o">=</span><span class="n">disp_affine</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="zarrnii.transform.DisplacementTransform.apply_transform" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">zarrnii</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">DisplacementTransform</span><span class="o">.</span><span class="n">apply_transform</span><span class="p">(</span><span class="n">vecs</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Apply displacement transformation to coordinate vectors.</p>
<p>Transforms input coordinates by interpolating displacement vectors
from the displacement field and adding them to the input coordinates.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>vecs</code></b>
              (<code><span title="numpy.ndarray">ndarray</span></code>)
          
          <div class="doc-md-description">
            <p>Input coordinates as numpy array. Shape should be (3, N) for
N points or (3,) for single point</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="numpy.ndarray">ndarray</span></code>
          
          <div class="doc-md-description">
            <p>Transformed coordinates with same shape as input</p>
          </div>
        </li>
    </ul>


<details class="notes" open>
  <summary>Notes</summary>
  <p>Points outside the displacement field domain are filled with
zero displacement (no transformation).</p>
</details>

            <details class="quote">
              <summary>Source code in <code>zarrnii/transform.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">apply_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vecs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply displacement transformation to coordinate vectors.</span>

<span class="sd">    Transforms input coordinates by interpolating displacement vectors</span>
<span class="sd">    from the displacement field and adding them to the input coordinates.</span>

<span class="sd">    Args:</span>
<span class="sd">        vecs: Input coordinates as numpy array. Shape should be (3, N) for</span>
<span class="sd">            N points or (3,) for single point</span>

<span class="sd">    Returns:</span>
<span class="sd">        Transformed coordinates with same shape as input</span>

<span class="sd">    Notes:</span>
<span class="sd">        Points outside the displacement field domain are filled with</span>
<span class="sd">        zero displacement (no transformation).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Transform points to voxel space of the displacement field</span>
    <span class="n">vox_vecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">disp_affine</span><span class="o">.</span><span class="n">invert</span><span class="p">()</span> <span class="o">@</span> <span class="n">vecs</span>

    <span class="c1"># Initialize displacement vectors</span>
    <span class="n">disp_vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vox_vecs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Interpolate displacement for each spatial dimension (x, y, z)</span>
    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">disp_vecs</span><span class="p">[</span><span class="n">ax</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">interpn</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">disp_grid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">disp_xyz</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span>
            <span class="n">vox_vecs</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
            <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Add displacement to original coordinates</span>
    <span class="k">return</span> <span class="n">vecs</span> <span class="o">+</span> <span class="n">disp_vecs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
    
  </body>
</html>